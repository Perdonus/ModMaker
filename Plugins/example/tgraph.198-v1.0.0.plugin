__id__ = "tgraph_neko"
__name__ = "Tgraph"
__description__ = """–£–¥–æ–±–Ω–∞—è —Ä–∞–±–æ—Ç–∞ —Å telegra.ph

–°–æ–∑–¥–∞–≤–∞–π—Ç–µ —Å—Ç–∞—Ç—å–∏ –ø—Ä—è–º–æ –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –ø–ª–∞–≥–∏–Ω–∞! –¢–æ–∫–µ–Ω –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏."""
__author__ = "@pl_meow"
__version__ = "1.0.0"
__icon__ = "kitty_cats_vk/12"
__min_version__ = "11.12.1"

import requests
import json
import os
import traceback
from typing import Any

from base_plugin import BasePlugin
from ui.settings import Header, Input, Text, Divider, Switch, EditText, Selector
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from markdown_utils import parse_markdown
from android_utils import log, run_on_ui_thread
from client_utils import run_on_queue, get_last_fragment
from org.telegram.ui import MessageSendPreview, ChatActivity, DialogsActivity
from org.telegram.ui.Components import ItemOptions
from org.telegram.messenger import R, SendMessagesHelper, UserConfig, MessagesController, Utilities, MediaController
from java.lang import Runnable, Class
from java.util import ArrayList
from java import cast
from java import dynamic_proxy
import datetime
from android.os import Bundle
from hook_utils import find_class, get_private_field
from base_plugin import MethodHook, HookResult, HookStrategy
from client_utils import send_message, send_request, RequestCallback
from org.telegram.tgnet import TLRPC
import time

class RunnableImpl(dynamic_proxy(Runnable)):
    def __init__(self, func):
        super().__init__()
        self.func = func
    def run(self):
        try:
            self.func()
        except Exception as e:
            log(f"RunnableImpl Error: {e}")

class _SendMenuHook(MethodHook):
    def __init__(self, plugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        try:
            item_options = param.args[0]
            if not item_options:
                return

            fragment = get_last_fragment()
            # Relaxed check to support ExternalActionActivity (Share from other apps)
            if not fragment:
                return
            
            text = self.plugin._get_current_input_text(fragment)
            media_paths = self.plugin._get_selected_media_paths()
            
            if (not text or not text.strip()) and not media_paths:
                return

            def on_click_action():
                try:
                    item_options.dismiss()
                except Exception:
                    pass
                self.plugin._handle_send_as_telegraph(fragment, text, media_paths)
            # –ü–æ–ø—ã—Ç–∫–∞ –Ω–∞–π—Ç–∏ –∏–∫–æ–Ω–∫—É, –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Ñ–æ–ª–ª–±—ç–∫
            icon_res = getattr(R.drawable, "msg_link", getattr(R.drawable, "ic_link", 0))
            if icon_res != 0:
                item_options.add(icon_res, "–û—Ç–ø—Ä–∞–≤–∏—Ç—å –∫–∞–∫ Telegraph", RunnableImpl(on_click_action))
        except Exception as e:
            log(f"_SendMenuHook Error: {e}")
# –ü–æ–ª—É—á–∞–µ–º –∫–ª–∞—Å—Å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ
DialogsActivityDelegate = find_class("org.telegram.ui.DialogsActivity$DialogsActivityDelegate")

class SelectChatDelegate(dynamic_proxy(DialogsActivityDelegate)):
    def __init__(self, plugin, url):
        super().__init__()
        self.plugin = plugin
        self.url = url

    def didSelectDialogs(self, *args):
        try:
            # args[0] -> fragment, args[1] -> dids (ArrayList), args[2] -> message, args[3] -> paramBoolean
            if len(args) > 1:
                dids = args[1]
                if dids and not dids.isEmpty():
                    selected = dids.get(0)
                    peer_id = selected
                    
                    # –û–±—Ä–∞–±–æ—Ç–∫–∞ TopicKey (–¥–ª—è —Ç–µ–º –≤ –≥—Ä—É–ø–ø–∞—Ö)
                    if hasattr(selected, "dialogId"):
                        peer_id = selected.dialogId
                    
                    # –ü—Ä–∏–≤–æ–¥–∏–º –∫ int (long) –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –ø–µ—Ä–µ–¥–∞—á–∏ –≤ JNI
                    try:
                        peer_id = int(peer_id)
                    except (ValueError, TypeError):
                        pass
                        
                    self.plugin._send_url_msg(peer_id, self.url)
            
            if len(args) > 0 and args[0]:
                args[0].finishFragment()
        except Exception as e:
            log(f"[{__id__}] SelectChatDelegate Error: {e}")
        return True

class TgraphPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.token = None
        self.hooks = []

    def on_plugin_load(self):
        # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ç–æ–∫–µ–Ω –∏–ª–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
        self.token = self.get_setting("telegraph_token", None)
        if not self.token:
            run_on_queue(self._generate_new_token)
        else:
            log(f"[{__id__}] Loaded existing token.")
        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º java.lang.Class.forName –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤ Class,
            # —Ç–∞–∫ –∫–∞–∫ find_class –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Python-–æ–±–µ—Ä—Ç–∫—É, —É –∫–æ—Ç–æ—Ä–æ–π –Ω–µ—Ç –º–µ—Ç–æ–¥–æ–≤ —Ä–µ—Ñ–ª–µ–∫—Å–∏–∏ (getDeclaredMethod).
            JClass = find_class("java.lang.Class")
            
            # –ü–æ–ª—É—á–∞–µ–º java.lang.Class –¥–ª—è —Ü–µ–ª–µ–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
            MessageSendPreview_Cls = JClass.forName("org.telegram.ui.MessageSendPreview")
            ItemOptions_Cls = JClass.forName("org.telegram.ui.Components.ItemOptions")
            
            if MessageSendPreview_Cls and ItemOptions_Cls:
                # –ò—â–µ–º –º–µ—Ç–æ–¥ setItemOptions(ItemOptions options)
                hook_method = MessageSendPreview_Cls.getDeclaredMethod("setItemOptions", ItemOptions_Cls)
                hook_method.setAccessible(True)
                
                self.hooks.append(self.hook_method(hook_method, _SendMenuHook(self)))
                log(f"[{__id__}] Hooked MessageSendPreview successfully.")
        except Exception as e:
            log(f"[{__id__}] Failed to hook MessageSendPreview: {e}")

    def _generate_new_token(self):
        try:
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∞–∫–∫–∞—É–Ω—Ç –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞
            response = requests.get("https://api.telegra.ph/createAccount?short_name=ExteraUser&author_name=ExteraGram")
            data = response.json()
            if data.get("ok"):
                self.token = data["result"]["access_token"]
                self.set_setting("telegraph_token", self.token)
                log(f"[{__id__}] Generated new token: {self.token}")
                run_on_ui_thread(lambda: BulletinHelper.show_success("–¢–æ–∫–µ–Ω telegra.ph —Å–æ–∑–¥–∞–Ω!"))
                # –û–±–Ω–æ–≤–ª—è–µ–º UI –Ω–∞—Å—Ç—Ä–æ–µ–∫, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Ç–∞–º
                run_on_ui_thread(lambda: self._reload_settings())
            else:
                error_msg = data.get("error", "Unknown error")
                log(f"[{__id__}] Failed to create account: {error_msg}")
        except Exception as e:
            log(f"[{__id__}] Error generating token: {e}")

    def create_settings(self):
        token_display = self.token if self.token else "–ó–∞–≥—Ä—É–∑–∫–∞/–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç..."
        
        return [
            Header("–†–µ–¥–∞–∫—Ç–æ—Ä Tgraph"),
            Selector(
                key="title_mode",
                text="–ò—Å—Ç–æ—á–Ω–∏–∫ –∑–∞–≥–æ–ª–æ–≤–∫–∞",
                items=["–í—Ä–µ–º—è", "–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞", "–°–≤–æ–π —Ç–µ–∫—Å—Ç"],
                default=0,
                icon="msg_title"
            ),
            Input(
                key="tg_title",
                text="–ó–∞–≥–æ–ª–æ–≤–æ–∫",
                default="",
                subtext="–í–≤–µ–¥–∏—Ç–µ –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å—Ç–∞—Ç—å–∏",
                icon="msg_title"
            ),
            Input(
                key="tg_content",
                text="–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ",
                default="",
                subtext="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å—Ç–∞—Ç—å–∏ (–º–æ–∂–Ω–æ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π)...",
                icon="msg_text"
            ),
            Text(
                text="–°–æ–∑–¥–∞—Ç—å –ø–æ—Å—Ç",
                icon="msg_send",
                accent=True,
                on_click=self._on_create_click
            ),
            Divider(),
            Header("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –æ—Ç–ø—Ä–∞–≤–∫–∏"),
            Selector(
                key="send_mode",
                text="–í–∏–¥ —Å—Å—ã–ª–∫–∏",
                items=["¬∑‚Äî‚Äì‚Äî¬∑ (–°–∫—Ä—ã—Ç–∞—è)", "–ü—Ä–æ—Å—Ç–∞—è —Å—Å—ã–ª–∫–∞", "–°–≤–æ–π —Ç–µ–∫—Å—Ç"],
                default=0,
                icon="msg_link"
            ),
            Input(
                key="custom_link_text",
                text="–¢–µ–∫—Å—Ç —Å—Å—ã–ª–∫–∏",
                subtext="–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Ä–µ–∂–∏–º–µ '–°–≤–æ–π —Ç–µ–∫—Å—Ç'",
                default="–ß–∏—Ç–∞—Ç—å",
                icon="msg_text"
            ),
            Selector(
                key="preview_mode",
                text="–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä",
                items=["–°–Ω–∏–∑—É", "–°–≤–µ—Ä—Ö—É", "–°–∫—Ä—ã—Ç—å"],
                default=2,
                icon="msg_web"
            ),
            Divider(),
            Header("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞"),
            Text(
                text=f"–¢–µ–∫—É—â–∏–π —Ç–æ–∫–µ–Ω:\n{token_display}",
                icon="msg_key",
                on_click=self._copy_token
            ),
            Text(
                text="–°–º–µ–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω",
                icon="msg_edit",
                on_click=self._show_change_token_dialog
            ),
            Text(
                text="–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω",
                icon="msg_retry",
                red=True,
                on_click=self._force_new_token
            ),
            Divider(),
            Switch(key="debug", text="Debug —Ä–µ–∂–∏–º", default=False, icon="msg_log")
        ]
    def _prepare_content(self, text_input, title_setting):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç –∏ –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Å–æ–≥–ª–∞—Å–Ω–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º."""
        mode = self.get_setting("title_mode", 0)
        
        title = ""
        content = text_input

        if mode == 0: # –í—Ä–µ–º—è
            title = datetime.datetime.now().strftime("%H:%M:%S")
        
        elif mode == 1: # –ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞
            lines = text_input.split('\n')
            first_line_index = -1
            
            # –ò—â–µ–º –ø–µ—Ä–≤—É—é –Ω–µ–ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É
            for i, line in enumerate(lines):
                if line.strip():
                    title = line.strip()
                    first_line_index = i
                    break
            
            if first_line_index != -1:
                # –£–¥–∞–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∏–∑ —Ç–µ–ª–∞, —Å–æ—Ö—Ä–∞–Ω—è—è –æ—Å—Ç–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–Ω–æ—Å—ã
                # –ë–µ—Ä–µ–º —Å–ª–∞–π—Å –ø–æ—Å–ª–µ –Ω–∞–π–¥–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
                remaining_lines = lines[first_line_index + 1:]
                # –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏ –≤ –Ω–∞—á–∞–ª–µ –æ—Å—Ç–∞—Ç–∫–∞, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ, –∑–¥–µ—Å—å –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å –∏–ª–∏ —Å—Ç—Ä–∏–ø–∏–º)
                content = "\n".join(remaining_lines).strip()
            else:
                # –ï—Å–ª–∏ —Ç–µ–∫—Å—Ç –ø—É—Å—Ç–æ–π –∏–ª–∏ —Ç–æ–ª—å–∫–æ –ø—Ä–æ–±–µ–ª—ã
                title = "–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞"
                
        elif mode == 2: # –°–≤–æ–π —Ç–µ–∫—Å—Ç
            title = title_setting if title_setting else "–ë–µ–∑ –∑–∞–≥–æ–ª–æ–≤–∫–∞"

        return title, content

    def _on_create_click(self, view):
        raw_title = self.get_setting("tg_title", "")
        raw_content = self.get_setting("tg_content", "")
        
        if not raw_content:
            BulletinHelper.show_error("–ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Å–æ–¥–µ—Ä–∂–∞–Ω–∏–µ!")
            return
        
        if not self.token:
             BulletinHelper.show_error("–¢–æ–∫–µ–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç! –°–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –Ω–æ–≤—ã–π.")
             return

        title, content = self._prepare_content(raw_content, raw_title)

        BulletinHelper.show_info("–°–æ–∑–¥–∞—é —Å—Ç–∞—Ç—å—é...")
        run_on_queue(lambda: self._create_page_task(title, content))
    def _text_to_nodes(self, text):
        try:
            from markdown_utils import parse_markdown
            parsed = parse_markdown(text)
            text = parsed.text
            entities = [e.to_tlrpc_object() for e in parsed.entities]
        except Exception:
            # –ï—Å–ª–∏ –ø–∞—Ä—Å–∏–Ω–≥ –Ω–µ —É–¥–∞–ª—Å—è, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—Å—Ç –∫–∞–∫ –µ—Å—Ç—å
            # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—à–∏–±–∫–∏
            return [{"tag": "p", "children": [text]}] if text else []

        u16_text = text.encode('utf-16-le')
        
        def u16_slice(start, end):
            s = max(0, min(start * 2, len(u16_text)))
            e = max(0, min(end * 2, len(u16_text)))
            return u16_text[s:e].decode('utf-16-le')

        # 1. –í—ã–¥–µ–ª—è–µ–º –±–ª–æ–∫–∏ PRE (–∫–æ–¥), —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∏ –Ω–µ –¥–æ–ª–∂–Ω—ã –±–∏—Ç—å—Å—è –Ω–∞ –ø–∞—Ä–∞–≥—Ä–∞—Ñ—ã
        pre_blocks = [e for e in entities if isinstance(e, TLRPC.TL_messageEntityPre)]
        pre_blocks.sort(key=lambda x: x.offset)

        nodes = []
        cursor = 0

        def process_inline_text(start_offset, end_offset):
            chunk = u16_slice(start_offset, end_offset)
            if not chunk: return
            
            lines = chunk.split('\n')
            current_line_start = start_offset
            
            for line in lines:
                line_len = len(line.encode('utf-16-le')) // 2
                line_end = current_line_start + line_len
                
                p_node = {"tag": "p", "children": []}
                
                if not line:
                    # –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ -> <br>
                    p_node["children"].append({"tag": "br"})
                else:
                    # –°–æ–±–∏—Ä–∞–µ–º —Å—É—â–Ω–æ—Å—Ç–∏ –¥–ª—è —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏
                    relevant_entities = []
                    for e in entities:
                        if isinstance(e, TLRPC.TL_messageEntityPre): continue
                        
                        e_end = e.offset + e.length
                        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
                        if e.offset < line_end and e_end > current_line_start:
                            local_start = max(e.offset, current_line_start)
                            local_end = min(e_end, line_end)
                            relevant_entities.append({
                                'type': e,
                                'start': local_start - current_line_start,
                                'end': local_end - current_line_start
                            })
                    
                    # –†–∞–∑–±–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫—É –Ω–∞ —Å–µ–≥–º–µ–Ω—Ç—ã –ø–æ –≥—Ä–∞–Ω–∏—Ü–∞–º —Å—É—â–Ω–æ—Å—Ç–µ–π
                    points = {0, line_len}
                    for e in relevant_entities:
                        points.add(e['start'])
                        points.add(e['end'])
                    
                    sorted_points = sorted(list(points))
                    
                    for i in range(len(sorted_points) - 1):
                        seg_start = sorted_points[i]
                        seg_end = sorted_points[i+1]
                        seg_text = u16_slice(current_line_start + seg_start, current_line_start + seg_end)
                        
                        if not seg_text: continue
                        
                        active_ents = [ent['type'] for ent in relevant_entities 
                                       if ent['start'] <= seg_start and ent['end'] >= seg_end]
                        
                        current_node = seg_text
                        
                        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ç–µ–≥–∏. –ü–æ—Ä—è–¥–æ–∫: —Å—Å—ã–ª–∫–∞ -> –∫–æ–¥ -> —Å—Ç–∏–ª—å
                        for ent in active_ents:
                            tag = None
                            attrs = None
                            if isinstance(ent, TLRPC.TL_messageEntityBold): tag = "b"
                            elif isinstance(ent, TLRPC.TL_messageEntityItalic): tag = "i"
                            elif isinstance(ent, TLRPC.TL_messageEntityCode): tag = "code"
                            elif isinstance(ent, TLRPC.TL_messageEntityStrike): tag = "s"
                            elif isinstance(ent, TLRPC.TL_messageEntityUnderline): tag = "u"
                            elif isinstance(ent, TLRPC.TL_messageEntityTextUrl): 
                                tag = "a"
                                attrs = {"href": ent.url}
                            
                            if tag:
                                node = {"tag": tag, "children": [current_node]}
                                if attrs: node["attrs"] = attrs
                                current_node = node
                        
                        p_node["children"].append(current_node)

                nodes.append(p_node)
                current_line_start += line_len + 1

        for pre in pre_blocks:
            if cursor < pre.offset:
                process_inline_text(cursor, pre.offset)
            
            pre_content = u16_slice(pre.offset, pre.offset + pre.length)
            nodes.append({"tag": "pre", "children": [pre_content]})
            cursor = pre.offset + pre.length
            
        u16_total = len(u16_text) // 2
        if cursor < u16_total:
            process_inline_text(cursor, u16_total)
            
        return nodes

    def _create_page_task(self, title, text_content):
        try:
            # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º Markdown –≤ Nodes —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            content_nodes = self._text_to_nodes(text_content)
            content_json = json.dumps(content_nodes)
            
            url = "https://api.telegra.ph/createPage"
            # –ü–µ—Ä–µ–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞–∫ data (form-encoded), –∫–æ–Ω—Ç–µ–Ω—Ç –∫–∞–∫ JSON-—Å—Ç—Ä–æ–∫—É
            payload = {
                "access_token": self.token,
                "title": title,
                "content": content_json,
                "return_content": "false"
            }
            
            response = requests.post(url, data=payload, timeout=15)
            res_data = response.json()
            
            if res_data.get("ok"):
                page_url = res_data["result"]["url"]
                run_on_ui_thread(lambda: self._show_success_dialog(page_url))
                # –û—á–∏—â–∞–µ–º –ø–æ–ª—è –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
                self.set_setting("tg_title", "")
                self.set_setting("tg_content", "")
                run_on_ui_thread(lambda: self._reload_settings())
            else:
                error = res_data.get("error", "Unknown error")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ API: {error}"))
                
        except Exception as e:
            log(f"[{__id__}] Error creating page: {e}\n{traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ —Å–µ—Ç–∏/–∫–æ–¥–∞: {e}"))
    def _show_success_dialog(self, url):
        fragment = get_last_fragment()
        if not fragment: return
        
        activity = fragment.getParentActivity()
        builder = AlertDialogBuilder(activity)
        builder.set_title("–°—Ç–∞—Ç—å—è —Å–æ–∑–¥–∞–Ω–∞! üéâ")
        builder.set_message(f"–°—Å—ã–ª–∫–∞:\n{url}")
        
        def copy_action(d, w):
            from android.content import Context, ClipData
            clipboard = activity.getSystemService(Context.CLIPBOARD_SERVICE)
            clip = ClipData.newPlainText("Telegraph Link", url)
            clipboard.setPrimaryClip(clip)
            BulletinHelper.show_success("–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!")
            d.dismiss()

        def send_action(d, w):
            d.dismiss()
            self._open_chat_selection(url)

        builder.set_positive_button("–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å", copy_action)
        builder.set_neutral_button("–û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤...", send_action)
        builder.set_negative_button("–ó–∞–∫—Ä—ã—Ç—å", lambda d, w: d.dismiss())
        builder.show()

    def _copy_token(self, view):
        if not self.token:
            return
        try:
            from org.telegram.messenger import AndroidUtilities
            AndroidUtilities.addToClipboard(self.token)
            BulletinHelper.show_success("–¢–æ–∫–µ–Ω —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω!")
        except Exception as e:
             BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: {e}")

    def _show_change_token_dialog(self, view):
        fragment = get_last_fragment()
        if not fragment: return
        activity = fragment.getParentActivity()
        
        builder = AlertDialogBuilder(activity)
        builder.set_title("–°–º–µ–Ω–∏—Ç—å —Ç–æ–∫–µ–Ω")
        
        # –°–æ–∑–¥–∞–µ–º –ø–æ–ª–µ –≤–≤–æ–¥–∞ —á–µ—Ä–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –∏–ª–∏ –Ω–∞–ø—Ä—è–º—É—é, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ
        from android.widget import EditText
        input_field = EditText(activity)
        input_field.setText(self.token if self.token else "")
        builder.set_view(input_field)
        
        def save_action(d, w):
            new_token = str(input_field.getText()).strip()
            if new_token:
                self.token = new_token
                self.set_setting("telegraph_token", new_token)
                BulletinHelper.show_success("–¢–æ–∫–µ–Ω –æ–±–Ω–æ–≤–ª–µ–Ω!")
                self._reload_settings()
            d.dismiss()
            
        builder.set_positive_button("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", save_action)
        builder.set_negative_button("–û—Ç–º–µ–Ω–∞", lambda d,w: d.dismiss())
        builder.show()

    def _force_new_token(self, view):
        BulletinHelper.show_info("–ì–µ–Ω–µ—Ä–∏—Ä—É—é –Ω–æ–≤—ã–π —Ç–æ–∫–µ–Ω...")
        run_on_queue(self._generate_new_token)

    def _reload_settings(self):
        # –¢—Ä—é–∫ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UI –Ω–∞—Å—Ç—Ä–æ–µ–∫
        self.set_setting("_refresh_trigger", str(time.time()), reload_settings=True)

    def on_plugin_unload(self):
        for hook in self.hooks:
            self.unhook_method(hook)
        self.hooks.clear()

    def _get_current_input_text(self, chat_activity):
        try:
            enter_view = get_private_field(chat_activity, "chatActivityEnterView")
            if enter_view:
                edit_field = enter_view.getEditField()
                if edit_field and edit_field.getText():
                    return str(edit_field.getText().toString())
        except Exception as e:
            log(f"[{__id__}] Error getting input text: {e}")
        return ""

    def _clear_input_field(self, chat_activity):
        try:
            enter_view = get_private_field(chat_activity, "chatActivityEnterView")
            if enter_view:
                enter_view.setFieldText("")
        except Exception as e:
            log(f"[{__id__}] Error clearing input: {e}")
    def _get_selected_media_paths(self):
        paths = []
        try:
            selected_photos = MediaController.getInstance().selectedPhotos
            if selected_photos:
                for i in range(selected_photos.size()):
                    entry = selected_photos.get(i)
                    if hasattr(entry, "path") and entry.path:
                        paths.append(str(entry.path))
                    elif hasattr(entry, "imagePath") and entry.imagePath:
                        paths.append(str(entry.imagePath))
        except Exception as e:
            log(f"[{__id__}] Error getting media: {e}")
        return paths

    def _upload_file_to_telegraph(self, path):
        try:
            if not os.path.exists(path):
                return None
            
            mime_type = "image/jpeg"
            if path.lower().endswith(".png"): mime_type = "image/png"
            elif path.lower().endswith(".gif"): mime_type = "image/gif"
            elif path.lower().endswith(".mp4"): mime_type = "video/mp4"
            
            with open(path, "rb") as f:
                response = requests.post(
                    "https://telegra.ph/upload",
                    files={"file": ("blob", f, mime_type)},
                    headers={"User-Agent": "Python-Telegraph-Client"},
                    timeout=30
                )
            
            data = response.json()
            if isinstance(data, list) and len(data) > 0 and "src" in data[0]:
                return "https://telegra.ph" + data[0]["src"]
            else:
                log(f"[{__id__}] Upload failed: {data}")
                return None
        except Exception as e:
            log(f"[{__id__}] Upload error: {e}")
            return None
    def _handle_send_as_telegraph(self, fragment, text, media_paths=None):
        if not self.token:
             run_on_ui_thread(lambda: BulletinHelper.show_error("–¢–æ–∫–µ–Ω –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! –ó–∞–π–¥–∏—Ç–µ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø–ª–∞–≥–∏–Ω–∞."))
             return
        
        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–≥–æ–ª–æ–≤–∫–∞
        custom_title_setting = self.get_setting("tg_title", "")
        title, content = self._prepare_content(text, custom_title_setting)
        
        msg = "–ü—É–±–ª–∏–∫–∞—Ü–∏—è –≤ Telegraph..."
        if media_paths:
            msg = f"–ó–∞–≥—Ä—É–∑–∫–∞ –º–µ–¥–∏–∞ ({len(media_paths)}) –∏ –ø—É–±–ª–∏–∫–∞—Ü–∏—è..."
            
        BulletinHelper.show_info(msg)
        run_on_queue(lambda: self._process_telegraph_send(fragment, title, content, media_paths))

    def _process_telegraph_send(self, fragment, title, text_content, media_paths=None):
        try:
            content_nodes = self._text_to_nodes(text_content)
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ –º–µ–¥–∏–∞
            if media_paths:
                media_nodes = []
                for path in media_paths:
                    src = self._upload_file_to_telegraph(path)
                    if src:
                        tag = "video" if path.lower().endswith(".mp4") else "img"
                        media_nodes.append({"tag": tag, "attrs": {"src": src}})
                
                # –î–æ–±–∞–≤–ª—è–µ–º –º–µ–¥–∏–∞ –≤ –Ω–∞—á–∞–ª–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
                if media_nodes:
                    content_nodes = media_nodes + content_nodes

            content_json = json.dumps(content_nodes)
            
            response = requests.post(
                "https://api.telegra.ph/createPage",
                data={
                    "access_token": self.token,
                    "title": title,
                    "content": content_json,
                    "return_content": "false"
                },
                timeout=30
            ).json()
            
            if response.get("ok"):
                page_url = response["result"]["url"]
                run_on_ui_thread(lambda: self._finalize_send(fragment, page_url))
            else:
                error = response.get("error", "Unknown error")
                run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ API: {error}"))
        except Exception as e:
            log(f"[{__id__}] Error in process_telegraph_send: {e}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞: {e}"))
    def _finalize_send(self, fragment, url):
        try:
            # –û—á–∏—â–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –º–µ–¥–∏–∞
            try:
                MediaController.getInstance().selectedPhotos.clear()
            except Exception:
                pass
                
            self._clear_input_field(fragment)
            self._send_url_msg(fragment.getDialogId(), url)
        except Exception as e:
            error_text = str(e)
            log(f"[{__id__}] Error finalizing send: {error_text}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞: {error_text}"))

    def _open_chat_selection(self, url):
        fragment = get_last_fragment()
        if not fragment: return
        
        bundle = Bundle()
        bundle.putBoolean("onlySelect", True)
        bundle.putInt("dialogsType", 3)
        bundle.putString("selectAlertString", "–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å—Å—ã–ª–∫—É")
        
        dialogs = DialogsActivity(bundle)
        dialogs.setDelegate(SelectChatDelegate(self, url))
        fragment.presentFragment(dialogs)

    def _send_url_msg(self, peer_id, url):
        try:
            send_mode = self.get_setting("send_mode", 0)
            preview_mode = self.get_setting("preview_mode", 2)
            custom_text = self.get_setting("custom_link_text", "–ß–∏—Ç–∞—Ç—å")

            message_text = url
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º Java ArrayList –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å API Telegram
            entities = ArrayList()
            
            if send_mode == 0: # Hidden
                message_text = "¬∑‚Äî‚Äì‚Äî¬∑"
                ent = TLRPC.TL_messageEntityTextUrl()
                ent.offset = 0
                ent.length = len(message_text.encode('utf-16-le')) // 2
                ent.url = url
                entities.add(ent)
            elif send_mode == 2: # Custom text
                message_text = custom_text if custom_text else "–ß–∏—Ç–∞—Ç—å"
                ent = TLRPC.TL_messageEntityTextUrl()
                ent.offset = 0
                ent.length = len(message_text.encode('utf-16-le')) // 2
                ent.url = url
                entities.add(ent)
            
            # --- –õ–û–ì–ò–ö–ê –û–¢–ü–†–ê–í–ö–ò ---
            
            if preview_mode == 2: # –†–ï–ñ–ò–ú '–°–ö–†–´–¢–¨' (–¢–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ –ø—Ä—è–º–æ–π –∑–∞–ø—Ä–æ—Å)
                req = TLRPC.TL_messages_sendMessage()
                req.peer = MessagesController.getInstance(UserConfig.selectedAccount).getInputPeer(peer_id)
                req.message = message_text
                req.random_id = Utilities.random.nextLong()
                
                flags = 0
                req.no_webpage = True
                flags |= 2 
                
                if not entities.isEmpty():
                    req.entities = entities
                    flags |= 8
                
                req.flags = flags
                
                def cb(r, e):
                    if e:
                        log(f"[{__id__}] Send error: {e.text}")
                    else:
                        run_on_ui_thread(lambda: BulletinHelper.show_success("–°—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!"))

                send_request(req, RequestCallback(cb))
                
            else: # –û–ë–´–ß–ù–´–ô –†–ï–ñ–ò–ú (–ë—ã—Å—Ç—Ä—ã–π, Optimistic UI)
                params = SendMessagesHelper.SendMessageParams()
                params.peer = peer_id
                params.message = message_text
                params.entities = entities
                
                if preview_mode == 1: # –°–≤–µ—Ä—Ö—É
                    if hasattr(params, 'invert_media'):
                        params.invert_media = True
                
                SendMessagesHelper.getInstance(UserConfig.selectedAccount).sendMessage(params)
                run_on_ui_thread(lambda: BulletinHelper.show_success("–°—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!"))
            
        except Exception as e:
            error_text = str(e)
            log(f"[{__id__}] Error in _send_url_msg: {error_text}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {error_text}"))

#–°–æ–∑–¥–∞–Ω–æ —Å –ª—é–±–æ–≤—å—é –∫ –∫–æ—Ç–∏–∫–∞–º >^ w ^<