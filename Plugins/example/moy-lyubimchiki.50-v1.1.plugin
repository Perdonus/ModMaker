__id__ = "myloves"
__name__ = "My Loves"
__author__ = "–°–≤–∞–≥–∞–ù–µ–¢—É—Ç–∞ @swagnonher"
__version__ = "1.2.0"
__description__ = """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫—Ç–æ –∏ –∫–∞–∫–∏–µ –ø–æ–¥–∞—Ä–∫–∏ –≤–∞–º –¥–∞—Ä–∏–ª. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ä—É—á–Ω–æ–π –≤–≤–æ–¥. –ö–æ–º–∞–Ω–¥—ã: .myloves, .manlove, .clearmyloves"""

# -*- coding: utf-8 -*-

import threading
import traceback
from collections import Counter, defaultdict
from java.util import Locale

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import (
    get_last_fragment, 
    send_message, 
    send_request, 
    get_user_config, 
    get_messages_controller,
    RequestCallback
)
from android_utils import run_on_ui_thread, log
from ui.alert import AlertDialogBuilder
from ui.bulletin import BulletinHelper
from markdown_utils import parse_markdown
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import ContactsController, MessagesController, UserConfig
from org.telegram.ui.ActionBar import AlertDialog

# --- –ü–æ–ø—ã—Ç–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ zwylib ---
try:
    import zwylib
    ZWYLIB_AVAILABLE = True
except ImportError:
    ZWYLIB_AVAILABLE = False
    zwylib = None

# --- –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –ø–ª–∞–≥–∏–Ω–∞ ---
__min_version__ = "11.12.0"
__icon__ = "DMJDuckX2/15"


class LocalizationManager:
    """–£–ø—Ä–∞–≤–ª—è–µ—Ç —Å—Ç—Ä–æ–∫–∞–º–∏ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏–∏ –¥–ª—è –ø–ª–∞–≥–∏–Ω–∞."""
    def __init__(self):
        self.language = Locale.getDefault().getLanguage()
        self.strings = {
            "ru": {
                "loading_title": "–ó–∞–≥—Ä—É–∑–∫–∞...",
                "loading_message": "–ü–æ–ª—É—á–∞—é —Å–ø–∏—Å–æ–∫ –≤–∞—à–∏—Ö –ø–æ–¥–∞—Ä–∫–æ–≤...",
                "error_generic": "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {error}",
                "error_no_gifts": "üíî –í–∞–º –µ—â–µ –Ω–∏–∫—Ç–æ –Ω–µ –¥–∞—Ä–∏–ª –ø–æ–¥–∞—Ä–∫–∏, –∏ —Ä—É—á–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –Ω–µ—Ç.",
                "error_unsupported_client": "–ê–≤—Ç–æ–ø–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ (–∫–ª–∏–µ–Ω—Ç —É—Å—Ç–∞—Ä–µ–ª). –†—É—á–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –Ω–µ—Ç.\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `.manlove <emoji> <—Ü–µ–Ω–∞> <@—é–∑–µ—Ä>` –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è.",
                "error_zwylib_missing": "‚ö†Ô∏è ZwyLib –Ω–µ –Ω–∞–π–¥–µ–Ω. –†—É—á–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏ –ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ–¥–∞—Ä–∫–æ–≤ –Ω–µ–≤–æ–∑–º–æ–∂–Ω—ã.",
                "error_network": "‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                "error_api_unavailable": "‚ùå API –ø–æ–¥–∞—Ä–∫–æ–≤ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –≤ –¥–∞–Ω–Ω–æ–π –≤–µ—Ä—Å–∏–∏ –∫–ª–∏–µ–Ω—Ç–∞.",
                "manlove_usage": "‚ÑπÔ∏è –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `.manlove <emoji> <—Ü–µ–Ω–∞> <@—é–∑–µ—Ä>`\n–î–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö: `.manlove ... / ...`",
                "manlove_success": "‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ {count} –∑–∞–ø–∏—Å–µ–π –æ –ø–æ–¥–∞—Ä–∫–∞—Ö.",
                "manlove_parse_error": "‚ùå –û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ –∑–∞–ø–∏—Å–∏: `{entry}`. –ü—Ä–æ–ø—É—â–µ–Ω–æ.",
                "clear_success": "üóëÔ∏è –í—Å–µ —Ä—É—á–Ω—ã–µ –∑–∞–ø–∏—Å–∏ –æ –ø–æ–¥–∞—Ä–∫–∞—Ö —É–¥–∞–ª–µ–Ω—ã.",
                "result_header": "üíñ –í–∞—à–∏ –õ—é–±–∏–º—á–∏–∫–∏ üíñ",
                "result_footer": "\n\n_–≠—Ç–æ –≤—Å–µ, –∫—Ç–æ –¥–∞—Ä–∏–ª –≤–∞–º –ø–æ–¥–∞—Ä–∫–∏._",
                "result_combined": "\n\nüîÑ _–ü–æ–∫–∞–∑–∞–Ω—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∏ —Ä—É—á–Ω—ã–µ –∑–∞–ø–∏—Å–∏._",
                "result_manual_only": "\n\nüìù _–ü–æ–∫–∞–∑–∞–Ω—ã —Ç–æ–ª—å–∫–æ —Ä—É—á–Ω—ã–µ –∑–∞–ø–∏—Å–∏._",
                "result_auto_only": "\n\nü§ñ _–ü–æ–∫–∞–∑–∞–Ω—ã —Ç–æ–ª—å–∫–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø–æ–¥–∞—Ä–∫–∏._",
                "unknown_user": "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å",
                "fetching_offset": "–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥–∞—Ä–∫–æ–≤... {current}/{total}",
            },
            "en": {
                "loading_title": "Loading...",
                "loading_message": "Fetching your gifts list...",
                "error_generic": "An error occurred: {error}",
                "error_no_gifts": "üíî Nobody has given you gifts yet, and no manual records exist.",
                "error_unsupported_client": "Auto-detection unavailable (client outdated). No manual records.\nUse `.manlove <emoji> <price> <@user>` to add.",
                "error_zwylib_missing": "‚ö†Ô∏è ZwyLib not found. Manual adding and viewing gifts is impossible.",
                "error_network": "‚ùå Network error. Please try again later.",
                "error_api_unavailable": "‚ùå Gifts API unavailable in this client version.",
                "manlove_usage": "‚ÑπÔ∏è Usage: `.manlove <emoji> <price> <@user>`\nFor multiple: `.manlove ... / ...`",
                "manlove_success": "‚úÖ Added {count} gift records.",
                "manlove_parse_error": "‚ùå Format error in record: `{entry}`. Skipped.",
                "clear_success": "üóëÔ∏è All manual gift records cleared.",
                "result_header": "üíñ Your Loves üíñ",
                "result_footer": "\n\n_These are everyone who gave you gifts._",
                "result_combined": "\n\nüîÑ _Showing automatically found and manual records._",
                "result_manual_only": "\n\nüìù _Showing only manual records._",
                "result_auto_only": "\n\nü§ñ _Showing only automatically found gifts._",
                "unknown_user": "Unknown user",
                "fetching_offset": "Fetching gifts... {current}/{total}",
            }
        }

    def get_string(self, key, **kwargs):
        """–ü–æ–ª—É—á–∞–µ—Ç –ª–æ–∫–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–æ–∫—É –ø–æ –∫–ª—é—á—É."""
        lang_strings = self.strings.get(self.language, self.strings.get("ru"))
        template = lang_strings.get(key, key)
        return template.format(**kwargs)


class MyLovesPlugin(BasePlugin):
    """
    –ü–ª–∞–≥–∏–Ω –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π, –ø–æ–¥–∞—Ä–∏–≤—à–∏—Ö –ø–æ–¥–∞—Ä–∫–∏.
    """
    def __init__(self):
        super().__init__()
        self.loc = LocalizationManager()
        self.progress_dialog: AlertDialog = None
        self.manual_gifts_cache = None
        self.is_fetching = False

    def on_plugin_load(self):
        """–í—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –ø–ª–∞–≥–∏–Ω–∞."""
        self.add_on_send_message_hook()
        self._init_cache()
        log(f"[{__id__}] –ø–ª–∞–≥–∏–Ω —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω. ZwyLib –¥–æ—Å—Ç—É–ø–µ–Ω: {ZWYLIB_AVAILABLE}")

    def _init_cache(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∫—ç—à –¥–ª—è —Ä—É—á–Ω–æ–≥–æ —Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–æ–¥–∞—Ä–∫–æ–≤."""
        if ZWYLIB_AVAILABLE:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–∏—Å–æ–∫ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∑–∞–ø–∏—Å–µ–π
            self.manual_gifts_cache = zwylib.JsonCacheFile("myloves_manual_gifts", [])
        else:
            log(f"[{__id__}] ZwyLib –Ω–µ –Ω–∞–π–¥–µ–Ω, —Ä—É—á–Ω–æ–π —Ä–µ–∂–∏–º –±—É–¥–µ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
            
    def on_send_message_hook(self, account, params):
        """–ü–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏—Å—Ö–æ–¥—è—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è."""
        if not hasattr(params, 'message') or not isinstance(params.message, str):
            return HookResult()

        msg = params.message.strip()

        if msg.lower() == ".myloves":
            if self.is_fetching:
                BulletinHelper.show_error("‚è≥ –£–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∑–∞–≥—Ä—É–∑–∫–∞ –ø–æ–¥–∞—Ä–∫–æ–≤...")
                return HookResult(strategy=HookStrategy.CANCEL)
            
            self.is_fetching = True
            self._show_loading_dialog()
            threading.Thread(target=self._handle_myloves_command, args=(params,)).start()
            return HookResult(strategy=HookStrategy.CANCEL)

        if msg.lower().startswith(".manlove "):
            self._handle_manual_add(params)
            return HookResult(strategy=HookStrategy.CANCEL)
            
        if msg.lower() == ".clearmyloves":
            self._handle_clear_manual(params)
            return HookResult(strategy=HookStrategy.CANCEL)

        return HookResult()

    def _handle_myloves_command(self, params):
        """–û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã .myloves."""
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å –ø–æ–¥–∞—Ä–∫–∏ —á–µ—Ä–µ–∑ API
            auto_gifts = self._fetch_star_gifts()
            
            # –ü–æ–ª—É—á–∞–µ–º —Ä—É—á–Ω—ã–µ –∑–∞–ø–∏—Å–∏
            manual_gifts = self._get_manual_gifts()
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            all_gifts = self._merge_gifts(auto_gifts, manual_gifts)
            
            if not all_gifts:
                if auto_gifts is None:  # API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω
                    error_msg = self.loc.get_string("error_unsupported_client")
                else:
                    error_msg = self.loc.get_string("error_no_gifts")
                self._send_final_message(error_msg, params)
            else:
                result_type = self._determine_result_type(auto_gifts, manual_gifts)
                final_message = self._format_gifts_message(all_gifts, result_type)
                self._send_final_message(final_message, params)
                
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –≤ _handle_myloves_command: {traceback.format_exc()}")
            self._send_final_message(self.loc.get_string("error_generic", error=str(e)), params)
        finally:
            self.is_fetching = False
            self._dismiss_loading_dialog()

    def _fetch_star_gifts(self):
        """–ü–æ–ª—É—á–∞–µ—Ç –ø–æ–¥–∞—Ä–∫–∏ —á–µ—Ä–µ–∑ Telegram API."""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å API –º–µ—Ç–æ–¥–æ–≤
            if not hasattr(TLRPC, 'TL_payments_getUserStarGifts'):
                log(f"[{__id__}] TL_payments_getUserStarGifts –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
                return None
            
            current_user_id = get_user_config().getClientUserId()
            messages_controller = get_messages_controller()
            
            # –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å
            request = TLRPC.TL_payments_getUserStarGifts()
            request.user_id = messages_controller.getInputUser(current_user_id)
            request.offset = ""
            request.limit = 100
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
            response = self._send_request_sync(request)
            
            if response is None:
                return None
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç
            return self._process_gifts_response(response)
            
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–¥–∞—Ä–∫–æ–≤ —á–µ—Ä–µ–∑ API: {traceback.format_exc()}")
            return None

    def _send_request_sync(self, request):
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ."""
        response_holder = {'response': None, 'error': None, 'done': False}
        
        def callback(response, error):
            response_holder['response'] = response
            response_holder['error'] = error
            response_holder['done'] = True
        
        try:
            send_request(request, RequestCallback(callback))
            
            # –ñ–¥–µ–º –æ—Ç–≤–µ—Ç–∞ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            timeout = 30  # 30 —Å–µ–∫—É–Ω–¥
            while not response_holder['done'] and timeout > 0:
                threading.Event().wait(0.1)
                timeout -= 0.1
            
            if response_holder['error']:
                log(f"[{__id__}] API Error: {response_holder['error']}")
                return None
            
            return response_holder['response']
            
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞–ø—Ä–æ—Å–∞: {traceback.format_exc()}")
            return None

    def _process_gifts_response(self, response):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—Ç–≤–µ—Ç API —Å –ø–æ–¥–∞—Ä–∫–∞–º–∏."""
        try:
            if not response or not hasattr(response, 'gifts'):
                return {}
            
            gifts = {}
            user_map = {}
            
            # –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            if hasattr(response, 'users'):
                for user in response.users:
                    user_map[user.id] = user
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ–¥–∞—Ä–∫–∏
            for gift in response.gifts:
                if not hasattr(gift, 'from_id') or not hasattr(gift, 'gift'):
                    continue
                
                sender_id = gift.from_id
                gift_info = gift.gift
                
                if sender_id not in gifts:
                    gifts[sender_id] = {
                        'user': user_map.get(sender_id),
                        'total_stars': 0,
                        'gifts': []
                    }
                
                # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–¥–∞—Ä–∫–µ
                if hasattr(gift_info, 'stars'):
                    gifts[sender_id]['total_stars'] += gift_info.stars
                
                if hasattr(gift_info, 'sticker') and hasattr(gift_info.sticker, 'emoji'):
                    gifts[sender_id]['gifts'].append(gift_info.sticker.emoji)
                else:
                    gifts[sender_id]['gifts'].append("üéÅ")  # Fallback emoji
            
            return gifts
            
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç–∞ API: {traceback.format_exc()}")
            return {}

    def _get_manual_gifts(self):
        """–ü–æ–ª—É—á–∞–µ—Ç —Ä—É—á–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–æ–¥–∞—Ä–∫–∏."""
        if not ZWYLIB_AVAILABLE or not self.manual_gifts_cache:
            return {}
        
        try:
            manual_data = self.manual_gifts_cache.content
            if not manual_data:
                return {}
            
            gifts = {}
            
            for gift in manual_data:
                sender = gift['sender']
                if sender not in gifts:
                    gifts[sender] = {
                        'user': sender,  # –î–ª—è —Ä—É—á–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π "user" - —Å—Ç—Ä–æ–∫–∞
                        'total_stars': 0,
                        'gifts': []
                    }
                
                gifts[sender]['total_stars'] += gift['stars']
                gifts[sender]['gifts'].append(gift['slug'])
            
            return gifts
            
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ä—É—á–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π: {traceback.format_exc()}")
            return {}

    def _merge_gifts(self, auto_gifts, manual_gifts):
        """–û–±—ä–µ–¥–∏–Ω—è–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –∏ —Ä—É—á–Ω—ã–µ –ø–æ–¥–∞—Ä–∫–∏."""
        all_gifts = {}
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ–¥–∞—Ä–∫–∏
        if auto_gifts:
            all_gifts.update(auto_gifts)
        
        # –î–æ–±–∞–≤–ª—è–µ–º —Ä—É—á–Ω—ã–µ –ø–æ–¥–∞—Ä–∫–∏
        if manual_gifts:
            for sender_key, manual_data in manual_gifts.items():
                if sender_key in all_gifts:
                    # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏
                    all_gifts[sender_key]['total_stars'] += manual_data['total_stars']
                    all_gifts[sender_key]['gifts'].extend(manual_data['gifts'])
                else:
                    # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ
                    all_gifts[sender_key] = manual_data
        
        return all_gifts

    def _determine_result_type(self, auto_gifts, manual_gifts):
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è –≤—ã–≤–æ–¥–∞."""
        has_auto = auto_gifts and len(auto_gifts) > 0
        has_manual = manual_gifts and len(manual_gifts) > 0
        
        if has_auto and has_manual:
            return "combined"
        elif has_manual:
            return "manual_only"
        elif has_auto:
            return "auto_only"
        else:
            return "none"

    def _format_gifts_message(self, gifts_data, result_type):
        """–°–æ–∑–¥–∞–µ—Ç –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è –∏–∑ –¥–∞–Ω–Ω—ã—Ö –æ –ø–æ–¥–∞—Ä–∫–∞—Ö."""
        if not gifts_data:
            return self.loc.get_string("error_no_gifts")
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∑–≤–µ–∑–¥
        sorted_gifts = sorted(gifts_data.items(), key=lambda item: item[1]['total_stars'], reverse=True)
        
        message_lines = [self.loc.get_string("result_header"), ""]
        medals = ["ü•á", "ü•à", "ü•â"]

        for i, (sender_key, data) in enumerate(sorted_gifts):
            user_info = data['user']
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            if isinstance(user_info, str):
                username = user_info
            elif user_info and hasattr(user_info, 'username'):
                username = f"@{user_info.username}" if user_info.username else ContactsController.formatName(user_info.first_name, user_info.last_name)
            elif user_info and hasattr(user_info, 'first_name'):
                username = ContactsController.formatName(user_info.first_name, getattr(user_info, 'last_name', ''))
            else:
                username = str(sender_key)
            
            total_stars = data['total_stars']
            gift_counts = Counter(data['gifts'])
            gifts_string = ", ".join([f"{gift}{f'x{count}' if count > 1 else ''}" for gift, count in gift_counts.items()])
            
            medal = medals[i] if i < len(medals) else f"**{i + 1}.**"
            line = f"{medal} **{username}** ‚Äî üåü{total_stars}\n   ‚ï∞ {gifts_string}"
            message_lines.append(line)

        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–ø–∏—Å—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        if result_type == "combined":
            message_lines.append(self.loc.get_string("result_combined"))
        elif result_type == "manual_only":
            message_lines.append(self.loc.get_string("result_manual_only"))
        elif result_type == "auto_only":
            message_lines.append(self.loc.get_string("result_auto_only"))
        else:
            message_lines.append(self.loc.get_string("result_footer"))

        return "\n".join(message_lines)

    def _handle_manual_add(self, params):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É .manlove."""
        if not ZWYLIB_AVAILABLE:
            BulletinHelper.show_error(self.loc.get_string("error_zwylib_missing"))
            return

        try:
            content = params.message.split(" ", 1)[1]
            entries = [e.strip() for e in content.split('/')]
            
            added_count = 0
            for entry in entries:
                parts = entry.split()
                if len(parts) != 3:
                    BulletinHelper.show_error(self.loc.get_string("manlove_parse_error", entry=entry))
                    continue
                
                slug, stars_str, sender = parts
                try:
                    stars = int(stars_str)
                    self.manual_gifts_cache.content.append({
                        "slug": slug,
                        "stars": stars,
                        "sender": sender
                    })
                    added_count += 1
                except ValueError:
                    BulletinHelper.show_error(self.loc.get_string("manlove_parse_error", entry=entry))

            if added_count > 0:
                self.manual_gifts_cache.write()
                BulletinHelper.show_success(self.loc.get_string("manlove_success", count=added_count))
            else:
                BulletinHelper.show_error(self.loc.get_string("manlove_usage"))
                
        except IndexError:
            BulletinHelper.show_error(self.loc.get_string("manlove_usage"))
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –≤ _handle_manual_add: {traceback.format_exc()}")
            BulletinHelper.show_error(self.loc.get_string("error_generic", error=str(e)))

    def _handle_clear_manual(self, params):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É .clearmyloves."""
        if not ZWYLIB_AVAILABLE:
            BulletinHelper.show_error(self.loc.get_string("error_zwylib_missing"))
            return
        
        try:
            self.manual_gifts_cache.content.clear()
            self.manual_gifts_cache.write()
            BulletinHelper.show_success(self.loc.get_string("clear_success"))
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –≤ _handle_clear_manual: {traceback.format_exc()}")
            BulletinHelper.show_error(self.loc.get_string("error_generic", error=str(e)))

    def _send_final_message(self, text, params):
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∏—Ç–æ–≥–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è Markdown."""
        try:
            parsed_message = parse_markdown(text)
            send_params = {
                "peer": params.peer,
                "message": parsed_message.text,
                "entities": [e.to_tlrpc_object() for e in parsed_message.entities] if parsed_message.entities else None,
                "replyToMsg": params.replyToMsg
            }
            send_message(send_params)
        except Exception as e:
            log(f"[{__id__}] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ Markdown: {traceback.format_exc()}")
            # Fallback: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            send_message({
                "peer": params.peer,
                "message": text.replace("*", "").replace("_", ""),
                "replyToMsg": params.replyToMsg
            })

    def _show_loading_dialog(self):
        """–ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –∑–∞–≥—Ä—É–∑–∫–∏."""
        def dialog_logic():
            try:
                if self.progress_dialog and self.progress_dialog.isShowing():
                    return
                    
                fragment = get_last_fragment()
                if fragment and fragment.getParentActivity():
                    activity = fragment.getParentActivity()
                    builder = AlertDialogBuilder(activity, AlertDialogBuilder.ALERT_TYPE_SPINNER)
                    builder.set_title(self.loc.get_string("loading_title"))
                    builder.set_message(self.loc.get_string("loading_message"))
                    dialog_instance = builder.show()
                    dialog_instance.set_cancelable(False)
                    self.progress_dialog = dialog_instance.get_dialog()
            except Exception as e:
                log(f"[{__id__}] –û—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞: {e}\n{traceback.format_exc()}")
        
        run_on_ui_thread(dialog_logic)

    def _dismiss_loading_dialog(self):
        """–ó–∞–∫—Ä—ã–≤–∞–µ—Ç –¥–∏–∞–ª–æ–≥ –∑–∞–≥—Ä—É–∑–∫–∏."""
        def dismiss_logic():
            try:
                if self.progress_dialog and self.progress_dialog.isShowing():
                    self.progress_dialog.dismiss()
            except Exception as e:
                log(f"[{__id__}] –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è –¥–∏–∞–ª–æ–≥–∞: {e}\n{traceback.format_exc()}")
            finally:
                self.progress_dialog = None
        
        run_on_ui_thread(dismiss_logic)
