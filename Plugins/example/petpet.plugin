
import os
import time
import uuid
import traceback
import threading
from io import BytesIO
from typing import Any, Optional, Tuple

from base_plugin import BasePlugin, HookResult, HookStrategy
from client_utils import run_on_queue, get_account_instance, get_last_fragment, get_messages_controller, send_request, RequestCallback
from android_utils import run_on_ui_thread, log

def log(*_a, **_k):
    return None
from ui.bulletin import BulletinHelper
from ui.settings import Header, Switch, Input, Divider, Text
from ui.alert import AlertDialogBuilder

from java.io import File
from java.util import Locale
from java import jarray, jlong, jint
from java.lang import Integer, Long

from org.telegram.messenger import (
    ApplicationLoader,
    MessageObject,
    FileLoader,
    UserConfig,
    ImageLocation,
    MessagesController
)
from org.telegram.tgnet import TLRPC
from org.telegram.messenger import SendMessagesHelper
from org.telegram.ui.Components import AvatarDrawable

from android.media import MediaMetadataRetriever
from android.graphics import Bitmap, BitmapFactory, Canvas
from java.io import ByteArrayOutputStream

try:
    from PIL import Image, ImageSequence, UnidentifiedImageError
    from petpetgif import petpet
except Exception:
    Image = None
    ImageSequence = None
    petpet = None
    UnidentifiedImageError = Exception

__id__ = "petpet"
__name__ = "PetPet"
__description__ = "Гладит медиа/гифки/стикеры/аву. Команди: .petpet reply"
__author__ = "@Toxano_modules"
__version__ = "1.1.2"
__min_version__ = "11.12.0"
__icon__ = "t_modules/4"

TEMP_DIR_NAME = "PetPetTemp"
DEFAULT_PILLOW_WHEEL = "https://chaquo.com/pypi-13.1/pillow/Pillow-9.2.0-0-cp311-cp311-android_21_arm64_v8a.whl"
DEFAULT_FREETYPE_WHEEL = "https://chaquo.com/pypi-7.0/chaquopy-freetype/chaquopy_freetype-2.9.1-2-py3-none-android_21_arm64_v8a.whl"


DEFAULT_LIBJPEG_WHEEL = "https://chaquo.com/pypi-7.0/chaquopy-libjpeg/chaquopy_libjpeg-1.5.3-1-py3-none-android_21_arm64_v8a.whl"
DEFAULT_LIBPNG_WHEEL = "https://chaquo.com/pypi-7.0/chaquopy-libpng/chaquopy_libpng-1.6.34-1-py3-none-android_21_arm64_v8a.whl"
MAX_FILE_SIZE = 10 * 1024 * 1024
OUTPUT_SIZE = 512

STRINGS = {
    "ru": {
        "processing": "Глажу...",
        "success": "Готово!",
        "no_reply": "Команда должна быть ответом на сообщение или упоминанием пользователя",
        "no_media": "Не удалось найти медиа или аватар",
        "no_avatar": "Аватар не найден или недоступен",
        "history_fail": "Не удалось загрузить историю аватарок",
        "index_error": "У пользователя нет авы с индексом {idx}",
        "unsupported_tgs": " Анимированные .tgs стикеры не поддерживаются",
        "download_error": "Не удалось загрузить медиа. Попробуйте еще раз.",
        "file_too_large": "Файл слишком большой (максимум 10 МБ)",
        "disabled": "Плагин отключен в настройках",
        "deps_missing": "Не найдены зависимости: freetype, pillow и petpetgif",
        "deps_required": "Без библиотек freetype, pillow и petpetgif плагин работать не будет",
        "deps_installing": "Устанавливаю зависимости (freetype, pillow, petpetgif)...",
        "deps_install_started": "Начинаю установку зависимостей",
        "deps_install_slow": "Установка может занять несколько минут. Пожалуйста, подождите",
        "deps_installed": "Зависимости установлены, попробуйте снова",
        "deps_failed": "Не удалось установить зависимости: {error}",
        "mandre_missing": "Нужна библиотека MandreLib для установкэ зависимостей",
        "reinstall_title": "Переустановка зависимостей",
        "reinstall_message": "Переустановить freetype, pillow и petpetgif? Это может занять несколько минут.",
        "reinstall_action": "Переустановить зависимости",
        "reinstall_confirm": "Переустановить",
        "cancel": "Отмена",
        "confirm_error": "Не удалось открыть подтверждение",
        "error": "Ошибка: {error}",
        "settings_header": "Настройки PetPet",
        "enabled": "Включить плагин",
        "command": "Команда",
        "command_subtext": "Например: gitler (будет .gitler)",
    }
}


def _t(key: str, **kwargs) -> str:
    lang = Locale.getDefault().getLanguage()
    base = STRINGS.get("ru", {}).get(key, key)
    return base.format(**kwargs) if kwargs else base


class PetPetPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self._temp_dir: Optional[File] = None
        self._installing: bool = False

    def on_plugin_load(self):
        self.add_on_send_message_hook()
        self._temp_dir = self._get_temp_dir()
        if not self._deps_ready():
            self._install_deps_async(silent=True)

    def create_settings(self):
        return [
            Header(text=_t("settings_header")),
            Switch(key="enabled", text=_t("enabled"), default=True, icon="input_bot2"),
            Input(
                key="command",
                text=_t("command"),
                default="petpet",
                subtext=_t("command_subtext"),
                icon="msg_bot",
            ),
            Divider(),
            Text(
                text=_t("reinstall_action"),
                icon="msg_download_solar",
                accent=True,
                on_click=lambda v: self._confirm_reinstall_deps()
            ),
        ]

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        if not hasattr(params, "message") or not isinstance(params.message, str):
            return HookResult()

        text = params.message.strip()
        cmd = self._get_command()
        
        if not (text == cmd or text.startswith(cmd + " ")):
            return HookResult()

        if not self.get_setting("enabled", True):
            run_on_ui_thread(lambda: BulletinHelper.show_info(_t("disabled")))
            return HookResult(strategy=HookStrategy.CANCEL)

        if not self._deps_ready():
            deps_msg = _t("deps_required")
            run_on_ui_thread(lambda: BulletinHelper.show_error(deps_msg))
            self._install_deps_async(silent=False)
            return HookResult(strategy=HookStrategy.CANCEL)

        args = text[len(cmd):].strip().split()
        force_avatar = False
        avatar_index = 0

        if "-a" in args:
            force_avatar = True
            try:
                idx = args.index("-a")
                if idx + 1 < len(args) and args[idx+1].isdigit():
                    avatar_index = int(args[idx+1])
            except Exception:
                pass

        run_on_ui_thread(lambda: BulletinHelper.show_info(_t("processing")))
        run_on_queue(lambda: self._process(params, force_avatar, avatar_index))
        return HookResult(strategy=HookStrategy.CANCEL)

    def _process(self, params: Any, force_avatar: bool, avatar_index: int):
        try:
            if not self._deps_ready():
                error_msg = _t("deps_missing")
                log("Dependencies not ready in _process!")
                run_on_ui_thread(lambda: BulletinHelper.show_error(error_msg))
                return
            
            log("Starting petpet processing...")
            reply_msg = getattr(params, "replyToMsg", None)
            src_image = None
            src_path = None
            
            if not reply_msg:
                avatar_path = self._get_current_user_avatar()
                if not avatar_path:
                    current_user = self._get_current_user()
                    display_name = self._get_current_user_display_name()
                    src_image = self._make_default_avatar(current_user, display_name, OUTPUT_SIZE)
                    if src_image is None:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(_t("no_media")))
                        return
                else:
                    src_image = self._load_image_safe(avatar_path)
            elif force_avatar:
                avatar_path = self._get_avatar_path(reply_msg, avatar_index)
                if not avatar_path:
                    target = self._get_peer_tlobject(reply_msg)
                    display_name = self._get_peer_display_name(reply_msg)
                    src_image = self._make_default_avatar(target, display_name, OUTPUT_SIZE)
                    if src_image is None:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(_t("no_avatar")))
                        return
                else:
                    src_image = self._load_image_safe(avatar_path)
            else:
                media_type = self._detect_media_type(reply_msg)
                
                if media_type is None:
                    avatar_path = self._get_avatar_path(reply_msg, 0)
                    if not avatar_path:
                        target = self._get_peer_tlobject(reply_msg)
                        display_name = self._get_peer_display_name(reply_msg)
                        src_image = self._make_default_avatar(target, display_name, OUTPUT_SIZE)
                        if src_image is None:
                            run_on_ui_thread(lambda: BulletinHelper.show_error(_t("no_media")))
                            return
                    else:
                        src_image = self._load_image_safe(avatar_path)
                    
                elif media_type == "sticker_animated":
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_t("unsupported_tgs")))
                    return
                    
                elif media_type == "photo":
                    src_path = self._get_photo_path(reply_msg)
                    if not src_path:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(_t("download_error")))
                        return
                    
                    file_size = os.path.getsize(src_path) if os.path.exists(src_path) else 0
                    if file_size > MAX_FILE_SIZE:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(_t("file_too_large")))
                        return
                    
                    src_image = self._load_image_safe(src_path)
                    
                elif media_type in ("sticker_static", "gif", "video", "sticker_video"):
                    src_path = self._get_document_path(reply_msg)
                    if not src_path:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(_t("download_error")))
                        return
                    
                    file_size = os.path.getsize(src_path) if os.path.exists(src_path) else 0
                    if file_size > MAX_FILE_SIZE:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(_t("file_too_large")))
                        return
                    
                    file_ext = os.path.splitext(src_path)[1].lower()
                    
                    if media_type == "gif":
                        if file_ext == ".gif":
                            src_image = self._extract_frame_gif(src_path, 0)
                        else:
                            src_image = self._extract_frame_video(src_path, 0)
                        if src_image is None:
                            src_image = self._get_document_thumb_image(reply_msg)
                    elif file_ext in ('.mp4', '.webm', '.mov', '.avi') or media_type in ("video", "sticker_video"):
                        src_image = self._extract_frame_video(src_path, 0)
                        if src_image is None:
                            src_image = self._get_document_thumb_image(reply_msg)
                    elif file_ext == '.gif':
                        src_image = self._extract_frame_gif(src_path, 0)
                        if src_image is None:
                            src_image = self._get_document_thumb_image(reply_msg)
                    else:
                        src_image = self._load_image_safe(src_path)
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_t("no_media")))
                    return

            if src_image is None:
                run_on_ui_thread(lambda: BulletinHelper.show_error(_t("download_error")))
                return

            output_size = OUTPUT_SIZE

            try:
                src_image = src_image.resize((output_size, output_size), Image.Resampling.LANCZOS)
            except Exception:
                try:
                    src_image = src_image.resize((output_size, output_size), Image.LANCZOS)
                except:
                    pass

            out_path = self._make_temp_path("gif")
            petgif = BytesIO()
            source_buf = BytesIO()
            
            src_image.save(source_buf, format="PNG")
            source_buf.seek(0)
            
            petpet.make(source_buf, petgif)
            
            petgif.seek(0)
            with open(out_path, "wb") as f:
                f.write(petgif.read())

            output_file_size = os.path.getsize(out_path) if os.path.exists(out_path) else 0

            if not os.path.exists(out_path) or output_file_size < 128:
                run_on_ui_thread(lambda: BulletinHelper.show_error(_t("error", error="GIF generation failed")))
                return

            run_on_ui_thread(lambda: BulletinHelper.show_info("Отправляю..."))
            
            send_with_reply = reply_msg is not None
            
            if send_with_reply:
                if self._send_gif_result(params, out_path):
                    run_on_ui_thread(lambda: BulletinHelper.show_success(_t("success")))
            else:
                if self._send_gif_result_no_reply(params, out_path):
                    run_on_ui_thread(lambda: BulletinHelper.show_success(_t("success")))
                
        except Exception as e:
            pass
        except Exception as e:
            err_text = str(e)
            log(f"Error in _process: {err_text}")
            import traceback
            log(f"Traceback: {traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(_t("error", error=err_text)))
    
    def _load_image_safe(self, path: str):
        try:
            return Image.open(path).convert("RGBA")
        except (UnidentifiedImageError, OSError, Exception) as e:
            try:
                bitmap = BitmapFactory.decodeFile(path)
                if not bitmap:
                    return None
                
                stream = ByteArrayOutputStream()
                bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
                data = stream.toByteArray()
                
                try:
                    bitmap.recycle()
                except:
                    pass
                
                return Image.open(BytesIO(data)).convert("RGBA")
            except Exception:
                return None

    def _fetch_user_photos_sync(self, user_id: int, offset: int, limit: int) -> list:
        result = []
        event = threading.Event()

        def callback(response, error):
            if error:
                pass
            elif response and hasattr(response, "photos"):
                try:
                    photos_list = response.photos
                    for i in range(photos_list.size()):
                        result.append(photos_list.get(i))
                except Exception:
                    pass
            event.set()

        try:
            req = TLRPC.TL_photos_getUserPhotos()
            mc = get_messages_controller()
            user = mc.getUser(jlong(user_id))
            if not user:
                event.set()
                return []
            req.user_id = mc.getInputUser(user)
            req.offset = offset
            req.max_id = 0
            req.limit = limit
            
            send_request(req, RequestCallback(callback))
            event.wait(5.0)
        except Exception:
            return []
            
        return result

    def _get_current_user_avatar(self) -> Optional[str]:
        try:
            mc = get_messages_controller()
            current_user = mc.getUser(jlong(UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()))
            
            if not current_user:
                return None
            
            photo_obj = getattr(current_user, "photo", None)
            if not photo_obj:
                return None
            
            target_photo = getattr(photo_obj, "photo_big", None)
            if not target_photo:
                target_photo = getattr(photo_obj, "photo_small", None)
            
            if not target_photo:
                return None
            
            fl = FileLoader.getInstance(UserConfig.selectedAccount)
            img_loc = ImageLocation.getForUser(current_user, ImageLocation.TYPE_BIG)
            file_path_obj = fl.getPathToAttach(target_photo, True)
            
            if file_path_obj:
                abs_path = file_path_obj.getAbsolutePath()
                if abs_path and os.path.exists(abs_path) and os.path.getsize(abs_path) > 0:
                    return abs_path
            
            if img_loc:
                fl.loadFile(img_loc, "jpg", None, 0, 1)
                
                for _ in range(40):
                    if file_path_obj:
                        abs_path = file_path_obj.getAbsolutePath()
                        if abs_path and os.path.exists(abs_path) and os.path.getsize(abs_path) > 0:
                            return abs_path
                    time.sleep(0.5)
            
            return None
        except Exception:
            return None

    def _get_current_user(self):
        try:
            mc = get_messages_controller()
            return mc.getUser(jlong(UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()))
        except Exception:
            return None

    def _get_current_user_display_name(self) -> str:
        try:
            mc = get_messages_controller()
            current_user = mc.getUser(jlong(UserConfig.getInstance(UserConfig.selectedAccount).getClientUserId()))
            return self._get_user_display_name(current_user) if current_user else "?"
        except Exception:
            return "?"

    def _get_peer_display_name(self, message_obj: MessageObject) -> str:
        try:
            if not message_obj or not message_obj.messageOwner:
                return "?"

            from_id = getattr(message_obj.messageOwner, "from_id", None)
            mc = get_messages_controller()
            target = None

            if from_id is not None:
                if hasattr(from_id, "user_id") and from_id.user_id:
                    target = mc.getUser(jlong(from_id.user_id))
                elif hasattr(from_id, "channel_id") and from_id.channel_id:
                    target = mc.getChat(jlong(from_id.channel_id))
                elif hasattr(from_id, "chat_id") and from_id.chat_id:
                    target = mc.getChat(jlong(from_id.chat_id))

            if target is None:
                did = message_obj.getDialogId()
                if did > 0:
                    target = mc.getUser(jlong(did))
                elif did < 0:
                    target = mc.getChat(jlong(-did))

            if isinstance(target, TLRPC.User):
                return self._get_user_display_name(target)
            if target and hasattr(target, "title"):
                return target.title or "?"

            return "?"
        except Exception:
            return "?"

    def _get_peer_tlobject(self, message_obj: MessageObject):
        try:
            if not message_obj or not message_obj.messageOwner:
                return None

            from_id = getattr(message_obj.messageOwner, "from_id", None)
            mc = get_messages_controller()
            target = None

            if from_id is not None:
                if hasattr(from_id, "user_id") and from_id.user_id:
                    target = mc.getUser(jlong(from_id.user_id))
                elif hasattr(from_id, "channel_id") and from_id.channel_id:
                    target = mc.getChat(jlong(from_id.channel_id))
                elif hasattr(from_id, "chat_id") and from_id.chat_id:
                    target = mc.getChat(jlong(from_id.chat_id))

            if target is None:
                did = message_obj.getDialogId()
                if did > 0:
                    target = mc.getUser(jlong(did))
                elif did < 0:
                    target = mc.getChat(jlong(-did))

            return target
        except Exception:
            return None

    def _get_user_display_name(self, user) -> str:
        first_name = getattr(user, "first_name", None) or ""
        last_name = getattr(user, "last_name", None) or ""
        username = getattr(user, "username", None) or ""
        if first_name or last_name:
            return (first_name + " " + last_name).strip()
        if username:
            return username
        return "?"

    def _make_default_avatar(self, target, name: str, size: int):
        if not Image:
            return None
        try:
            avatar = AvatarDrawable()
            if target is not None:
                try:
                    avatar.setInfo(UserConfig.selectedAccount, target)
                except Exception:
                    try:
                        avatar.setInfo(target)
                    except Exception:
                        pass
            else:
                safe_name = (name or "?").strip()
                parts = [p for p in safe_name.replace("_", " ").split() if p]
                first = parts[0] if parts else ""
                last = parts[1] if len(parts) > 1 else ""
                fallback_id = abs(hash(safe_name)) % 2147483647
                avatar.setInfo(fallback_id, first, last)

            bmp = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888)
            canvas = Canvas(bmp)
            avatar.setBounds(0, 0, size, size)
            avatar.draw(canvas)

            stream = ByteArrayOutputStream()
            bmp.compress(Bitmap.CompressFormat.PNG, 100, stream)
            data = stream.toByteArray()

            try:
                bmp.recycle()
            except:
                pass

            return Image.open(BytesIO(data)).convert("RGBA")
        except Exception:
            return None

    def _get_avatar_path(self, message_obj: MessageObject, index: int = 0) -> Optional[str]:
        try:
            if not message_obj or not message_obj.messageOwner:
                return None

            from_id = getattr(message_obj.messageOwner, "from_id", None)
            mc = get_messages_controller()
            target = None
            user_id = 0

            if from_id is not None:
                if hasattr(from_id, "user_id") and from_id.user_id:
                    user_id = from_id.user_id
                    target = mc.getUser(jlong(user_id))
                elif hasattr(from_id, "channel_id") and from_id.channel_id:
                    target = mc.getChat(jlong(from_id.channel_id))
                elif hasattr(from_id, "chat_id") and from_id.chat_id:
                    target = mc.getChat(jlong(from_id.chat_id))

            if target is None:
                did = message_obj.getDialogId()
                if did > 0:
                    user_id = did
                    target = mc.getUser(jlong(did))
                elif did < 0:
                    target = mc.getChat(jlong(-did))

            if target is None:
                return None

            target_photo = None
            if index > 0 and user_id > 0:
                photos = self._fetch_user_photos_sync(user_id, 0, index + 5)
                if not photos:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_t("history_fail")))
                    return None

                if index < len(photos):
                    target_photo = photos[index]
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_t("index_error", idx=index)))
                    return None
            else:
                photo_obj = getattr(target, "photo", None)
                if not photo_obj:
                    if index > 0:
                        run_on_ui_thread(lambda: BulletinHelper.show_error(_t("no_avatar")))
                    return None

                target_photo = getattr(photo_obj, "photo_big", None)
                if not target_photo:
                    target_photo = getattr(photo_obj, "photo_small", None)

            if not target_photo:
                return None

            fl = FileLoader.getInstance(UserConfig.selectedAccount)
            img_loc = None

            if isinstance(target_photo, TLRPC.Photo):
                largest = None
                max_w = 0
                for i in range(target_photo.sizes.size()):
                    sz = target_photo.sizes.get(i)
                    if isinstance(sz, TLRPC.TL_photoSize):
                        if sz.w > max_w:
                            max_w = sz.w
                            largest = sz
                if not largest and target_photo.sizes.size() > 0:
                    largest = target_photo.sizes.get(target_photo.sizes.size() - 1)

                img_loc = ImageLocation.getForPhoto(largest, target_photo)
                file_path_obj = fl.getPathToAttach(largest, True)
            else:
                if isinstance(target, TLRPC.User):
                    img_loc = ImageLocation.getForUser(target, ImageLocation.TYPE_BIG)
                else:
                    img_loc = ImageLocation.getForChat(target, ImageLocation.TYPE_BIG)
                file_path_obj = fl.getPathToAttach(target_photo, True)

            if not img_loc:
                return None

            if file_path_obj:
                abs_path = file_path_obj.getAbsolutePath()
                if abs_path and os.path.exists(abs_path) and os.path.getsize(abs_path) > 0:
                    return abs_path

            fl.loadFile(img_loc, "jpg", None, 0, 1)

            for _ in range(40):
                if file_path_obj:
                    abs_path = file_path_obj.getAbsolutePath()
                    if abs_path and os.path.exists(abs_path) and os.path.getsize(abs_path) > 0:
                        return abs_path
                time.sleep(0.5)

            return None

        except Exception:
            return None

    def _get_command(self) -> str:
        try:
            raw = str(self.get_setting("command", "petpet")).strip().lower()
            if raw.startswith("."):
                raw = raw[1:]
            return f".{raw}" if raw else ".petpet"
        except:
            return ".petpet"

    def _deps_ready(self) -> bool:
        global Image, ImageSequence, petpet, UnidentifiedImageError
        if Image is not None and petpet is not None:
            return True
        
        try:
            from PIL import Image as _I, ImageSequence as _S, UnidentifiedImageError as _UI
            from petpetgif import petpet as _p
            Image, ImageSequence, petpet, UnidentifiedImageError = _I, _S, _p, _UI
            return True
        except Exception:
            return False

    def _confirm_reinstall_deps(self):
        def action():
            fragment = get_last_fragment()
            if not fragment:
                BulletinHelper.show_error(_t("confirm_error"))
                return
            activity = fragment.getParentActivity()
            if not activity:
                BulletinHelper.show_error(_t("confirm_error"))
                return

            builder = AlertDialogBuilder(activity)
            builder.set_title(_t("reinstall_title"))
            builder.set_message(_t("reinstall_message"))

            def on_yes(bld, which):
                try:
                    bld.dismiss()
                except Exception:
                    pass
                self._install_deps_async(silent=False)

            builder.set_positive_button(_t("reinstall_confirm"), on_yes)
            builder.make_button_red(AlertDialogBuilder.BUTTON_POSITIVE)
            builder.set_negative_button(_t("cancel"), lambda bld, which: bld.dismiss())
            builder.show()

        run_on_ui_thread(action)

    def _install_deps_async(self, silent: bool = False):
        if self._installing:
            if not silent:
                run_on_ui_thread(lambda: BulletinHelper.show_info(_t("deps_installing")))
            return
        self._installing = True

        def worker():
            try:
                if not silent:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(_t("deps_required")))
                    run_on_ui_thread(lambda: BulletinHelper.show_info(_t("deps_install_started")))
                    run_on_ui_thread(lambda: BulletinHelper.show_info(_t("deps_installing")))
                    run_on_ui_thread(lambda: BulletinHelper.show_info(_t("deps_install_slow")))
                try:
                    from mandre_lib import MandrePip
                except Exception as import_err:
                    error_msg = str(import_err)
                    log(f"Failed to import MandrePip: {error_msg}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_t("mandre_missing")))
                    return

                errors = []
                
                for pkg in [DEFAULT_FREETYPE_WHEEL, DEFAULT_LIBJPEG_WHEEL, DEFAULT_LIBPNG_WHEEL, DEFAULT_PILLOW_WHEEL]:
                    log(f"Installing package: {pkg}")
                    c, _, e = MandrePip.pip(["install", "--no-deps", pkg])
                    if c != 0:
                        err_text = e or str(c)
                        log(f"Failed to install {pkg}: {err_text}")
                        errors.append(err_text)
                    else:
                        log(f"Successfully installed: {pkg}")
                
                
                pillow_candidates = [
                    DEFAULT_PILLOW_WHEEL,
                    "https://chaquo.com/pypi-13.1/pillow/Pillow-9.2.0-0-cp311-cp311-android_24_arm64_v8a.whl",
                ]
                pillow_installed = False
                for pillow_pkg in pillow_candidates:
                    log(f"Installing package: {pillow_pkg}")
                    c, _, e = MandrePip.pip(["install", "--no-deps", pillow_pkg])
                    if c == 0:
                        pillow_installed = True
                        log(f"Successfully installed: {pillow_pkg}")
                        break
                    err_text = e or str(c)
                    log(f"Failed to install {pillow_pkg}: {err_text}")
                    errors.append(err_text)

                if not pillow_installed:
                    log("Falling back to 'Pillow==9.2.0' resolution from indexes")
                    c, _, e = MandrePip.pip(["install", "--no-deps", "Pillow==9.2.0"])
                    if c != 0:
                        err_text = e or str(c)
                        log(f"Failed to install Pillow==9.2.0: {err_text}")
                        errors.append(err_text)
                    else:
                        log("Successfully installed: Pillow==9.2.0")
                log("Installing package: pet-pet-gif")
                c, _, e = MandrePip.pip(["install", "--no-deps", "pet-pet-gif"])
                if c != 0:
                    err_text = e or str(c)
                    log(f"Failed to install pet-pet-gif: {err_text}")
                    errors.append(err_text)
                else:
                    log("Successfully installed: pet-pet-gif")
                
                if errors:
                    error_msg = ";".join(errors)
                    log(f"Installation errors: {error_msg}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_t("deps_failed", error=error_msg)))
                    return

                log("All packages installed, trying to import...")
                def _preload_native_libs():
                    import ctypes
                    import sys
                    libs = [
                        "libjpeg_chaquopy.so",
                        "libpng_chaquopy.so",
                        "libfreetype_chaquopy.so",
                    ]
                    rtld_global = getattr(ctypes, "RTLD_GLOBAL", 0)
                    for lib in libs:
                        found_path = None
                        for sp in list(sys.path):
                            if not sp or not os.path.isdir(sp):
                                continue
                            try:
                                for dirpath, _, filenames in os.walk(sp):
                                    if lib in filenames:
                                        found_path = os.path.join(dirpath, lib)
                                        break
                                if found_path:
                                    break
                            except Exception:
                                continue
                        if not found_path:
                            log(f"Native lib not found on sys.path: {lib}")
                            continue
                        try:
                            ctypes.CDLL(found_path, mode=rtld_global)
                        except Exception as e:
                            pass
                _preload_native_libs()
                try:
                    global Image, ImageSequence, petpet, UnidentifiedImageError
                    from PIL import Image as _I, ImageSequence as _S, UnidentifiedImageError as _UI
                    from petpetgif import petpet as _p
                    Image, ImageSequence, petpet, UnidentifiedImageError = _I, _S, _p, _UI
                    log("Successfully imported all dependencies!")
                except Exception as e:
                    pass
                except Exception as e:
                    error_msg = str(e)
                    log(f"Failed to import after installation: {error_msg}")
                    import traceback
                    log(f"Traceback: {traceback.format_exc()}")
                    run_on_ui_thread(lambda: BulletinHelper.show_error(_t("deps_failed", error=error_msg)))
                    return

                run_on_ui_thread(lambda: BulletinHelper.show_success(_t("deps_installed")))
            finally:
                self._installing = False
        run_on_queue(worker)

    def _extract_frame_gif(self, path: str, frame_number: int):
        try:
            im = Image.open(path)
            if hasattr(im, 'is_animated') and im.is_animated:
                im.seek(0)
                frame = im.copy().convert("RGBA")
                im.close()
                return frame
            else:
                return im.convert("RGBA")
        except Exception:
            return None

    def _extract_frame_video(self, path: str, frame_number: int):
        retriever = None
        try:
            retriever = MediaMetadataRetriever()
            retriever.setDataSource(path)
            bmp = retriever.getFrameAtTime(0, MediaMetadataRetriever.OPTION_CLOSEST_SYNC)
            if not bmp:
                try:
                    duration_str = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION)
                    duration_ms = int(duration_str) if duration_str else 0
                except Exception:
                    duration_ms = 0

                probe_times_us = []
                if duration_ms > 0:
                    probe_times_us.append(int((duration_ms * 1000) / 2))
                    probe_times_us.append(int((duration_ms * 1000) / 4))
                probe_times_us.append(1_000)

                for t_us in probe_times_us:
                    try:
                        bmp = retriever.getFrameAtTime(t_us, MediaMetadataRetriever.OPTION_CLOSEST)
                        if bmp:
                            break
                    except Exception:
                        continue
            if not bmp:
                return None
            
            s = ByteArrayOutputStream()
            bmp.compress(Bitmap.CompressFormat.PNG, 100, s)
            data = s.toByteArray()
            
            try:
                bmp.recycle()
            except:
                pass
            
            return Image.open(BytesIO(data)).convert("RGBA")
        except Exception:
            return None
        finally:
            if retriever:
                try:
                    retriever.release()
                except:
                    pass

    def _get_document_thumb_image(self, message_obj: MessageObject):
        try:
            doc = MessageObject.getDocument(message_obj.messageOwner)
            if not doc or not hasattr(doc, "thumbs") or doc.thumbs.isEmpty():
                return None

            try:
                thumb = FileLoader.getClosestPhotoSizeWithSize(doc.thumbs, 320)
            except Exception:
                thumb = doc.thumbs.get(0) if doc.thumbs.size() > 0 else None

            if not thumb:
                return None

            fl = FileLoader.getInstance(UserConfig.selectedAccount)
            path_obj = fl.getPathToAttach(thumb, True)
            if path_obj and path_obj.exists() and path_obj.length() > 0:
                return self._load_image_safe(path_obj.getAbsolutePath())

            img_loc = ImageLocation.getForDocument(thumb, doc)
            if img_loc:
                fl.loadFile(img_loc, "jpg", None, 0, 1)

            for _ in range(30):
                time.sleep(0.3)
                if path_obj and path_obj.exists() and path_obj.length() > 0:
                    return self._load_image_safe(path_obj.getAbsolutePath())

            return None
        except Exception:
            return None

    def _detect_media_type(self, message_obj: MessageObject) -> Optional[str]:
        if not message_obj or not message_obj.messageOwner:
            return None
        media = message_obj.messageOwner.media
        if isinstance(media, TLRPC.TL_messageMediaPhoto) and media.photo:
            return "photo"
        doc = MessageObject.getDocument(message_obj.messageOwner)
        if not doc:
            return None
        if MessageObject.isGifDocument(doc):
            return "gif"
        
        mime = getattr(doc, "mime_type", "") or ""
        is_sticker = False
        
        attrs = getattr(doc, "attributes", None)
        if attrs:
            for i in range(attrs.size()):
                a = attrs.get(i)
                if isinstance(a, TLRPC.TL_documentAttributeSticker):
                    is_sticker = True
                    break
        
        if is_sticker:
            if mime == "application/x-tgsticker":
                return "sticker_animated"
            if mime == "video/webm":
                return "sticker_video"
            return "sticker_static"
        
        if mime.startswith("video/"):
            return "video"
        if mime.startswith("image/"):
            return "sticker_static"
        return None

    def _get_photo_path(self, message_obj: MessageObject) -> Optional[str]:
        try:
            fl = FileLoader.getInstance(UserConfig.selectedAccount)
            path = fl.getPathToMessage(message_obj.messageOwner)
            
            if path and path.exists() and path.length() > 0:
                return path.getAbsolutePath()
            
            media = message_obj.messageOwner.media
            if not isinstance(media, TLRPC.TL_messageMediaPhoto):
                return None
            photo = media.photo
            
            largest = None
            max_size = 0
            for i in range(photo.sizes.size()):
                sz = photo.sizes.get(i)
                if isinstance(sz, TLRPC.TL_photoSize):
                    if hasattr(sz, 'w') and sz.w > max_size:
                        max_size = sz.w
                        largest = sz
            
            if not largest and photo.sizes.size() > 0:
                largest = photo.sizes.get(photo.sizes.size() - 1)
            
            loc = ImageLocation.getForPhoto(largest, photo)
            fl.loadFile(loc, message_obj, "jpg", 1, 1)
            
            path_obj = fl.getPathToAttach(largest, True)
            for attempt in range(60):
                time.sleep(0.5)
                if path_obj and path_obj.exists() and path_obj.length() > 0:
                    size1 = path_obj.length()
                    time.sleep(0.2)
                    size2 = path_obj.length()
                    if size1 == size2 and size1 > 0:
                        return path_obj.getAbsolutePath()
            
            return None
        except Exception:
            return None

    def _get_document_path(self, message_obj: MessageObject) -> Optional[str]:
        try:
            doc = MessageObject.getDocument(message_obj.messageOwner)
            if not doc:
                return None
            fl = get_account_instance().getFileLoader()
            path_obj = fl.getPathToAttach(doc, True)
            
            if path_obj and path_obj.exists() and path_obj.length() > 0:
                return path_obj.getAbsolutePath()
            
            fl.loadFile(doc, message_obj, 1, 1)
            
            for attempt in range(60):
                time.sleep(0.5)
                if path_obj and path_obj.exists() and path_obj.length() > 0:
                    size1 = path_obj.length()
                    time.sleep(0.2)
                    size2 = path_obj.length()
                    if size1 == size2 and size1 > 0:
                        return path_obj.getAbsolutePath()
            
            return None
        except Exception:
            return None

    def _send_gif_result(self, params: Any, gif_path: str) -> bool:
        try:
            dialog_id = 0
            if hasattr(params, "peer") and isinstance(params.peer, int):
                dialog_id = params.peer
            elif hasattr(params, "messageOwner") and hasattr(params.messageOwner, "dialog_id"):
                dialog_id = params.messageOwner.dialog_id
            
            if dialog_id == 0:
                frag = get_last_fragment()
                if frag and hasattr(frag, "getDialogId"):
                    dialog_id = frag.getDialogId()

            if dialog_id == 0:
                run_on_ui_thread(lambda: BulletinHelper.show_error(_t("error", error="dialog_id=0")))
                return False

            reply_to_msg = getattr(params, "replyToMsg", None)
            reply_to_top_msg = getattr(params, "replyToTopMsg", None)

            def _send_on_ui():
                try:
                    SendMessagesHelper.prepareSendingDocument(
                        get_account_instance(),
                        gif_path,
                        gif_path,
                        None, 
                        None, 
                        None, 
                        dialog_id,
                        reply_to_msg,      
                        reply_to_top_msg,  
                        None,
                        None,
                        None,
                        True,
                        0,
                        None,
                        None,
                        0,
                        False,
                    )
                except Exception:
                    pass

            run_on_ui_thread(_send_on_ui)
            self._delete_file_delayed(gif_path)
            return True
        except Exception:
            return False

    def _send_gif_result_no_reply(self, params: Any, gif_path: str) -> bool:
        try:
            dialog_id = 0
            if hasattr(params, "peer") and isinstance(params.peer, int):
                dialog_id = params.peer
            elif hasattr(params, "messageOwner") and hasattr(params.messageOwner, "dialog_id"):
                dialog_id = params.messageOwner.dialog_id
            
            if dialog_id == 0:
                frag = get_last_fragment()
                if frag and hasattr(frag, "getDialogId"):
                    dialog_id = frag.getDialogId()

            if dialog_id == 0:
                run_on_ui_thread(lambda: BulletinHelper.show_error(_t("error", error="dialog_id=0")))
                return False

            def _send_on_ui():
                try:
                    SendMessagesHelper.prepareSendingDocument(
                        get_account_instance(),
                        gif_path,
                        gif_path,
                        None, 
                        None, 
                        None, 
                        dialog_id,
                        None,  
                        None,  
                        None,
                        None,
                        None,
                        True,
                        0,
                        None,
                        None,
                        0,
                        False,
                    )
                except Exception:
                    pass

            run_on_ui_thread(_send_on_ui)
            self._delete_file_delayed(gif_path)
            return True
        except Exception:
            return False

    def _get_temp_dir(self) -> Optional[File]:
        try:
            c = ApplicationLoader.applicationContext
            f = File(c.getExternalCacheDir() or c.getCacheDir(), TEMP_DIR_NAME)
            if not f.exists():
                f.mkdirs()
            return f
        except:
            return None

    def _make_temp_path(self, ext: str) -> str:
        d = self._temp_dir or self._get_temp_dir()
        return File(d, f"{uuid.uuid4()}.{ext}").getAbsolutePath()

    def _delete_file_delayed(self, path: str):
        def w():
            time.sleep(10)
            try:
                os.remove(path)
            except:
                pass
        run_on_queue(w)
