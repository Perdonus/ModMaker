__id__ = "hidelink_preview"
__name__ = "noLinkPreview"
__author__ = "@RnPlugins with @PluginIDE"
__version__ = "1.0.0r"
__description__ = """По команде .лх [ссылка] [текст] отправляет сообщение с превью от ссылки, скрывая саму ссылку

The command .lh [link] [text] sends a message with a preview of the link, hiding the link itself"""

# Сгенерировано в PluginIDE - @PluginIDE

__icon__ = "sPluginIDE/35"
__min_version__ = "11.12.0"

import re
from typing import List, Any
import traceback

from base_plugin import BasePlugin, HookResult, HookStrategy
from ui.settings import Switch, Header
from java import jclass
from java.util import ArrayList

# Получаем Java-класс TLRPC$TL_messageEntityTextUrl по его полному пути.
try:
    TL_messageEntityTextUrl = jclass("org.telegram.tgnet.TLRPC$TL_messageEntityTextUrl")
except Exception:
    TL_messageEntityTextUrl = jclass("org.telegram.tgnet.TLRPC.TL_messageEntityTextUrl")


class LinkHiderPlugin(BasePlugin):
    """
    Плагин для скрытия ссылок в тексте с сохранением форматирования.
    """

    ZERO_WIDTH_CHAR = "\u2060"  # WORD JOINER (невидимый символ, безопасно держит энтити)

    def on_plugin_load(self) -> None:
        """
        Вызывается при загрузке плагина. Регистрируем хук на отправку сообщения.
        """
        self.add_on_send_message_hook(priority=100)
        self.log("Link Hider плагин загружен и готов к работе.")

    def create_settings(self) -> List[Any]:
        """
        Создает страницу настроек для плагина.
        """
        return [
            Header(text="Настройки предпросмотра"),
            Switch(
                key="show_preview",
                text="Показывать предпросмотр ссылки",
                subtext="Если включено, Telegram попытается создать превью для скрытой ссылки.",
                default=True
            )
        ]

    def _iter_entities(self, entities_obj):
        """
        Универсальный итератор по сущностям, поддерживает как Java ArrayList, так и Python list.
        """
        if entities_obj is None:
            return
        # Java ArrayList
        if hasattr(entities_obj, "size") and hasattr(entities_obj, "get"):
            size = entities_obj.size()
            for i in range(size):
                yield entities_obj.get(i)
        else:
            # Падение назад на обычный питоновский список
            for e in entities_obj:
                yield e

    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        """
        Перехватывает отправляемые сообщения для обработки команды.
        Формат:
          .lh <url> <текст>
          .лх <url> <текст>
        """
        try:
            if not hasattr(params, 'message') or not isinstance(params.message, str):
                return HookResult()

            original_message = params.message

            # Разрешаем отсутствие текста после URL (т.е. текст может быть пустым)
            pattern = re.compile(r"^\.(lh|лх)\s+(\S+)\s*(.*)$", re.IGNORECASE | re.DOTALL)
            match = pattern.match(original_message)

            if match:
                url = match.group(2)
                new_message = match.group(3)  # Весь текст, включая переносы строк, может быть пустым

                if not re.match(r'^[a-zA-Z]+://', url):
                    url = 'https://' + url

                # Вставляем невидимый символ в начало, к которому и будет привязан скрытый URL
                # Это гарантирует, что ссылка не "окрасит" первый видимый символ сообщения.
                new_message_with_hidden = f"{self.ZERO_WIDTH_CHAR}{new_message}"

                link_entity = TL_messageEntityTextUrl()
                link_entity.offset = 0
                link_entity.length = 1  # Ровно на невидимый символ
                link_entity.url = url

                # Получаем исходные entities
                original_entities = getattr(params, "entities", None)

                # Длина префикса-команды — с какого индекса в оригинале начинается пользовательский текст (group 3)
                command_length = match.start(3)

                # Готовим новый список entities как Java ArrayList
                adjusted_entities = ArrayList()
                adjusted_entities.add(link_entity)

                # Переносим и корректируем офсеты остальных сущностей
                for entity in self._iter_entities(original_entities):
                    try:
                        # Игнорируем сущности, которые "лежат" на тексте команды
                        if getattr(entity, "offset", 0) >= command_length:
                            # Сдвигаем влево на длину команды...
                            new_offset = entity.offset - command_length
                            # ...и вправо на 1 (из-за вставленного невидимого символа)
                            entity.offset = new_offset + 1
                            adjusted_entities.add(entity)
                    except Exception:
                        # На всякий случай не падаем из-за экзотических сущностей
                        continue

                params.message = new_message_with_hidden
                params.entities = adjusted_entities

                show_preview = self.get_setting("show_preview", True)
                # В экосистеме плагинов поле называется disable_web_page_preview
                setattr(params, "disable_web_page_preview", not show_preview)

                return HookResult(strategy=HookStrategy.MODIFY, params=params)

        except Exception:
            self.log(f"[hidelink_preview] Link Hider | Ошибка: {traceback.format_exc()}")

        return HookResult()