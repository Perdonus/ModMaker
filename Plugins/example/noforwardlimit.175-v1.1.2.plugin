"""
Если вы при разработке своего плагина использовали готовые фрагменты кода из моего, пожалуйста,
укажите в описании своего плагина @zwylair в качестве благодарности за вклад в разработку. Спасибо ♥

If you used code snippets from my plugin in the development of your own, please credit @zwylair
in your plugin’s description as a thank you for the contribution. Thanks ♥


⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣤⣀⠀⠀⠀⠀⣀⣠⣤⣤⣤⣄⡀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⠿⠛⠛⠛⠛⠛⢿⣷⣤⣾⠿⠛⠛⠙⠛⠛⠿⠗
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⡿⠁⠀⠀⠀⠀⠀⠀⠀⠙⡿⠁⠀⠀⠀⢀⣤⣀⠀⠀⢀⣤⣶⡆
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⡇
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣿⣿⣿⣿⣿⣧⣄
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠀⣿⣷⣄⣀⣤⡄⠀⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⠷
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣁⣤⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠘⠛⠛⠛⠻⣿⣿⣿⠋⠉⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠻⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠹⣿⡟⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⠟⢙⠛⠛⠀⠀⠀⠀⠀⠀⣀⣴⡿⠓⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠁⠀⠈⠻⢿⣦⣄⠀⣠⣾⡿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣿⠿⠋⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀
"""

from typing import Any, Dict, Callable, List

from hook_utils import get_private_field, set_private_field
from client_utils import get_messages_controller
from base_plugin import BasePlugin, HookResult, XposedHook

from java.util import Locale, ArrayList
from java.lang import Boolean, Integer, Long
from android.view import View
from org.telegram.messenger import MessageObject
from org.telegram.ui import ChatActivity
from org.telegram.tgnet import TLRPC, TLObject

__name__ = "NoForwardLimit"
__description__ = "Removes the limit of 100 forward messages (requires zwylib)"
__icon__ = "zwyPluginsIcons/6"
__id__ = "zwyNoForwardLimit"
__version__ = "1.1.3"
__author__ = "@zwylair"
__min_version__ = "11.12.1"


def get_selected_msgs_array_index(param):
    message_object = param.args[0]
    return int(message_object.getDialogId() != dialog_id)


def update_reply_button_visibility(selected_only_one_message: bool):
    logger.info("updating reply button visibility")
    reply_button.setVisibility(View.VISIBLE if selected_only_one_message else View.GONE)


def update_select_button_visibility():
    logger.info("updating select button visibility")

    java_msgs_main = java_msgs[0]
    new_select_visibility = View.GONE

    if select_button is None:
        return

    if java_msgs_main.size() > 1:
        all_selected_msg_ids = get_sparsearray_keys(java_msgs_main) + get_sparsearray_keys(java_msgs[1])

        all_selected_msg_ids.sort()
        begin = all_selected_msg_ids[0]
        end = all_selected_msg_ids[-1]

        for i in range(messages.size()):
            msg = messages.get(i)
            msg_id = msg.getId()

            is_in_bounds = begin < msg_id < end
            is_selected = java_msgs_main.indexOfKey(msg_id) >= 0

            if is_in_bounds and not is_selected and msg.contentType == 0:
                new_select_visibility = View.VISIBLE
                break

    if select_button_animator:
        select_button_animator.cancel()

    current_visibility = select_button.getVisibility()
    if current_visibility != new_select_visibility:
        if new_select_visibility == View.VISIBLE:
            select_button.setVisibility(View.VISIBLE)
            select_button.setAlpha(1.0)
            select_button.setScaleY(1.0)
        else:
            select_button.setAlpha(0.0)
            select_button.setScaleY(0.0)
            select_button.setVisibility(View.GONE)


def get_sparsearray_keys(sparse_array):
    return [sparse_array.keyAt(i) for i in range(sparse_array.size())]


def cancel_selection_mode(chat_activity):
    hide_action_mode_method.invoke(chat_activity)
    update_pinned_msg_view_method.invoke(chat_activity, [True])


def split_list_into_chunks(lst: List[int], chunk_size: int) -> List[List[int]]:
    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]


def decrement_cant_forward_count(chat_activity):
    global cant_forward_msgs_count
    cant_forward_msgs_count -= 2  # -2, cuz 1 was added when the message was added, and another 1 cuz it was added right before the current hook call

    logger.info(f"[after] decrementing cantForwardMessagesCount. new value: {cant_forward_msgs_count}")
    set_private_field(chat_activity, "cantForwardMessagesCount", Integer(cant_forward_msgs_count))

    if cant_forward_msgs_count == 0:
        forward_button.setEnabled(True)
        forward_button.setAlpha(1.0)


def decrement_cant_delete_count(chat_activity):
    global cant_delete_messages_count
    cant_delete_messages_count -= 2  # -2, cuz 1 was added when the message was added, and another 1 cuz it was added right before the current hook call

    logger.info(f"[after] decrementing cantDeleteMessagesCount. new value: {cant_delete_messages_count}")
    set_private_field(chat_activity, "cantDeleteMessagesCount", Integer(cant_delete_messages_count))

    if cant_delete_messages_count == 0:
        delete_item.setVisibility(View.VISIBLE)


class SelectorHook(XposedHook):
    def __init__(self):
        super().__init__()
        self.messages_array: Dict[int, MessageObject] = {}
        self.is_processing_msg_group = False
        self.is_last_in_group = False
        self.handle_end_of_select_msg_group_call = False

    def before_hooked_method(self, param):
        chat_activity = param.thisObject
        selected_msg_obj = param.args[0]
        tapped_outside: bool = param.args[1]
        is_last: bool = param.args[2]
        is_grouped = selected_msg_obj.getGroupId() != 0

        # if the id of dialog not equals the cached one
        if get_private_field(chat_activity, "dialog_id") != dialog_id:
            refresh_activity_cache(chat_activity)

        if self.is_processing_msg_group:
            self.is_last_in_group = is_last
            logger.info(f"[before] selected group member (msg_id={selected_msg_obj.getId()}, last={self.is_last_in_group})")
            return

        if tapped_outside and is_last and is_grouped:
            logger.info(f"[before] started selection of a group (with replaced array) (msg_id={selected_msg_obj.getId()})")
            self.is_processing_msg_group = True

        # replace selected messages array
        index = get_selected_msgs_array_index(param)
        java_msgs[index] = param.thisObject.SparseArrayWithTouch()
        set_private_field(param.thisObject, "selectedMessagesIds", java_msgs)

    def after_hooked_method(self, param):
        if self.handle_end_of_select_msg_group_call:
            self.handle_end_of_select_msg_group_call = False
            return

        if self.is_processing_msg_group:
            if not self.is_last_in_group:
                return

            logger.info("[after] ended selection of group")

            self.is_processing_msg_group = False
            self.is_last_in_group = False
            self.handle_end_of_select_msg_group_call = True

        chat_activity = param.thisObject
        index = get_selected_msgs_array_index(param)
        selected_msgs_array = java_msgs[index]
        is_in_schedule_mode = chat_mode == 1

        # add/remove new messages from local db
        for index in reversed(range(selected_msgs_array.size())):
            message_id = selected_msgs_array.keyAt(index)
            message_object = selected_msgs_array.get(message_id)

            if message_id in self.messages_array.keys():
                logger.info(f"[after] unselecting message id: {message_id}")

                if not message_object.canForwardMessage():
                    decrement_cant_forward_count(chat_activity)

                if not message_object.canDeleteMessage(is_in_schedule_mode, current_chat):
                    decrement_cant_delete_count(chat_activity)

                self.messages_array.pop(message_id)
            else:
                logger.info(f"[after] selecting message id: {message_id}")
                self.messages_array[message_id] = message_object

        # restore selected messages
        selected_msgs_array.clear()
        for k, v in self.messages_array.items():
            selected_msgs_array.put(k, v)

        # handle no messages selected case
        if len(self.messages_array) == 0:
            cancel_selection_mode(chat_activity)
            return

        logger.info(f"[after] local db: {self.messages_array}")
        logger.info(f"[after] java db: {selected_msgs_array}")

        update_reply_button_visibility(len(self.messages_array) == 1)
        update_select_button_visibility()

        # separator
        for _ in range(3):
            logger.info("[after] \n")

    def clear_message_storage(self):
        logger.info("clearing local select db")
        self.messages_array.clear()


class ClearSelectionHook(XposedHook):
    def before_hooked_method(self, param):
        selector_hook.clear_message_storage()


class MultiSelectorHook(XposedHook):
    def __init__(self, hook_method: Callable):
        super().__init__()
        self.hook_method = hook_method

    def after_hooked_method(self, param):
        class BypassLimitReachedHook:
            def replace_hooked_method(self, _param):
                return False

        chat_list_view = get_private_field(param.thisObject, "chatListView")
        selection_listener = get_private_field(chat_list_view, "multiSelectionListener")
        method = selection_listener.getClass().getMethod("limitReached")
        self.hook_method(method, BypassLimitReachedHook())


class DeleteMessagesHook(XposedHook):
    chunk_size = 100

    def before_hooked_method(self, param):
        first_msg_array = param.args[0]
        second_msg_array = param.args[1]

        if first_msg_array.size() > 0:
            msgs = first_msg_array
            selected_msg_array_arg_index = 0
        else:
            msgs = second_msg_array
            selected_msg_array_arg_index = 1

        messages: List[int] = zwylib.arraylist_to_list(msgs)

        logger.info(f"got messages list (size={len(messages)})")

        if len(messages) <= self.chunk_size:
            logger.info(f"{len(messages)} <= {self.chunk_size}. split skipped.")

            # separator
            for _ in range(5):
                logger.info("")
            return

        message_ids_chunks: List[List[int]] = split_list_into_chunks(messages, self.chunk_size)
        last_chunk_index = len(message_ids_chunks) - 1

        logger.info(f"split to {len(message_ids_chunks)} chunks of ~{self.chunk_size}")

        for index, chunk in enumerate(message_ids_chunks):
            preview = ", ".join(map(str, chunk[:5]))
            logger.info(f"\t[chunk {index}] {preview}, ...")

            param.args[selected_msg_array_arg_index] = zwylib.list_to_arraylist(chunk)

            if index < last_chunk_index:
                param.method.invoke(param.thisObject, param.args)

        # separator
        for _ in range(5):
            logger.info("")


class Locales:
    en = {
        "zwylib_was_not_found": "ZwyLib plugin required for this plugin is not found!",
    }
    ru = {
        "zwylib_was_not_found": "Требуемый плагин ZwyLib не найден!",
    }
    uk = {
        "zwylib_was_not_found": "Не знайдено обов’язковий плагін ZwyLib!",
    }
    default = en


def localise(key: str) -> str:
    locale_dict = getattr(Locales, LOCALE, Locales.default)
    return locale_dict.get(key, key)


def refresh_activity_cache(chat_activity):
    global cant_delete_messages_count, cant_forward_msgs_count, delete_item, forward_button, reply_button, \
        select_button_animator, chat_mode, current_chat, dialog_id, java_msgs, messages, select_button

    cant_delete_messages_count = get_private_field(chat_activity, "cantDeleteMessagesCount")
    cant_forward_msgs_count = get_private_field(chat_activity, "cantForwardMessagesCount")
    delete_item = get_private_field(chat_activity, "deleteItem")
    forward_button = get_private_field(chat_activity, "forwardButton")
    reply_button = get_private_field(chat_activity, "replyButton")
    select_button_animator = get_private_field(chat_activity, "selectButtonAnimation")
    chat_mode = get_private_field(chat_activity, "chatMode")
    current_chat = get_private_field(chat_activity, "currentChat")
    dialog_id = get_private_field(chat_activity, "dialog_id")
    java_msgs = get_private_field(chat_activity, "selectedMessagesIds")
    messages = get_private_field(chat_activity, "messages")
    select_button = get_private_field(chat_activity, "selectButton")


AUTOUPDATE_CHANNEL_ID = 2521243181
AUTOUPDATE_MSG_ID = 53
LOG_PREFIX = __name__
LOCALE = Locale.getDefault().getLanguage()

try:
    import zwylib
except (ImportError, ModuleNotFoundError):
    raise Exception(localise("zwylib_was_not_found"))

selector_hook = SelectorHook()
logger = zwylib.build_log(LOG_PREFIX)
BulletinHelper = zwylib.build_bulletin_helper(LOG_PREFIX)

ChatActivityClass = ChatActivity.getClass()
hide_action_mode_method = ChatActivityClass.getDeclaredMethod("hideActionMode")
update_pinned_msg_view_method = ChatActivityClass.getDeclaredMethod("updatePinnedMessageView", Boolean.TYPE)

cant_delete_messages_count: Any = None
cant_forward_msgs_count: Any = None
delete_item: Any = None
forward_button: Any = None
reply_button: Any = None
select_button_animator: Any = None
chat_mode: Any = None
current_chat: Any = None
dialog_id: Any = None
java_msgs: Any = None
messages: Any = None
select_button: Any = None

hide_action_mode_method.setAccessible(True)
update_pinned_msg_view_method.setAccessible(True)

class NoForwardLimit(BasePlugin):
    def on_plugin_load(self):
        zwylib.add_autoupdater_task(__id__, AUTOUPDATE_CHANNEL_ID, AUTOUPDATE_MSG_ID)

        self.add_on_send_message_hook()
        self.add_hook("TL_messages_forwardMessages")

        selector_method = ChatActivityClass.getDeclaredMethod("addToSelectedMessages", MessageObject, Boolean.TYPE, Boolean.TYPE)
        selector_method.setAccessible(True)
        self.hook_method(selector_method, selector_hook)

        clear_selection_method = ChatActivityClass.getDeclaredMethod("hideActionMode")
        clear_selection_method.setAccessible(True)
        self.hook_method(clear_selection_method, ClearSelectionHook())

        multi_selector_method = ChatActivityClass.getDeclaredMethod("startMultiselect", Integer.TYPE)
        multi_selector_method.setAccessible(True)
        self.hook_method(multi_selector_method, MultiSelectorHook(self.hook_method))

        clazz = get_messages_controller().getClass()
        delete_messages_method = clazz.getDeclaredMethod("deleteMessages", ArrayList, ArrayList, TLRPC.EncryptedChat, Long.TYPE, Boolean.TYPE, Integer.TYPE, Boolean.TYPE, Long.TYPE, TLObject, Integer.TYPE, Boolean.TYPE, Integer.TYPE)
        self.hook_method(delete_messages_method, DeleteMessagesHook())

        logger.info("Loaded")

    def on_plugin_unload(self):
        zwylib.remove_autoupdater_task(__id__)
        logger.info("Unloaded")

    def pre_request_hook(self, req_name, account, req):
        if req_name == "TL_messages_forwardMessages":
            selector_hook.clear_message_storage()
        return HookResult()
