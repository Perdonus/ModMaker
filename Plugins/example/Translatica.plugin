from base_plugin import BasePlugin, HookStrategy, HookResult, MenuItemData, MenuItemType
from typing import Any
import requests
import time
from ui.bulletin import BulletinHelper
from android_utils import run_on_ui_thread, log
from android.view import Gravity
from android.widget import FrameLayout, TextView, LinearLayout
from android.util import TypedValue
from android_utils import OnClickListener
from client_utils import get_last_fragment, get_messages_controller, send_request

__id__          = "translatica"
__name__        = "Translatica"
__description__ = "A context aware translation plugin that rewrites messages to sound natural in the chosen language, with full control over translation behavior.\n\nИнструмент контекстного перевода, который переформулирует сообщения так, чтобы они звучали естественно на выбранном языке и обеспечивает полный контроль над процессом перевода."
__author__      = "@AGeekApple"
__version__     = "1.0.2"
__min_version__ = "11.12.0"
__icon__        = "ApplePlugins/19"

class Translatica(BasePlugin):
    # Sistema de desativação de logs
    _TRANSLATICA_LOGS_MUTED = False

    def _set_log_muted(self, muted: bool):
        try:
            Translatica._TRANSLATICA_LOGS_MUTED = bool(muted)
        except Exception:
            pass

    # API do Gemini
    def _show_gemini_api_sheet(self):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                # Se não há contexto UI, abre link diretamente
                self._open_gemini_api_link()
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            title_view = TextView(ctx)
            title_view.setText("Google Gemini")
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            desc_view = TextView(ctx)
            desc_view.setText(self._t("gemini_howto_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("get_gemini_api_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_gemini_api_link()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    # API do OpenRouter
    def _show_openrouter_api_sheet(self):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                self._open_openrouter_api_link()
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            title_view = TextView(ctx)
            title_view.setText(self._t("howto_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            try:
                WebView = self._find_class_safe("android.webkit.WebView")
                web_view = WebView(ctx)
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                # Permitir acesso a arquivos locais no WebView para carregar imagens em cache
                try:
                    web_view.getSettings().setAllowFileAccess(True)
                    web_view.getSettings().setAllowFileAccessFromFileURLs(True)
                    web_view.getSettings().setAllowUniversalAccessFromFileURLs(True)
                    web_view.getSettings().setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception:
                    pass
                # Cache local da imagem e uso com base relativa
                _ = self._get_cached_image_src("https://i.postimg.cc/6prvBL0L/openrouter.png", "openrouter.png")
                html = """
                <html>
                <head>
                    <style>
                        body { margin: 0; padding: 0; background-color: transparent; }
                        img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                    </style>
                </head>
                <body>
                    <img src='openrouter.png' alt='API Banner'>
                </body>
                </html>
                """
                base = "file://" + self._get_cache_dir_path() + "/"
                web_view.loadDataWithBaseURL(base, html, "text/html", "UTF-8", None)
                container.addView(web_view, self._layout_helper_create_linear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            desc_view = TextView(ctx)
            desc_view.setText(self._t("howto_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("get_api_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_openrouter_api_link()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            # Conteúdo do OpenRouter apenas (sem seção Gemini)

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _show_using_translatica_sheet(self):
        try:
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            title_view = TextView(ctx)
            title_view.setText(self._t("using_translatica_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            try:
                WebView = self._find_class_safe("android.webkit.WebView")
                web_view = WebView(ctx)
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                # Permitir acesso a arquivos locais no WebView para carregar imagens em cache
                try:
                    web_view.getSettings().setAllowFileAccess(True)
                    web_view.getSettings().setAllowFileAccessFromFileURLs(True)
                    web_view.getSettings().setAllowUniversalAccessFromFileURLs(True)
                    web_view.getSettings().setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception:
                    pass
                local_src = self._get_cached_image_src("https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExaDE3NmkyZmtzZXNzZ2ZsbmhqeHNwNTJuaHEyOTMxZ2I3b3JpaGt4eSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/2OfiQeMc1drQYdoARu/giphy.gif", "using_translatica.gif")
                html = f"""
                <html>
                <head>
                    <style>
                        body {{ margin: 0; padding: 0; background-color: transparent; }}
                        img {{ width: 100%; height: auto; display: block; margin-bottom: -4px; }}
                    </style>
                </head>
                <body>
                    <img src='{local_src}' alt='Banner'>
                </body>
                </html>
                """
                base = "file://" + self._get_cache_dir_path() + "/"
                web_view.loadDataWithBaseURL(base, html, "text/html", "UTF-8", None)
                container.addView(web_view, self._layout_helper_create_linear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            desc_view = TextView(ctx)
            desc_view.setText(self._t("using_translatica_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("ok_button_label"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _log_wrapper(self, original_log):
        def wrapper(*args, **kwargs):
            try:
                if not Translatica._TRANSLATICA_LOGS_MUTED:
                    return original_log(*args, **kwargs)
            except Exception:
                return original_log(*args, **kwargs)
        return wrapper

    def _apply_log_wrapper(self):
        try:
            global log
            log = self._log_wrapper(log)
        except Exception:
            pass

    # Helper de log com prefixo do plugin
    def _log(self, message: str):
        try:
            log(f"[Translatica] {message}")
        except Exception:
            pass

    # Aplicar wrapper ao carregar classe
    _apply_log = True

    # Dicionário
    TRANSLATIONS = {
        
        "bullet_tokens_insufficient": {
            "en": "No tokens",
            "pt": "Sem tokens",
            "es": "Sin tokens",
            "ru": "Нет токенов",
        },
        "translation_section": {
            "en": "Translation",
            "pt": "Tradução",
            "es": "Traducción",
            "ru": "Перевод",
        },
        "dictionary_section": {
            "en": "Dictionary",
            "pt": "Dicionário",
            "es": "Diccionario",
            "ru": "Словарь",
        },
        "help_section": {
            "en": "Help",
            "pt": "Ajuda",
            "es": "Ayuda",
            "ru": "Помощь",
        },
        "extras_section": {
            "en": "Extras",
            "pt": "Extras",
            "es": "Extras",
            "ru": "Дополнительно",
        },
        "welcome_brief": {
            "en": "Welcome, {name}!\n\nTo use Translatica, configure your API key for OpenRouter or Google Gemini. You can also add your own AI provider using any OpenAI compatible endpoint. Check the section ‘Using Translatica’ for a quick guide.",
            "pt": "Bem-vindo(a), {name}!\n\nPara usar o Translatica, configure sua chave de API do OpenRouter ou do Google Gemini. Você também pode adicionar seu próprio provedor de IA usando qualquer endpoint compatível com OpenAI. Leia a seção ‘Usando o Translatica’ para um guia rápido.",
            "es": "¡Bienvenido(a), {name}!\n\nPara usar Translatica, configura tu clave de API de OpenRouter o de Google Gemini. También puedes añadir tu propio proveedor de IA usando cualquier endpoint compatible con OpenAI. Consulta la sección ‘Usando Translatica’ para una guía rápida.",
            "ru": "Добро пожаловать, {name}!\n\nЧтобы использовать Translatica, настройте ключ API для OpenRouter или Google Gemini. Вы также можете добавить собственного провайдера ИИ через любой совместимый с OpenAI endpoint. Ознакомьтесь с разделом «Как пользоваться Translatica» для быстрого руководства."
        },
        "logs_disable_subtext": {
            "en": "Hides plugin logs and notifications",
            "pt": "Oculta logs e notificações do plugin",
            "es": "Oculta registros y notificaciones del plugin",
            "ru": "Скрывает логи и уведомления плагина"
        },
        "using_translatica_label": {
            "en": "Using Translatica",
            "pt": "Usando o Translatica",
            "es": "Usando Translatica",
            "ru": "Как пользоваться Translatica"
        },
        "using_translatica_title": {
            "en": "Using Translatica",
            "pt": "Usando o Translatica",
            "es": "Usando Translatica",
            "ru": "Как пользоваться Translatica"
        },
        "using_translatica_description": {
            "en": "Translatica requires an API key to translate messages. You can use OpenRouter or Google Gemini, and you can also add your own AI provider using any OpenAI compatible endpoint.\n\nChoose the provider in the settings, enter the corresponding API key and select a model. Enable or disable Translatica through chat menu > plugins, or by sending .on (enable) and .off (disable).\n\nPer chat: use .add to activate translations in the current chat, and .del to deactivate them.\n\nLanguage override per chat: send .add followed by a language code (en, pt, es, ru or cm) to force that language. Example: .add en. Send .add reset to remove the override.\n\nIf any chats are added, translations run only in those chats except the ones disabled with .del. Otherwise, translations run in all chats except the ones disabled with .del.",
            "pt": "O Translatica exige uma chave de API para traduzir mensagens. Você pode usar OpenRouter ou Google Gemini e também pode adicionar seu próprio provedor de IA usando qualquer endpoint compatível com OpenAI.\n\nEscolha o provedor nas configurações, informe a chave correspondente e selecione um modelo. Ative ou desative o Translatica pelo menu do chat > plugins ou enviando .on (ativar) e .off (desativar).\n\nPor chat: use .add para ativar traduções no chat atual e .del para desativá-las.\n\nIdioma por chat: envie .add seguido de um código de idioma (en, pt, es, ru ou cm) para fixar o idioma. Exemplo: .add pt. Envie .add reset para remover o idioma definido.\n\nSe houver chats adicionados, as traduções funcionarão apenas neles, exceto os desativados com .del. Caso contrário, funcionarão em todos os chats, exceto os desativados com .del.",
            "es": "Translatica requiere una clave de API para traducir mensajes. Puedes usar OpenRouter o Google Gemini y también puedes añadir tu propio proveedor de IA usando cualquier endpoint compatible con OpenAI.\n\nElige el proveedor en la configuración, introduce la clave correspondiente y selecciona un modelo. Activa o desactiva Translatica desde el menú del chat > plugins o enviando .on (activar) y .off (desactivar).\n\nPor chat: usa .add para activar traducciones en el chat actual y .del para desactivarlas.\n\nIdioma por chat: envía .add seguido de un código de idioma (en, pt, es, ru o cm) para fijar el idioma. Ejemplo: .add es. Envía .add reset para quitar el idioma fijado.\n\nSi hay chats añadidos, las traducciones se ejecutarán solo en ellos excepto los desactivados con .del. De lo contrario, se ejecutarán en todos los chats excepto los desactivados con .del.",
            "ru": "Для работы Translatica требуется ключ API. Можно использовать OpenRouter или Google Gemini, а также можно добавить собственного провайдера ИИ через любой совместимый с OpenAI endpoint.\n\nВыберите провайдера в настройках, укажите ключ и модель. Включать или выключать Translatica можно через меню чата > плагины или командами .on и .off.\n\nДля каждого чата: используйте .add, чтобы включить перевод в текущем чате, и .del, чтобы выключить его.\n\nЯзык для чата: отправьте .add с кодом языка (en, pt, es, ru или cm), чтобы закрепить язык. Пример: .add ru. Отправьте .add reset, чтобы убрать закрепление.\n\nЕсли есть чаты, добавленные через .add, перевод будет работать только в них, кроме отключенных через .del. В остальных случаях перевод работает во всех чатах, кроме отключенных через .del."
        },
        "ok_button_label": {
            "en": "Understood",
            "pt": "Entendido",
            "es": "Entendido",
            "ru": "Понятно"
        },
        "cmd_on_success": {
            "en": "Translations enabled",
            "pt": "Traduções ativadas",
            "es": "Traducciones activadas",
            "ru": "Перевод включен"
        },
        "cmd_on_already_on": {
            "en": "Already enabled",
            "pt": "Já está ativado",
            "es": "Ya está activado",
            "ru": "Уже включено"
        },
        "cmd_off_success": {
            "en": "Translations disabled",
            "pt": "Traduções desativadas",
            "es": "Traducciones desactivadas",
            "ru": "Перевод выключен"
        },
        "cmd_off_already_off": {
            "en": "Already disabled",
            "pt": "Já está desativado",
            "es": "Ya está desactivado",
            "ru": "Уже выключено"
        },
        "cmd_add_success": {
            "en": "Chat added to enabled list",
            "pt": "Chat adicionado à lista de ativados",
            "es": "Chat añadido a la lista de activados",
            "ru": "Чат добавлен в список включённых"
        },
        "cmd_add_already": {
            "en": "Chat already in enabled list",
            "pt": "Chat já está na lista de ativados",
            "es": "El chat ya está en la lista de activados",
            "ru": "Чат уже в списке включённых"
        },
        "cmd_del_success": {
            "en": "Chat removed from enabled list",
            "pt": "Chat removido da lista de ativados",
            "es": "Chat eliminado de la lista de activados",
            "ru": "Чат удалён из списка включённых"
        },
        "cmd_del_already": {
            "en": "Chat was not in enabled list",
            "pt": "Chat não estava na lista de ativados",
            "es": "El chat no estaba en la lista de activados",
            "ru": "Чат отсутствовал в списке включённых"
        },
        "cmd_add_lang_success": {
            "en": "Chat enabled with language {lang}",
            "pt": "Chat ativado com idioma {lang}",
            "es": "Chat activado con idioma {lang}",
            "ru": "Чат включён с языком {lang}"
        },
        "cmd_add_lang_reset": {
            "en": "Chat language override removed",
            "pt": "Idioma do chat redefinido",
            "es": "Idioma del chat restablecido",
            "ru": "Переопределение языка чата удалено"
        },
        "cmd_block_success": {
            "en": "Chat disabled for translations",
            "pt": "Chat desativado para traduções",
            "es": "Chat desactivado para traducciones",
            "ru": "Чат отключён для перевода"
        },
        "cmd_block_already": {
            "en": "Chat already disabled",
            "pt": "Chat já está desativado",
            "es": "El chat ya está desactivado",
            "ru": "Чат уже отключён"
        },
        "cmd_dialog_not_found": {
            "en": "Could not identify this chat",
            "pt": "Não foi possível identificar este chat",
            "es": "No fue posible identificar este chat",
            "ru": "Не удалось определить этот чат"
        },
        "always_correct_label": {
            "en": "Always Correct",
            "pt": "Sempre Correto",
            "es": "Siempre Correcto",
            "ru": "Всегда правильно"
        },
        "always_correct_subtext": {
            "en": "Ensures proper grammar, punctuation and capitalization",
            "pt": "Garante gramática, pontuação e capitalização corretas",
            "es": "Garantiza gramática, puntuación y capitalización correctas",
            "ru": "Обеспечивает правильную грамматику, пунктуацию и заглавные буквы"
        },
        "fast_mode_label": {
            "en": "Fast send mode",
            "pt": "Modo rápido de envio",
            "es": "Modo de envío rápido",
            "ru": "Быстрый режим отправки",
        },
        "fast_mode_subtext": {
            "en": "Experimental mode. Prioritizes speed using a lighter model with fewer tokens",
            "pt": "Modo experimental. Prioriza a velocidade usando um modelo mais leve e menos tokens",
            "es": "Modo experimental. Prioriza la velocidad usando un modelo más ligero y menos tokens",
            "ru": "Экспериментальный режим. Приоритет скорости за счёт более лёгкой модели и меньшего количества токенов"
        },
        "target_language_label": {
            "en": "Target language",
            "pt": "Idioma alvo",
            "es": "Idioma objetivo",
            "ru": "Целевой язык",
        },
        "lang_custom": {
            "en": "Custom",
            "pt": "Custom",
            "es": "Personalizado",
            "ru": "Пользовательский",
        },
        "custom_lang_label": {
            "en": "Custom language",
            "pt": "Idioma personalizado",
            "es": "Idioma personalizado",
            "ru": "Пользовательский язык"
        },
        "custom_lang_subtext": {
            "en": "Type any language name, for example: Hindi, French, Italian",
            "pt": "Digite o nome de qualquer idioma, por exemplo: Hindi, Francês, Italiano",
            "es": "Escribe el nombre de cualquier idioma, por ejemplo: Hindi, Francés, Italiano",
            "ru": "Введите название любого языка, например: хинди, французский, итальянский"
        },
        "api_key_label": {
            "en": "API Key",
            "pt": "Chave de API",
            "es": "Clave de API",
            "ru": "Ключ API"
        },
        "ai_provider_label": {
            "en": "AI Provider",
            "pt": "Provedor de IA",
            "es": "Proveedor de IA",
            "ru": "Провайдер ИИ"
        },
        "ai_provider_custom": {
            "en": "Custom",
            "pt": "Personalizado",
            "es": "Personalizado",
            "ru": "Пользовательский"
        },
        
        "openrouter_api_key_label": {
            "en": "OpenRouter API Key",
            "pt": "Chave OpenRouter",
            "es": "Clave OpenRouter",
            "ru": "Ключ OpenRouter"
        },
        "gemini_api_key_label": {
            "en": "Gemini API Key",
            "pt": "Chave do Gemini",
            "es": "Clave de Gemini",
            "ru": "Ключ Gemini"
        },
        "get_api_help_label": {
            "en": "Get the API",
            "pt": "Obter a API",
            "es": "Obtener la API",
            "ru": "Получить API",
        },
        "get_openrouter_api_label": {
            "en": "Get OpenRouter API",
            "pt": "Obter API do OpenRouter",
            "es": "Obtener API de OpenRouter",
            "ru": "Получить API OpenRouter"
        },
        "get_gemini_api_button": {
            "en": "Get Gemini API",
            "pt": "Obter API do Gemini",
            "es": "Obtener API de Gemini",
            "ru": "Получить API Gemini"
        },
        "custom_api_url_label": {
            "en": "Custom API URL",
            "pt": "URL de API (custom)",
            "es": "URL de API (custom)",
            "ru": "URL API (кастом)",
        },
        "custom_api_key_label": {
            "en": "Custom API Key",
            "pt": "Chave de API (custom)",
            "es": "Clave de API (custom)",
            "ru": "Ключ API (кастом)",
        },
        "custom_model_label": {
            "en": "Custom model",
            "pt": "Modelo (custom)",
            "es": "Modelo (custom)",
            "ru": "Модель (кастом)",
        },
        "howto_title": {
            "en": "Get the API",
            "pt": "Obter a API",
            "es": "Obtener la API",
            "ru": "Получить API",
        },
        "howto_description": {
            "en": "You need an OpenRouter API key to use AI models through this service.",
            "pt": "Você precisa de uma chave de API do OpenRouter para usar os modelos por meio deste serviço.",
            "es": "Necesitas una clave de API de OpenRouter para usar los modelos a través de este servicio.",
            "ru": "Вам нужен ключ API OpenRouter, чтобы использовать модели через этот сервис."
        },
        
        "gemini_howto_description": {
            "en": "Go to aistudio.google.com/apikey, sign in and create an API key. This provider uses an OpenAI-compatible endpoint.",
            "pt": "Acesse aistudio.google.com/apikey, faça login e crie uma chave de API. Este provedor usa um endpoint compatível com OpenAI.",
            "es": "Ve a aistudio.google.com/apikey, inicia sesión y crea una clave de API. Este proveedor usa un endpoint compatible con OpenAI.",
            "ru": "Перейдите на aistudio.google.com/apikey, войдите и создайте ключ API. Этот провайдер использует совместимый с OpenAI endpoint."
        },
        "get_api_button": {
            "en": "Get the API",
            "pt": "Obter a API",
            "es": "Obtener la API",
            "ru": "Получить API",
        },
        "model_label": {
            "en": "Model",
            "pt": "Modelo",
            "es": "Modelo",
            "ru": "Модель",
        },
        "model_creativity_section": {
            "en": "Model & Creativity",
            "pt": "Modelo e Criatividade",
            "es": "Modelo y Creatividad",
            "ru": "Модель и Креативность",
        },
        "temperature_label": {
            "en": "Creativity",
            "pt": "Criatividade",
            "es": "Creatividad",
            "ru": "Креативность"
        },
        "plugin_language_label": {
            "en": "Plugin language",
            "pt": "Idioma do plugin",
            "es": "Idioma del plugin",
            "ru": "Язык плагина",
        },
        
        "quick_dismiss_subtext": {
            "en": "Shows an alert when sending a text",
            "pt": "Exibe um alerta ao enviar texto",
            "es": "Muestra una alerta al enviar texto",
            "ru": "Показывает предупреждение при отправке текста",
        },
        
        "aura_subtext": {
            "en": "Displays a subtle ripple effect when sending",
            "pt": "Exibe um efeito ripple sutil ao enviar",
            "es": "Muestra un efecto ripple sutil al enviar",
            "ru": "Отображает тонкий эффект ряби при отправке"
        },
        "logs_disable_label": {
            "en": "Disable Logs",
            "pt": "Desativar Logs",
            "es": "Desactivar Logs",
            "ru": "Отключить логи"
        },
        "quick_dismiss_alert_text": {
            "en": "Message is being sent",
            "pt": "Mensagem sendo enviada",
            "es": "Mensaje siendo enviado",
            "ru": "Сообщение отправляется",
        },
        "chat_overrides_title": {
            "en": "Languages per chat",
            "pt": "Idiomas por chat",
            "es": "Idiomas por chat",
            "ru": "Языки по чатам",
        },
        "chat_overrides_empty": {
            "en": "No chat with a fixed language (.add lang)",
            "pt": "Nenhum chat com idioma fixado (.add lang)",
            "es": "Ningún chat con idioma fijado (.add lang)",
            "ru": "Нет чатов с закреплённым языком (.add lang)",
        },
        "lang_english": {
            "en": "English",
            "pt": "Inglês",
            "es": "Inglés",
            "ru": "Английский",
        },
        "lang_portuguese": {
            "en": "Portuguese",
            "pt": "Português",
            "es": "Portugués",
            "ru": "Португальский",
        },
        "lang_spanish": {
            "en": "Spanish",
            "pt": "Espanhol",
            "es": "Español",
            "ru": "Испанский",
        },
        "lang_russian": {
            "en": "Russian",
            "pt": "Russo",
            "es": "Ruso",
            "ru": "Русский",
        },
        "plugin_enabled_msg": {
            "en": "Translatica enabled",
            "pt": "Translatica ativado",
            "es": "Translatica activado",
            "ru": "Translatica включен",
        },
        "plugin_disabled_msg": {
            "en": "Translatica disabled",
            "pt": "Translatica desativado",
            "es": "Translatica desactivado",
            "ru": "Translatica выключен",
        },
        
        "support_title": {
            "en": "Support",
            "pt": "Suporte",
            "es": "Soporte",
            "ru": "Поддержка",
        },
        "support_description": {
            "pt": "Oi. Sou o Apple, desenvolvedor de plugins e projetos independentes. Se você curtiu, pode apoiar enviando um presente pelo Telegram. É só tocar no meu nome de usuário ou me chamar se quiser ajudar de outra forma. Seu apoio mantém os projetos ativos e novas ideias ganhando vida. Obrigado.",
            "en": "Hey. I am Apple, a developer of plugins and independent projects. If you like what I do, you can support it by sending a gift on Telegram. Just tap my username or reach out if you’d like to help in another way. Your support keeps the projects alive and new ideas coming. Thank you.",
            "ru": "Привет. Я Apple, разработчик плагинов и независимых проектов. Если вам нравится моя работа, вы можете поддержать меня, отправив подарок в Telegram. Просто нажмите на мое имя пользователя или напишите мне, если хотите помочь другим способом. Ваша поддержка помогает проектам развиваться и воплощать новые идеи. Спасибо."
        },
        "support_button": {
            "en": "Contact the Dev",
            "pt": "Falar com o Dev",
            "es": "Contactar al Dev",
            "ru": "Связаться с разработчиком"
        },
        "optional_label": {
            "en": "Advanced Options",
            "pt": "Opções Avançadas",
            "es": "Opciones Avanzadas",
            "ru": "Дополнительные параметры"
        },
        "prompt_selector_label": {
            "en": "Prompt",
            "pt": "Prompt",
            "es": "Prompt",
            "ru": "Подсказка",
        },
        "prompt_mode_base": {
            "en": "Translatica Mode",
            "pt": "Translatica Mode",
            "es": "Translatica Mode",
            "ru": "Режим Translatica",
        },
        "prompt_mode_extra": {
            "en": "Enhancement",
            "pt": "Aprimoramento",
            "es": "Mejora",
            "ru": "Уточнение"
        },
        "prompt_extra_input_label": {
            "en": "Enhancement prompt",
            "pt": "Prompt de aprimoramento",
            "es": "Prompt de mejora",
            "ru": "Подсказка уточнения"
        },
        "advanced_cat_logging": {
            "en": "Logging",
            "pt": "Registros",
            "es": "Registros",
            "ru": "Журналы",
        },
        "advanced_cat_prompt": {
            "en": "Prompt",
            "pt": "Prompt",
            "es": "Prompt",
            "ru": "Подсказка",
        },
        "advanced_cat_optional": {
            "en": "Optional",
            "pt": "Opcional",
            "es": "Opcional",
            "ru": "Опционально",
        },
        "advanced_cat_behavior": {
            "en": "Translation Behavior",
            "pt": "Comportamento de Tradução",
            "es": "Comportamiento de Traducción",
            "ru": "Поведение перевода",
        },
        "advanced_cat_language": {
            "en": "Plugin Language",
            "pt": "Idioma do Plugin",
            "es": "Idioma del Plugin",
            "ru": "Язык плагина"
        },
    }

    # Resolve a tradução para uma chave com base no idioma atual do plugin
    def _t(self, key: str) -> str:
        try:
            lang = self._get_plugin_lang_code()
            d = self.TRANSLATIONS.get(key)
            if not d:
                return key
            return d.get(lang) or d.get("en") or key
        except Exception:
            return key

    # Utilitários de cache para imagens (.png) nos BottomSheets
    def _get_cache_dir_path(self) -> str:
        try:
            from org.telegram.messenger import ApplicationLoader
            base = str(ApplicationLoader.getFilesDirFixed())
            import os
            p = os.path.join(base, "translatica_cache")
            try:
                os.makedirs(p, exist_ok=True)
            except Exception:
                pass
            return p
        except Exception:
            return "/"

    def _get_cached_image_src(self, url: str, name: str) -> str:
        try:
            import os
            cache_dir = self._get_cache_dir_path()
            local_path = os.path.join(cache_dir, name)
            if not os.path.exists(local_path):
                try:
                    resp = requests.get(url, timeout=10)
                    if resp and resp.status_code == 200:
                        with open(local_path, "wb") as f:
                            f.write(resp.content)
                except Exception:
                    pass
            return ("file://" + local_path) if os.path.exists(local_path) else url
        except Exception:
            return url

    # Detecta erros de cota/tokens e exibe um boletim curto
    def _maybe_show_tokens_bulletin(self, resp) -> None:
        try:
            text_low = str(getattr(resp, "text", "") or "").lower()
            data = {}
            try:
                data = resp.json() if resp.text else {}
            except Exception:
                data = {}
            err = None
            if isinstance(data, dict):
                err = data.get("error") or data.get("errors") or None
            msg = ""
            code = ""
            status = ""
            if isinstance(err, dict):
                msg = str(err.get("message", "") or "").lower()
                code = str(err.get("code", "") or "").lower()
                status = str(err.get("status", "") or "").lower()
            elif isinstance(err, list) and err:
                try:
                    msg = str((err[0] or {}).get("message", "") or "").lower()
                    code = str((err[0] or {}).get("code", "") or "").lower()
                    status = str((err[0] or {}).get("status", "") or "").lower()
                except Exception:
                    pass
            keywords = [
                "insufficient_quota",
                "quota exceeded",
                "quota_exceeded",
                "resource_exhausted",
                "no credits",
                "not enough credits",
                "insufficient tokens",
                "token quota",
                "exceeded quota",
            ]
            blob = " ".join([text_low, msg, code, status])
            if any(k in blob for k in keywords):
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_error(self._t("bullet_tokens_insufficient")))
                except Exception:
                    pass
                try:
                    self._log("Cota de tokens insuficiente; exibindo bulletin curto")
                except Exception:
                    pass
        except Exception:
            pass

    # Helpers robustos para leitura de booleans salvos como bool/int/str
    def _get_bool_setting(self, key: str, default: bool = False) -> bool:
        try:
            val = self.get_setting(key, default)
            if isinstance(val, bool):
                return val
            if isinstance(val, int):
                return val != 0
            s = str(val).strip().lower()
            if s in ("true", "1", "yes", "on"):  # valores verdadeiros comuns
                return True
            if s in ("false", "0", "no", "off", ""):
                return False
            return bool(val) if val is not None else bool(default)
        except Exception:
            return bool(default)

    # Helpers de idioma do plugin
    def _get_plugin_lang_index(self) -> int:
        try:
            raw = self.get_setting("plugin_lang", 0)
            # Aceita código ou índice
            codes = ["en", "pt", "es", "ru"]
            try:
                idx = int(raw)
                return idx if 0 <= idx < len(codes) else 0
            except Exception:
                try:
                    return codes.index(str(raw or "en").lower())
                except Exception:
                    return 0
        except Exception:
            return 0

    def _get_plugin_lang_code(self) -> str:
        try:
            codes = ["en", "pt", "es", "ru"]
            idx = self._get_plugin_lang_index()
            return codes[idx]
        except Exception:
            return "en"
    # Mapeia as chaves para rótulos de idiomas
    def _opcoes_idioma(self):
        return [
            {"key": "pt", "label": "Português"},
            {"key": "en", "label": "Inglês"},
            {"key": "es", "label": "Espanhol"},
            {"key": "ru", "label": "Russo"},
            {"key": "custom", "label": "Custom"},
        ]

    # Modelos disponíveis via OpenRouter (slugs oficiais)
    def _opcoes_modelos(self):
        return [
            {"key": "google/gemini-2.5-flash", "label": "Gemini 2.5 Flash"},
            {"key": "google/gemini-2.5-pro", "label": "Gemini 2.5 Pro"},
            {"key": "google/gemini-2.5-flash-lite", "label": "Gemini 2.5 Flash Lite"},
            {"key": "google/gemini-2.0-flash-lite", "label": "Gemini 2.0 Flash Lite"},
        ]

    # Modelos via Gemini direto (endpoint Google OpenAI-compatible)
    def _opcoes_modelos_gemini(self):
        return [
            {"key": "gemini-2.5-pro", "label": "gemini-2.5-pro"},
            {"key": "gemini-2.5-flash", "label": "gemini-2.5-flash"},
            {"key": "gemini-flash-latest", "label": "gemini-flash-latest"},
            {"key": "gemini-2.5-flash-lite", "label": "gemini-2.5-flash-lite"},
            {"key": "gemini-flash-lite-latest", "label": "gemini-flash-lite-latest"},
        ]

    def _get_ai_provider_idx(self) -> int:
        try:
            raw = self.get_setting("ai_provider", 0)
            return int(raw) if str(raw).isdigit() else 0
        except Exception:
            return 0

    def _resolve_model_for_provider(self, prov_idx: int) -> str:
        try:
            # Lista de modelos conforme provedor
            if prov_idx == 0:
                modelos = [m["key"] for m in self._opcoes_modelos()]  # OpenRouter slugs
                default_model = modelos[0] if modelos else "google/gemini-2.5-flash"
            elif prov_idx == 1:
                modelos = [m["key"] for m in self._opcoes_modelos_gemini()]  # Gemini direto
                default_model = modelos[0] if modelos else "gemini-2.5-flash"
            else:
                # Provedor custom: modelo livre via Input
                raw_custom = str(self.get_setting("custom_model_name", "") or "").strip()
                return raw_custom

            raw = self.get_setting("modelo_gemini", default_model)
            # Permite índice salvo (preferível) ou slug
            try:
                idx = int(raw)
                if 0 <= idx < len(modelos):
                    return modelos[idx]
            except Exception:
                pass

            # Caso slug: tenta mapear entre provedores ao trocar
            val = str(raw or default_model)
            if prov_idx == 0:
                # Se usuário tinha salvo um slug de Gemini puro (sem prefixo), prefixar para OpenRouter
                if "/" not in val:
                    pref = f"google/{val}"
                    return pref if pref in modelos else default_model
                return val if val in modelos else default_model
            else:
                # Se usuário tinha salvo um slug OpenRouter (com prefixo), remover 'google/'
                if "/" in val:
                    parts = val.split("/")
                    tail = parts[-1]
                    return tail if tail in modelos else default_model
                return val if val in modelos else default_model
        except Exception:
            return "gemini-2.5-flash"

    # Obtém o código ISO do idioma escolhido pelo usuário
    def _idioma_alvo(self):
        try:
            # Aceita índice (Selector) ou código (compatibilidade)
            raw = self.get_setting("idioma_alvo", "pt")
            codigos = ["pt", "en", "es", "ru"]
            try:
                idx = int(raw)
                if idx >= len(codigos):
                    val = str(self.get_setting("idioma_custom_code", "") or "").strip()
                    return val if val else "pt"
                if 0 <= idx < len(codigos):
                    return codigos[idx]
            except Exception:
                pass
            val = str(raw or "pt").lower()
            if val not in codigos:
                # Caso antigo com código diferente: usar custom se existir
                custom = str(self.get_setting("idioma_custom_code", "") or "").strip()
                if custom:
                    return custom
                val = "pt"
            return val
        except Exception:
            return "pt"

    def _open_openrouter_api_link(self):
        try:
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            # Preferir navegador interno (WebView)
            try:
                from hook_utils import find_class
                Browser = find_class("org.telegram.messenger.browser.Browser")
                Browser.openUrl(ctx, "https://openrouter.ai/settings/keys")
                return
            except Exception:
                pass
            # Fallback para Intent do Android se Browser falhar
            try:
                from android.content import Intent
                from android.net import Uri
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://openrouter.ai/settings/keys"))
                ctx.startActivity(intent)
            except Exception:
                pass
        except Exception:
            pass

    def _open_gemini_api_link(self):
        try:
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            try:
                from hook_utils import find_class
                Browser = find_class("org.telegram.messenger.browser.Browser")
                Browser.openUrl(ctx, "https://aistudio.google.com/apikey")
                return
            except Exception:
                pass
            try:
                from android.content import Intent
                from android.net import Uri
                intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://aistudio.google.com/apikey"))
                ctx.startActivity(intent)
            except Exception:
                pass
        except Exception:
            pass

    def _lang_label_from_code(self, code: str) -> str:
        try:
            c = str(code or "").lower().strip()
            mapping = {
                "pt": self._t("lang_portuguese"),
                "en": self._t("lang_english"),
                "es": self._t("lang_spanish"),
                "ru": self._t("lang_russian"),
            }
            if c in mapping:
                return mapping[c]
            return c.upper() if c else "—"
        except Exception:
            return str(code or "—")

    def _get_dialog_title_by_id(self, did: int) -> str:
        try:
            mc = self.get_messages_controller()
            if mc is None:
                return str(did)
            if isinstance(did, int) and did > 0:
                try:
                    user = mc.getUser(did)
                    if user:
                        try:
                            from org.telegram.messenger import ContactsController
                            return str(ContactsController.formatName(user.first_name, user.last_name) or (getattr(user, "username", "") or str(did))).replace("\n", " ")
                        except Exception:
                            return str(getattr(user, "first_name", "") or getattr(user, "username", "") or did)
                except Exception:
                    pass
            else:
                try:
                    chat = mc.getChat(-did)
                    if chat:
                        return str(getattr(chat, "title", str(did)) or str(did))
                except Exception:
                    pass
            return str(did)
        except Exception:
            return str(did)

    def _show_chat_overrides_sheet(self):
        try:
            overrides = self._load_chat_lang_overrides()
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                return

            from org.telegram.ui.ActionBar import BottomSheet, Theme
            from android.widget import LinearLayout, TextView
            from android.util import TypedValue
            container = LinearLayout(ctx)
            try:
                container.setOrientation(LinearLayout.VERTICAL)
            except Exception:
                pass
            try:
                title_view = TextView(ctx)
                title_view.setText(self._t("chat_overrides_title") or "Idiomas por Chat")
                try:
                    title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                except Exception:
                    pass
                try:
                    title_view.setTypeface(Theme.getTypeface("fonts/rmedium.ttf"))
                except Exception:
                    pass
                try:
                    title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 20)
                except Exception:
                    pass
                container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))
            except Exception:
                pass
            if not overrides:
                try:
                    empty_view = TextView(ctx)
                    empty_view.setText(self._t("chat_overrides_empty") or "Nenhum chat com idioma fixado (.add lang)")
                    try:
                        empty_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteGrayText))
                    except Exception:
                        pass
                    try:
                        empty_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 15)
                    except Exception:
                        pass
                    container.addView(empty_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))
                except Exception:
                    pass
            else:
                try:
                    items = []
                    for did, code in overrides.items():
                        name = self._get_dialog_title_by_id(int(did))
                        items.append((name, int(did), str(code)))
                    items.sort(key=lambda x: x[0].lower())
                    for name, did, code in items:
                        try:
                            line = TextView(ctx)
                            label = f"{name} - {self._lang_label_from_code(code)}"
                            line.setText(label)
                            try:
                                line.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
                            except Exception:
                                pass
                            try:
                                line.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16)
                            except Exception:
                                pass
                            container.addView(line, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 6, 24, 6))
                        except Exception:
                            pass
                except Exception:
                    pass
            try:
                sheet = BottomSheet(ctx, True)
                sheet.setCustomView(container)
                run_on_ui_thread(sheet.show)
            except Exception:
                pass
        except Exception:
            try:
                self._log("Erro ao abrir lista de idiomas por chat")
            except Exception:
                pass


    # Helpers locais para LayoutHelper sem import direto
    def _layout_helper_create_linear(self, w, h, g, l, t, r, b):
        try:
            from org.telegram.ui.Components import LayoutHelper
            return LayoutHelper.createLinear(w, h, g, l, t, r, b)
        except Exception:
            return None

    def _layout_helper_create_frame(self, w, h, g):
        try:
            from org.telegram.ui.Components import LayoutHelper
            return LayoutHelper.createFrame(w, h, g)
        except Exception:
            return None

    def _find_class_safe(self, name):
        try:
            from hook_utils import find_class
            return find_class(name)
        except Exception:
            return None

    # Aura: Efeito ripple suave ao enviar mensagens (menção honrosa: @mihailkotovski)
    def _tocar_ripple_suave(self, intensidade: float = 0.35):
        try:
            if not self._get_bool_setting("aura_enabled", False):
                return
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                try:
                    from org.telegram.messenger import ApplicationLoader
                    ctx = ApplicationLoader.applicationContext
                except Exception:
                    ctx = None
            if not ctx:
                return
            try:
                view = None
                try:
                    window = ctx.getWindow()
                    if window:
                        view = window.getDecorView()
                except Exception:
                    view = None
                width = float(view.getWidth()) if view else 540.0
                height = float(view.getHeight()) if view else 960.0
                cx = width / 2.0
                cy = height / 2.0
            except Exception:
                cx, cy = 270.0, 480.0
            try:
                LA = self._find_class_safe("org.telegram.ui.LaunchActivity")
                if LA and hasattr(LA, "makeRipple"):
                    run_on_ui_thread(lambda: LA.makeRipple(float(cx), float(cy), float(intensidade)))
            except Exception:
                pass
        except Exception:
            pass

    # Prompt para tradução com contexto
    def _montar_prompt(self, texto, idioma_destino):
        try:
            # Orientações para evitar tradução literal e garantir contexto
            system = (
                "Você é uma assistente de tradução contextual altamente natural. Traduza o conteúdo fornecido "
                "para o idioma solicitado sem recorrer a tradução literal. Preserve intenção, tom, estilo, "
                "nuances culturais, nomes próprios, siglas e números. Soe completamente natural para nativos "
                "do idioma-alvo. Nunca use hífens ou travessões de diálogo e não utilize listas, bullets ou "
                "qualquer estrutura de marcação. Reestruture frases quando necessário para evitar características "
                "de tradução automática. Entregue apenas uma única passagem contínua de texto, sem explicações, "
                "sem metadados, sem comentários e sem qualquer conteúdo além da tradução."
            )
            try:
                if self._get_bool_setting("always_correct_enabled", False):
                    system += " Garanta gramática e pontuação corretas, com capitalização adequada no início de frases e após pontuação final."
            except Exception:
                pass
            # Complemento de Prompt (modo 'Complement') — compatível com índice (0/1) ou string ('base'/'extra')
            try:
                raw_mode = self.get_setting("prompt_mode", "base")
                if isinstance(raw_mode, int):
                    mode_raw = "base" if int(raw_mode) == 0 else "extra"
                else:
                    mode_raw = str(raw_mode or "base").lower()
                extra_text = str(self.get_setting("prompt_extra_text", "") or "").strip()
                if mode_raw == "extra" and extra_text:
                    system += f" Além disso, aplique este complemento de estilo: {extra_text}. Mantenha naturalidade humana, evitando tom robótico."
            except Exception:
                pass
            user = (
                f"Idioma de destino: {idioma_destino}\n"
                f"Texto para traduzir:\n{texto}"
            )
            return system, user
        except Exception:
            return "Traduza com contexto.", str(texto or "")

    # Chama o endpoint de chat para obter a tradução
    def _traduzir_com_ia(self, texto, idioma_destino):
        try:
            start_ts = time.time()
            prov_idx = self._get_ai_provider_idx()
            system, user = self._montar_prompt(texto, idioma_destino)
            messages = [
                {"role": "system", "content": system},
                {"role": "user", "content": user},
            ]

            # Temperatura (Criatividade) e tokens
            try:
                temperatura = float(self.get_setting("temperatura", 0.2))
            except Exception:
                temperatura = 0.2
            fast_mode = self._get_bool_setting("fast_mode_enabled", False)
            max_tokens = 800
            if fast_mode:
                max_tokens = 256

            # Seleção de modelo com compatibilidade entre provedores
            modelo = self._resolve_model_for_provider(prov_idx)

            if prov_idx == 0:
                # OpenRouter
                api_key = str(self.get_setting("openrouter_api_key", "") or "").strip()
                if not api_key:
                    self._log("Tradução ignorada (OpenRouter): sem API key")
                    return texto
                base = "https://openrouter.ai/api/v1"
                url = f"{base}/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Authorization": f"Bearer {api_key}",
                }
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    self._log(f"Traduzindo via OpenRouter: modelo={modelo}, temp={temperatura}, idioma={idioma_destino}, len={len(str(texto))}")
                except Exception:
                    pass
            elif prov_idx == 1:
                # Google Gemini (endpoint OpenAI-compatible)
                api_key = str(self.get_setting("gemini_api_key", "") or "").strip()
                if not api_key:
                    self._log("Tradução ignorada (Gemini): sem API key")
                    return texto
                base = "https://generativelanguage.googleapis.com/v1beta/openai"
                url = f"{base}/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                    "Authorization": f"Bearer {api_key}",
                }
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    self._log(f"Traduzindo via Gemini (OpenAI-compat): modelo={modelo}, temp={temperatura}, idioma={idioma_destino}, len={len(str(texto))}")
                except Exception:
                    pass
            else:
                # Custom OpenAI-compatible
                base = str(self.get_setting("custom_api_url", "") or "").strip()
                if not base:
                    self._log("Tradução ignorada (Custom): URL vazia")
                    return texto
                # Remove barras duplicadas no final para estabilidade de concatenação
                try:
                    while base.endswith("//"):
                        base = base[:-1]
                except Exception:
                    pass
                api_key = str(self.get_setting("custom_api_key", "") or "").strip()
                if not modelo:
                    self._log("Tradução ignorada (Custom): modelo ausente")
                    return texto
                url = f"{base.rstrip('/')}/chat/completions"
                headers = {
                    "Content-Type": "application/json",
                    "Accept": "application/json",
                }
                if api_key:
                    headers["Authorization"] = f"Bearer {api_key}"
                payload = {
                    "model": modelo,
                    "messages": messages,
                    "temperature": temperatura,
                    "max_tokens": max_tokens,
                }
                try:
                    self._log(f"Traduzindo via Custom OpenAI-compat: base={base}, modelo={modelo}, temp={temperatura}, idioma={idioma_destino}, len={len(str(texto))}")
                except Exception:
                    pass

            # Requisição HTTP
            try:
                resp = requests.post(url, headers=headers, json=payload, timeout=(10, 30) if fast_mode else (10, 60))
            except Exception as e:
                self._log(f"Erro HTTP ao traduzir: {e}")
                resp = None

            # Fallbacks para Gemini se a chamada OpenAI-compat falhar
            if resp is not None and resp.status_code != 200 and prov_idx == 1:
                try:
                    self._log(f"Gemini compat falhou ({resp.status_code}); tentando com query key...")
                except Exception:
                    pass
                try:
                    url2 = f"https://generativelanguage.googleapis.com/v1beta/openai/chat/completions?key={api_key}"
                    headers2 = {"Content-Type": "application/json", "Accept": "application/json"}
                    resp = requests.post(url2, headers=headers2, json=payload, timeout=(10, 30) if fast_mode else (10, 60))
                except Exception as e:
                    self._log(f"Erro HTTP fallback Gemini (query key): {e}")
                    resp = None

            if resp is not None and resp.status_code != 200 and prov_idx == 1:
                try:
                    self._log(f"Gemini compat ainda falhou ({resp.status_code}); fallback generateContent...")
                except Exception:
                    pass
                try:
                    model_gc = modelo.split("/")[-1]
                    url3 = f"https://generativelanguage.googleapis.com/v1beta/models/{model_gc}:generateContent?key={api_key}"
                    prompt = f"{system}\n\n{user}"
                    payload3 = {
                        "contents": [{"parts": [{"text": prompt}]}],
                        "generationConfig": {
                            "temperature": temperatura,
                            "maxOutputTokens": max_tokens,
                        }
                    }
                    headers3 = {"Content-Type": "application/json", "Accept": "application/json"}
                    resp = requests.post(url3, headers=headers3, json=payload3, timeout=(10, 30) if fast_mode else (10, 60))
                except Exception as e:
                    self._log(f"Erro HTTP fallback Gemini (generateContent): {e}")
                    resp = None

            if resp is None:
                return texto
            if resp.status_code != 200:
                try:
                    self._maybe_show_tokens_bulletin(resp)
                except Exception:
                    pass
                try:
                    self._log(f"Falha na tradução: status={resp.status_code}; body='{resp.text[:180]}'")
                except Exception:
                    pass
                return texto

            data = resp.json() if resp.text else {}
            conteudo = ""
            try:
                if prov_idx == 1 and isinstance(data, dict) and "candidates" in data:
                    cands = data.get("candidates", [])
                    if cands:
                        conteudo = (((cands[0] or {}).get("content") or {}).get("parts") or [{}])[0].get("text") or ""
                else:
                    ch = data.get("choices", [])
                    if ch and isinstance(ch, list):
                        c0 = ch[0]
                        conteudo = (c0.get("message") or {}).get("content") or c0.get("content") or c0.get("text") or ""
            except Exception:
                conteudo = ""

            saida = str(conteudo or "").strip()
            if not saida:
                try:
                    self._log("Tradução vazia; retornando texto original")
                except Exception:
                    pass
                return texto

            saida = saida.replace("\u2026", "").strip()
            try:
                elapsed = (time.time() - start_ts)
                preview = (saida[:60] + ("…" if len(saida) > 60 else ""))
                self._log(f"Tradução concluída em {elapsed:.2f}s; saída={len(saida)} chars; preview='{preview}'")
            except Exception:
                pass
            return saida
        except Exception as e:
            try:
                self._log(f"Erro inesperado em tradução: {e}")
            except Exception:
                pass
            return texto

    # Hook de envio: traduz antes de enviar
    def on_send_message_hook(self, account: int, params: Any) -> HookResult:
        try:
            # Evita loop: se estamos reenviando a própria mensagem traduzida, não intercepte
            try:
                if getattr(self, "_suppress_next_hook", False):
                    self._suppress_next_hook = False
                    return HookResult(strategy=HookStrategy.DEFAULT)
            except Exception:
                pass
            # Respeita estado on/off do plugin, mas permite comandos .on/.off/.add/.del sempre
            try:
                if not self._is_enabled():
                    try:
                        if isinstance(params.message, str):
                            _cmd = params.message.strip().lower()
                            # Mesmo desativado, permitir comandos de controle e utilidade
                            if _cmd in (".on", ".off", ".add", ".del", ".chat", ".chats", ".op"):
                                pass
                            else:
                                return HookResult()
                        else:
                            return HookResult()
                    except Exception:
                        return HookResult()
            except Exception:
                pass
            # Apenas processa mensagens de texto
            if not isinstance(params.message, str):
                return HookResult()

            mensagem_original = params.message.strip()
            if not mensagem_original:
                return HookResult()
            try:
                preview = (mensagem_original[:60] + ("…" if len(mensagem_original) > 60 else ""))
                self._log(f"Interceptado envio: conta={account}, len={len(mensagem_original)}; preview='{preview}'")
            except Exception:
                pass

            # Comandos .on / .off e .add / .del (sempre funcionam e sempre cancelam)
            cmd = mensagem_original.strip().lower()
            if cmd == ".op": # Que curioso, né? Tá fazendo o quê aqui?
                try:
                    self._log("Comando .op: abrir configurações do plugin")
                except Exception:
                    pass
                try:
                    from hook_utils import find_class
                    PluginSettingsActivity = find_class("org.telegram.ui.PluginSettingsActivity")
                    fragment = get_last_fragment()
                    if fragment and PluginSettingsActivity:
                        fragment.presentFragment(PluginSettingsActivity(self))
                except Exception:
                    try:
                        fragment = get_last_fragment()
                        fragment.presentFragment(PluginSettingsActivity(self))
                    except Exception:
                        pass
                return HookResult(HookStrategy.CANCEL)
            if cmd == ".on":
                if self._is_enabled():
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_on_already_on")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                self.set_setting("plugin_enabled", 1)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("cmd_on_success")))
                    self._log("Cmd .on: plugin_enabled=1")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)
            if cmd == ".off":
                if not self._is_enabled():
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_off_already_off")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                self.set_setting("plugin_enabled", 0)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_off_success")))
                    self._log("Cmd .off: plugin_enabled=0")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)
            if cmd.startswith(".add"):
                did = self._extract_dialog_id(params)
                if not did:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_dialog_not_found")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                enabled = self._load_enabled_dialogs()
                disabled = self._load_disabled_dialogs()
                overrides = self._load_chat_lang_overrides()
                # Parse subcomando em estilo SearchIt: ".add <sub>" (opcional)
                try:
                    parts = mensagem_original.strip().split()
                    sub = parts[1].strip().lower() if len(parts) >= 2 else ""
                    if sub.startswith("-"):
                        sub = sub[1:].strip()
                except Exception:
                    sub = ""
                if sub:
                    if sub == "reset":
                        if did in overrides:
                            del overrides[did]
                            self._save_chat_lang_overrides(overrides)
                        if did not in enabled:
                            enabled.add(did)
                            self._save_enabled_dialogs(enabled)
                        if did in disabled:
                            disabled.discard(did)
                            self._save_disabled_dialogs(disabled)
                        try:
                            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_add_lang_reset")))
                            self._log(f"Cmd .add reset: did={did}")
                        except Exception:
                            pass
                        return HookResult(HookStrategy.CANCEL)
                    else:
                        lang_map = {"en": "en", "pt": "pt", "es": "es", "ru": "ru", "cm": str(self.get_setting("idioma_custom_code", "") or "").strip()}
                        sel = lang_map.get(sub, sub)
                        overrides[did] = sel
                        self._save_chat_lang_overrides(overrides)
                        if did not in enabled:
                            enabled.add(did)
                            self._save_enabled_dialogs(enabled)
                        if did in disabled:
                            disabled.discard(did)
                            self._save_disabled_dialogs(disabled)
                        try:
                            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("cmd_add_lang_success").format(lang=sel or sub)))
                            self._log(f"Cmd .add lang: did={did} lang={sel}")
                        except Exception:
                            pass
                        return HookResult(HookStrategy.CANCEL)
                if did in enabled:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_add_already")))
                        self._log(f"Cmd .add: did={did} already enabled")
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                enabled.add(did)
                if did in disabled:
                    disabled.discard(did)
                    self._save_disabled_dialogs(disabled)
                self._save_enabled_dialogs(enabled)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("cmd_add_success")))
                    self._log(f"Cmd .add: did={did} enabled")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)
            if cmd == ".del":
                did = self._extract_dialog_id(params)
                if not did:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_dialog_not_found")))
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                enabled = self._load_enabled_dialogs()
                disabled = self._load_disabled_dialogs()
                if did in enabled:
                    enabled.discard(did)
                    self._save_enabled_dialogs(enabled)
                if did in disabled:
                    try:
                        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_block_already")))
                        self._log(f"Cmd .del: did={did} already disabled")
                    except Exception:
                        pass
                    return HookResult(HookStrategy.CANCEL)
                disabled.add(did)
                self._save_disabled_dialogs(disabled)
                try:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("cmd_block_success")))
                    self._log(f"Cmd .del: did={did} disabled")
                except Exception:
                    pass
                return HookResult(HookStrategy.CANCEL)

            # Comando .chat / .chats: mostra info com chats e idiomas fixados (.add lang)
            if cmd in (".chat", ".chats"):
                try:
                    run_on_ui_thread(lambda: self._show_chat_overrides_sheet())
                except Exception:
                    self._show_chat_overrides_sheet()
                return HookResult(HookStrategy.CANCEL)

            # Fast mode: envia imediatamente o original e, em background, envia a tradução como mensagem subsequente
            try:
                fast_mode = self._get_bool_setting("fast_mode_enabled", False)
            except Exception:
                fast_mode = False
            if fast_mode:
                try:
                    from client_utils import run_on_queue, get_send_messages_helper
                except Exception:
                    run_on_queue = None
                    get_send_messages_helper = None
                # Respeita overrides por chat também no Fast Mode
                try:
                    did_for_lang_fast = self._extract_dialog_id(params)
                except Exception:
                    did_for_lang_fast = 0
                overrides_fast = self._load_chat_lang_overrides()
                idioma_fast = overrides_fast.get(did_for_lang_fast) or self._idioma_alvo()
                def _translate_and_send_fast():
                    try:
                        self._log("Fast mode: traduzindo em background")
                        texto_traduzido_local = self._traduzir_com_ia(mensagem_original, idioma_fast)
                        if not texto_traduzido_local or texto_traduzido_local == mensagem_original:
                            return
                        try:
                            params.message = texto_traduzido_local
                        except Exception:
                            pass
                        def _mark_and_send_fast():
                            try:
                                self._suppress_next_hook = True
                            except Exception:
                                pass
                            try:
                                run_on_ui_thread(lambda: self._tocar_ripple_suave())
                            except Exception:
                                pass
                            try:
                                self._log("Fast mode: enviando tradução subsequente")
                            except Exception:
                                pass
                            get_send_messages_helper().sendMessage(params)
                        run_on_ui_thread(_mark_and_send_fast)
                    except Exception:
                        try:
                            self._log("Fast mode: erro ao traduzir em background")
                        except Exception:
                            pass
                try:
                    if run_on_queue:
                        run_on_queue(_translate_and_send_fast)
                    else:
                        import threading
                        threading.Thread(target=_translate_and_send_fast).start()
                except Exception:
                    pass
                return HookResult(HookStrategy.DEFAULT)

            # Quick Dismiss: mostra um spinner durante a tradução e dispensa ao concluir
            try:
                qd_enabled = self._get_bool_setting("quick_dismiss_enabled", False)
            except Exception:
                qd_enabled = False

            quick_dialog = None
            if qd_enabled:
                try:
                    fragment = self.get_last_fragment_safe()
                    ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
                    if not ctx:
                        try:
                            from org.telegram.messenger import ApplicationLoader
                            ctx = ApplicationLoader.applicationContext
                        except Exception:
                            ctx = None
                    if ctx:
                        # Usa AlertDialogBuilder com spinner, padrão em outros plugins Apple
                        from ui.alert import AlertDialogBuilder
                        quick_dialog = AlertDialogBuilder(ctx, AlertDialogBuilder.ALERT_TYPE_SPINNER)
                        quick_dialog.set_title("Quick Dismiss")
                        quick_dialog.set_message(self._t("quick_dismiss_alert_text"))
                        try:
                            quick_dialog.set_cancelable(False)
                        except Exception:
                            pass
                        try:
                            quick_dialog.set_canceled_on_touch_outside(False)
                        except Exception:
                            pass
                        try:
                            quick_dialog.set_progress(0)
                        except Exception:
                            pass
                        run_on_ui_thread(quick_dialog.show)
                except Exception:
                    quick_dialog = None

            # Verificar filtro por chat
            try:
                enabled_set = self._load_enabled_dialogs()
                disabled_set = self._load_disabled_dialogs()
                did = self._extract_dialog_id(params)
                if did:
                    if enabled_set:
                        if (did not in enabled_set) or (did in disabled_set):
                            return HookResult()
                    else:
                        if did in disabled_set:
                            return HookResult()
            except Exception:
                pass

            try:
                did_for_lang = self._extract_dialog_id(params)
            except Exception:
                did_for_lang = 0
            overrides = self._load_chat_lang_overrides()
            idioma = overrides.get(did_for_lang) or self._idioma_alvo()

            # Quando Quick Dismiss está ativo, cancela o envio original e reenvia após traduzir
            if qd_enabled:
                try:
                    from client_utils import run_on_queue, get_send_messages_helper
                except Exception:
                    # Fallback: traduz sincrono e modifica params
                    self._log("Quick Dismiss indisponível; traduzindo de forma síncrona")
                    texto_traduzido = self._traduzir_com_ia(mensagem_original, idioma)
                    params.message = texto_traduzido
                    try:
                        changed = (texto_traduzido != mensagem_original)
                        self._log(f"Envio síncrono: traduzido={changed}")
                    except Exception:
                        pass
                    return HookResult(HookStrategy.MODIFY, params=params)

                def _translate_and_send():
                    try:
                        self._log("Tradução assíncrona iniciada")
                        texto_traduzido_local = self._traduzir_com_ia(mensagem_original, idioma)
                        try:
                            params.message = texto_traduzido_local
                        except Exception:
                            pass
                        # Atualiza e fecha o diálogo, então envia
                        if quick_dialog:
                            try:
                                run_on_ui_thread(lambda: quick_dialog.set_progress(100))
                            except Exception:
                                pass
                            run_on_ui_thread(quick_dialog.dismiss)
                        try:
                            def _mark_and_send():
                                try:
                                    self._suppress_next_hook = True
                                except Exception:
                                    pass
                                try:
                                    run_on_ui_thread(lambda: self._tocar_ripple_suave())
                                except Exception:
                                    pass
                                try:
                                    changed = (texto_traduzido_local != mensagem_original)
                                    self._log(f"Envio assíncrono: traduzido={changed}")
                                except Exception:
                                    pass
                                get_send_messages_helper().sendMessage(params)
                            run_on_ui_thread(_mark_and_send)
                        except Exception:
                            pass
                    except Exception:
                        # Fecha o diálogo em caso de erro
                        if quick_dialog:
                            try:
                                run_on_ui_thread(quick_dialog.dismiss)
                            except Exception:
                                pass
                        try:
                            self._log("Erro na tradução assíncrona; diálogo fechado")
                        except Exception:
                            pass
                    
                run_on_queue(_translate_and_send)
                return HookResult(HookStrategy.CANCEL)

            # Quick Dismiss desativado: traduz assíncrono e reenvia para evitar travar UI
            try:
                from client_utils import run_on_queue, get_send_messages_helper
            except Exception:
                # Fallback: manter fluxo síncrono se APIs de fila não estiverem disponíveis
                self._log("Quick Dismiss desativado; fallback síncrono por ausência de run_on_queue")
                texto_traduzido = self._traduzir_com_ia(mensagem_original, idioma)
                params.message = texto_traduzido
                try:
                    run_on_ui_thread(lambda: self._tocar_ripple_suave())
                except Exception:
                    pass
                try:
                    changed = (texto_traduzido != mensagem_original)
                    self._log(f"Envio síncrono: traduzido={changed}")
                except Exception:
                    pass
                return HookResult(HookStrategy.MODIFY, params=params)

            def _translate_and_send_no_qd():
                try:
                    self._log("Tradução assíncrona iniciada (QD off)")
                    texto_traduzido_local = self._traduzir_com_ia(mensagem_original, idioma)
                    try:
                        params.message = texto_traduzido_local
                    except Exception:
                        pass
                    def _mark_and_send():
                        try:
                            self._suppress_next_hook = True
                        except Exception:
                            pass
                        try:
                            run_on_ui_thread(lambda: self._tocar_ripple_suave())
                        except Exception:
                            pass
                        try:
                            changed = (texto_traduzido_local != mensagem_original)
                            self._log(f"Envio assíncrono (QD off): traduzido={changed}")
                        except Exception:
                            pass
                        get_send_messages_helper().sendMessage(params)
                    run_on_ui_thread(_mark_and_send)
                except Exception:
                    try:
                        self._log("Erro na tradução assíncrona (QD off)")
                    except Exception:
                        pass

            run_on_queue(_translate_and_send_no_qd)
            return HookResult(HookStrategy.CANCEL)
        except Exception as e:
            try:
                self._log(f"Erro inesperado no hook de envio: {e}")
            except Exception:
                pass
            return HookResult()

    # Carregamento do plugin: registra o hook
    def on_plugin_load(self) -> None:
        # Garante que o hook de envio esteja ativo
        self.add_on_send_message_hook()
        # Registrar subfragmentos de forma explícita (quando o host suportar)
        try:
            register = getattr(self, "register_subfragment", None)
            if callable(register):
                # Permite abrir diretamente pelas rotas internas (ex.: optional_subfragment)
                register("optional_subfragment", self._create_optional_subfragment)
        except Exception:
            pass
        # Aplicar wrapper de logs apenas uma vez
        try:
            if Translatica._apply_log:
                self._apply_log_wrapper()
                Translatica._apply_log = False
        except Exception:
            pass
        # Aplicar estado inicial de desativação de logs a partir das configurações
        try:
            initial_muted = False
            try:
                initial_muted = bool(int(self.get_setting("logs_disabled", 0)))
            except Exception:
                initial_muted = bool(self.get_setting("logs_disabled", False))
            self._set_log_muted(initial_muted)
        except Exception:
            pass
        # Garante item de toggle no menu do chat
        try:
            self._ensure_chat_toggle_menu_item()
        except Exception:
            pass

    # Configurações expostas na tela de ajustes
    def create_settings(self):
        try:
            from ui.settings import Header, Divider, Input, Selector, Switch, Text
            labels = [
                self._t("lang_portuguese"),
                self._t("lang_english"),
                self._t("lang_spanish"),
                self._t("lang_russian"),
                self._t("lang_custom"),
            ]
            codes = ["pt", "en", "es", "ru"]
            raw = self.get_setting("idioma_alvo", "pt")
            try:
                raw_idx = int(raw)
                lang_idx = raw_idx if 0 <= raw_idx < len(labels) else 0
            except Exception:
                try:
                    v = str(raw or "pt").lower()
                    lang_idx = codes.index(v) if v in codes else (len(labels) - 1)
                except Exception:
                    lang_idx = 0

            # Provider atual e lista de modelos correspondente
            prov_idx = self._get_ai_provider_idx()
            modelos = self._opcoes_modelos() if prov_idx == 0 else self._opcoes_modelos_gemini()
            modelo_labels = [m["label"] for m in modelos]
            modelo_keys = [m["key"] for m in modelos]
            raw_model = self.get_setting("modelo_gemini", modelo_keys[0])
            try:
                m_idx = int(raw_model)
                modelo_idx = m_idx if 0 <= m_idx < len(modelo_labels) else 0
            except Exception:
                try:
                    modelo_idx = modelo_keys.index(str(raw_model or modelo_keys[0]))
                except Exception:
                    modelo_idx = 0

            # Seletor de idioma do plugin para facilitar a vida
            plugin_lang_idx = self._get_plugin_lang_index()

            # Estados atuais
            qd_default = self._get_bool_setting("quick_dismiss_enabled", False)
            logs_muted = self._get_bool_setting("logs_disabled", False)

            # Temperatura: selector com valores predefinidos
            temp_values = [0.0, 0.2, 0.4, 0.7, 1.0]
            temp_labels = ["0.0", "0.2", "0.4", "0.7", "1.0"]
            # Prioriza chave de índice dedicada para estabilidade do componente
            try:
                temp_idx = int(self.get_setting("temperatura_idx", 1))
                if temp_idx < 0 or temp_idx >= len(temp_values):
                    temp_idx = 1
            except Exception:
                # Compatibilidade: deriva índice do valor float salvo em "temperatura"
                try:
                    raw_temp = float(self.get_setting("temperatura", 0.2))
                except Exception:
                    raw_temp = 0.2
                try:
                    temp_idx = temp_values.index(raw_temp)
                except Exception:
                    # Seleciona o índice do valor mais próximo
                    try:
                        closest = min(range(len(temp_values)), key=lambda i: abs(temp_values[i] - raw_temp))
                        temp_idx = closest
                    except Exception:
                        temp_idx = 1

            # Welcome divider with user name
            try:
                user_name = self._get_current_user_name()
            except Exception:
                user_name = ""
            welcome_text = (self._t("welcome_brief") or "").format(name=str(user_name or ""))

            items = [
                Divider(text=welcome_text or self._t("translation_section")),
                Divider(text=self._t("translation_section")),
                Selector(
                    key="idioma_alvo",
                    text=self._t("target_language_label"),
                    default=lang_idx,
                    items=labels,
                    icon="menu_feature_translate",
                    link_alias="idioma_alvo",
                    on_change=self._on_change_target_language,
                ),
            ]
            # Campo Custom - visível só quando o usuário escolhe "Custom"
            if lang_idx == (len(labels) - 1):
                items.append(Input(
                    key="idioma_custom_code",
                    text=self._t("custom_lang_label"),
                    default=str(self.get_setting("idioma_custom_code", "")),
                    icon="msg_language",
                    subtext=self._t("custom_lang_subtext"),
                    link_alias="idioma_custom_code",
                    on_change=self._on_change_custom_lang_code,
                ))

            items.extend([
                Divider(text=self._t("ai_provider_label")),
                Selector(
                    key="ai_provider",
                    text=self._t("ai_provider_label"),
                    default=prov_idx,
                    items=["OpenRouter", "Google Gemini", (self._t("ai_provider_custom") or "Custom OpenAI compatible")],
                    icon="msg_bot",
                    link_alias="ai_provider",
                    on_change=self._on_change_ai_provider,
                ),
            ])

            # API Key e ajuda conforme provedor selecionado pelo user
            if prov_idx == 0:
                items.append(Divider(text=self._t("api_key_label")))
                items.extend([
                    Input(
                        key="openrouter_api_key",
                        text=self._t("openrouter_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("openrouter_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="openrouter_api_key",
                        on_change=self._on_change_api_key,
                    ),
                    Text(
                        text=self._t("get_openrouter_api_label") or self._t("get_api_help_label"),
                        icon="menu_link_create2",
                        accent=True,
                        link_alias="get_openrouter_api",
                        on_click=lambda view: self._show_openrouter_api_sheet()
                    ),
                ])
            elif prov_idx == 1:
                items.append(Divider(text=self._t("api_key_label")))
                items.extend([
                    Input(
                        key="gemini_api_key",
                        text=self._t("gemini_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("gemini_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="gemini_api_key",
                        on_change=self._on_change_gemini_api_key,
                    ),
                    Text(
                        text=self._t("get_gemini_api_button") or self._t("get_api_help_label"),
                        icon="menu_link_create2",
                        accent=True,
                        link_alias="get_gemini_api",
                        on_click=lambda view: self._show_gemini_api_sheet()
                    ),
                ])
            else:
                items.append(Divider(text=self._t("api_key_label")))
                items.extend([
                    Input(
                        key="custom_api_url",
                        text=self._t("custom_api_url_label"),
                        default=str(self.get_setting("custom_api_url", "")),
                        icon="msg_link",
                        link_alias="custom_api_url",
                        on_change=self._on_change_custom_api_url,
                    ),
                    Input(
                        key="custom_api_key",
                        text=self._t("custom_api_key_label") or self._t("api_key_label"),
                        default=str(self.get_setting("custom_api_key", "")),
                        icon="menu_feature_reliable",
                        link_alias="custom_api_key",
                        on_change=self._on_change_custom_api_key,
                    ),
                ])

            items.append(Divider(text=self._t("model_creativity_section")))
            if prov_idx == 2:
                items.append(Input(
                    key="custom_model_name",
                    text=self._t("custom_model_label") or self._t("model_label"),
                    default=str(self.get_setting("custom_model_name", "")),
                    icon="menu_edit_price",
                    link_alias="custom_model_name",
                    on_change=self._on_change_custom_model_name,
                ))
            else:
                items.append(Selector(
                    key="modelo_gemini",
                    text=self._t("model_label"),
                    default=modelo_idx,
                    items=modelo_labels,
                    icon="menu_edit_price",
                    link_alias="modelo_gemini",
                    on_change=self._on_change_model,
                ))
            items.extend([
                Selector(
                    key="temperatura_idx",
                    text=self._t("temperature_label"),
                    default=temp_idx,
                    items=temp_labels,
                    icon="media_settings",
                    link_alias="temperatura_idx",
                    on_change=self._on_change_temperature,
                ),
                Divider(),
                Text(
                    text=self._t("using_translatica_label"),
                    icon="msg_info",
                    link_alias="using_translatica",
                    on_click=lambda view: self._show_using_translatica_sheet()
                ),
                Divider(),
                Text(
                    text=self._t("optional_label"),
                    icon="msg_settings",
                    create_sub_fragment=self._create_optional_subfragment,
                    link_alias="optional_subfragment"
                ),
            ])

            # Dotted Plugins e Suporte
            try:
                items.append(Divider())
                # Padrão Apple Plugins
                items.append(Text(
                    text="Dotted Plugins",
                    icon="etg_settings",
                    accent=True,
                    link_alias="dotted_plugins",
                    on_click=lambda view: run_on_ui_thread(lambda: self._open_by_username("exteraDevPlugins"))
                ))
                items.append(Text(
                    text=self._t("support_title"),
                    icon="msg_reactions",
                    accent=True,
                    link_alias="support",
                    on_click=lambda view: self._show_support_sheet()
                ))
            except Exception:
                pass

            return items
        except Exception:
            return []

    # Suporte Get the API
    def _show_support_sheet(self):
        try:
            # API
            from org.telegram.ui.ActionBar import BottomSheet, Theme
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)
            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(self._t("support_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            # Banner
            try:
                WebView = self._find_class_safe("android.webkit.WebView")
                web_view = WebView(ctx)
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                # Permitir acesso a arquivos locais no WebView para carregar imagens em cache
                try:
                    web_view.getSettings().setAllowFileAccess(True)
                    web_view.getSettings().setAllowFileAccessFromFileURLs(True)
                    web_view.getSettings().setAllowUniversalAccessFromFileURLs(True)
                    web_view.getSettings().setLoadsImagesAutomatically(True)
                except Exception:
                    pass
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception:
                    pass
                _ = self._get_cached_image_src("https://i.postimg.cc/ZRsXHX1C/icon-chat.png", "support_banner.png")
                html = """
                <html>
                <head>
                    <style>
                        body { margin: 0; padding: 0; background-color: transparent; }
                        img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                    </style>
                </head>
                <body>
                    <img src='support_banner.png' alt='Support Banner'>
                </body>
                </html>
                """
                base = "file://" + self._get_cache_dir_path() + "/"
                web_view.loadDataWithBaseURL(base, html, "text/html", "UTF-8", None)
                container.addView(web_view, self._layout_helper_create_linear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            # Descrição
            desc_view = TextView(ctx)
            desc_view.setText(self._t("support_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            # Botão
            button_container = FrameLayout(ctx)
            try:
                GradientDrawable = self._find_class_safe("android.graphics.drawable.GradientDrawable")
                button_bg = GradientDrawable()
                button_bg.setCornerRadius(8)
                try:
                    button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                    button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
                except Exception:
                    button_bg.setStroke(2, 0xFF3B78FF)
                    button_bg.setColor(0xFF1F1F1F)
            except Exception:
                button_bg = None

            btn = TextView(ctx)
            btn.setText(self._t("support_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            if button_bg:
                btn.setBackground(button_bg)
            button_container.addView(btn, self._layout_helper_create_frame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_support_user()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, self._layout_helper_create_linear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _open_support_user(self, v=None):
        try:
            # Tenta abrir via MessagesController
            try:
                if self._open_by_username("AGeekApple"):
                    return
            except Exception:
                pass
            # Fallback via Intent
            fragment = self.get_last_fragment_safe()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return
            from android.content import Intent
            from android.net import Uri
            intent = Intent(Intent.ACTION_VIEW)
            intent.setData(Uri.parse("tg://resolve?domain=AGeekApple"))
            ctx.startActivity(intent)
        except Exception as e:
            self._log(f"Erro ao abrir usuário de suporte: {e}")

    # Helper de fragmento
    def get_last_fragment_safe(self):
        try:
            from client_utils import get_last_fragment
            return get_last_fragment()
        except Exception:
            return None

    def get_messages_controller(self):
        try:
            from client_utils import get_messages_controller
            return get_messages_controller()
        except Exception:
            return None

    def _extract_dialog_id(self, params: Any) -> int:
        try:
            # Tenta obter diretamente
            for key in ("dialog_id", "did"):
                try:
                    v = getattr(params, key)
                    if isinstance(v, (int,)) and int(v) != 0:
                        return int(v)
                except Exception:
                    pass
            # Tenta construir a partir de peer (user/chat/channel)
            try:
                peer = getattr(params, "peer")
            except Exception:
                peer = None
            if peer:
                try:
                    uid = getattr(peer, "user_id")
                except Exception:
                    uid = 0
                try:
                    gid = getattr(peer, "chat_id")
                except Exception:
                    gid = 0
                try:
                    cid = getattr(peer, "channel_id")
                except Exception:
                    cid = 0
                # Convenção: usuários positivos; chats/canais negativos
                if isinstance(uid, int) and uid != 0:
                    return int(uid)
                if isinstance(gid, int) and gid != 0:
                    return int(-gid)
                if isinstance(cid, int) and cid != 0:
                    return int(-cid)
                # Fallback para dialog_id interno
                try:
                    dv = getattr(peer, "dialog_id")
                    if isinstance(dv, int) and dv != 0:
                        return int(dv)
                except Exception:
                    pass
            # Fallback: tentar obter do fragmento atual (ChatActivity)
            try:
                fragment = self.get_last_fragment_safe()
                if fragment:
                    for attr in ("dialog_id", "did", "currentDialogId"):
                        try:
                            v = getattr(fragment, attr)
                            if isinstance(v, int) and v != 0:
                                return int(v)
                        except Exception:
                            pass
                    # Tentar método getDialogId()
                    try:
                        v = fragment.getDialogId()
                        if isinstance(v, int) and v != 0:
                            return int(v)
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            pass
        return 0

    def _load_enabled_dialogs(self) -> set:
        try:
            raw = str(self.get_setting("enabled_dialogs", "") or "")
            items = [s for s in raw.split(",") if s.strip()]
            out = set()
            for s in items:
                try:
                    if s and (s.lstrip("-").isdigit()):
                        out.add(int(s))
                except Exception:
                    pass
            return out
        except Exception:
            return set()

    def _save_enabled_dialogs(self, s: set):
        try:
            val = ",".join(str(int(x)) for x in sorted(s))
            self.set_setting("enabled_dialogs", val)
        except Exception:
            pass

    def _load_disabled_dialogs(self) -> set:
        try:
            raw = str(self.get_setting("disabled_dialogs", "") or "")
            items = [s for s in raw.split(",") if s.strip()]
            out = set()
            for s in items:
                try:
                    if s and (s.lstrip("-").isdigit()):
                        out.add(int(s))
                except Exception:
                    pass
            return out
        except Exception:
            return set()

    def _save_disabled_dialogs(self, s: set):
        try:
            val = ",".join(str(int(x)) for x in sorted(s))
            self.set_setting("disabled_dialogs", val)
        except Exception:
            pass

    def _load_chat_lang_overrides(self) -> dict:
        out = {}
        try:
            raw = str(self.get_setting("chat_lang_overrides", "") or "")
            pairs = [p for p in raw.split(";") if p.strip()]
            for p in pairs:
                try:
                    did_str, lang = p.split("=", 1)
                    did_str = did_str.strip()
                    lang = lang.strip()
                    if did_str and (did_str.lstrip("-").isdigit()) and lang:
                        out[int(did_str)] = lang
                except Exception:
                    pass
        except Exception:
            pass
        return out

    def _save_chat_lang_overrides(self, d: dict):
        try:
            val = ";".join(f"{int(k)}={str(v)}" for k, v in d.items())
            self.set_setting("chat_lang_overrides", val)
        except Exception:
            pass

    def _get_current_user_name(self) -> str:
        try:
            try:
                from org.telegram.messenger import UserConfig, ContactsController, MessagesController
                account = getattr(UserConfig, 'selectedAccount', 0)
                mc = MessagesController.getInstance(account)
                me = UserConfig.getInstance(account)
                user = mc.getUser(me.getClientUserId()) if mc and me else None
                if user:
                    try:
                        return ContactsController.formatName(user.first_name, user.last_name).replace('\n', ' ')
                    except Exception:
                        pass
            except Exception:
                pass
            return "Você"
        except Exception:
            return "Você"

    def _open_by_username(self, username: str) -> bool:
        try:
            mc = self.get_messages_controller()
            if mc is None:
                return False
            fragment = self.get_last_fragment_safe()
            mc.openByUserName(str(username), fragment, 1)
            return True
        except Exception:
            return False

    def _open_by_username(self, username: str) -> bool:
        try:
            mc = self.get_messages_controller()
            if mc is None:
                return False
            fragment = self.get_last_fragment_safe()
            mc.openByUserName(str(username), fragment, 1)
            return True
        except Exception:
            return False

    #  Handlers de on_change (sem retornar valores)
    def _on_change_target_language(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        if i < 0 or i >= 5:
            i = 0
        self.set_setting("idioma_alvo", i)
        run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("target_language_label")))
        # Recarrega para refletir visibilidade do campo Custom
        self.reload_settings()

    def _on_change_custom_lang_code(self, v):
        try:
            self.set_setting("idioma_custom_code", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_lang_label")))
        except Exception:
            pass

    def _on_change_api_key(self, v):
        try:
            self.set_setting("openrouter_api_key", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_gemini_api_key(self, v):
        try:
            self.set_setting("gemini_api_key", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("gemini_api_key_label") or self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_openrouter_api_key(self, v):
        try:
            self.set_setting("openrouter_api_key", str(v).strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("openrouter_api_key_label")))
        except Exception:
            pass

    def _on_change_model(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        prov_idx = self._get_ai_provider_idx()
        modelos = self._opcoes_modelos() if prov_idx == 0 else self._opcoes_modelos_gemini()
        if i < 0 or i >= len(modelos):
            i = 0
        # Salvamos apenas o índice; resolução para slug ocorre dinamicamente
        self.set_setting("modelo_gemini", i)
        run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("model_label")))

    def _on_change_ai_provider(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        if i < 0 or i > 2:
            i = 0
        self.set_setting("ai_provider", i)
        # Recarrega para atualizar campos dependentes (API key, lista de modelos, ajuda)
        run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("ai_provider_label")))
        self.reload_settings()

    def _on_change_temperature(self, v):
        try:
            # Aceita índice do selector ou valor direto (compatibilidade)
            temp_values = [0.0, 0.2, 0.4, 0.7, 1.0]
            try:
                idx = int(v)
                if idx < 0 or idx >= len(temp_values):
                    idx = 1
                val = temp_values[idx]
            except Exception:
                try:
                    val = float(str(v))
                except Exception:
                    val = 0.2
                # Deriva índice do valor recebido para manter consistência
                try:
                    idx = temp_values.index(val)
                except Exception:
                    try:
                        idx = min(range(len(temp_values)), key=lambda i: abs(temp_values[i] - val))
                    except Exception:
                        idx = 1
            # Salva valor e índice para estabilidade do componente
            self.set_setting("temperatura", val)
            self.set_setting("temperatura_idx", idx)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("temperature_label")))
        except Exception:
            pass

    def _on_change_custom_api_url(self, v):
        try:
            s = str(v or "").strip()
            # Remove barras duplicadas no final, preservando uma única se existir
            try:
                while s.endswith("//"):
                    s = s[:-1]
            except Exception:
                pass
            self.set_setting("custom_api_url", s)
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_api_url_label")))
        except Exception:
            pass

    def _on_change_custom_api_key(self, v):
        try:
            self.set_setting("custom_api_key", str(v or "").strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_api_key_label") or self._t("api_key_label")))
        except Exception:
            pass

    def _on_change_custom_model_name(self, v):
        try:
            self.set_setting("custom_model_name", str(v or "").strip())
            run_on_ui_thread(lambda: BulletinHelper.show_success(self._t("custom_model_label") or self._t("model_label")))
        except Exception:
            pass

    def _on_change_quick_dismiss(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            # Salva como booleano (sempre visível; só estado muda)
            self.set_setting("quick_dismiss_enabled", v_bool)
            run_on_ui_thread(lambda: BulletinHelper.show_info("Quick Dismiss"))
        except Exception:
            pass

    def _on_change_fast_mode(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("fast_mode_enabled", v_bool)
            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("fast_mode_label")))
        except Exception:
            pass

    def _on_change_aura(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("aura_enabled", v_bool)
            # Feedback visual simples
            run_on_ui_thread(lambda: BulletinHelper.show_info("Aura"))
        except Exception:
            pass

    def _on_change_always_correct(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("always_correct_enabled", v_bool)
            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("always_correct_label")))
        except Exception:
            pass

    def _on_change_logs_disabled(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            # Salva como booleano (sempre visível > só estado muda)
            self.set_setting("logs_disabled", v_bool)
            self._set_log_muted(v_bool)
            run_on_ui_thread(lambda: BulletinHelper.show_info(self._t("logs_disable_label")))
        except Exception:
            pass

    def _on_change_plugin_language(self, idx):
        try:
            i = int(idx)
        except Exception:
            i = 0
        if i < 0 or i >= 4:
            i = 0
        self.set_setting("plugin_lang", i)
        self.reload_settings()

    # Estado on/off
    def _is_enabled(self) -> bool:
        try:
            return bool(int(self.get_setting("plugin_enabled", 1)))
        except Exception:
            return True

    def _toggle_enabled(self) -> bool:
        try:
            cur = 1 if self._is_enabled() else 0
            new = 0 if cur == 1 else 1
            self.set_setting("plugin_enabled", new)
            # Feedback visual
            msg = self._t("plugin_enabled_msg") if new == 1 else self._t("plugin_disabled_msg")
            if new == 1:
                run_on_ui_thread(lambda: BulletinHelper.show_success(msg))
            else:
                run_on_ui_thread(lambda: BulletinHelper.show_info(msg))
            return bool(new)
        except Exception:
            return self._is_enabled()

    # Toggle no menu do chat (3-dot)
    def _add_chat_toggle_menu_item(self):
        try:
            # Evita duplicatas removendo anterior
            if getattr(self, "_chat_toggle_item_id", None):
                try:
                    self.remove_menu_item(self._chat_toggle_item_id)
                except Exception:
                    pass
                self._chat_toggle_item_id = None

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text="Translatica",
                icon="msg_translate",
                priority=5,
                on_click=lambda ctx: self._handle_chat_toggle_click(ctx)
            ))
            self._chat_toggle_item_id = item_id
        except Exception:
            pass

    def _remove_chat_toggle_menu_item(self):
        try:
            if getattr(self, "_chat_toggle_item_id", None):
                try:
                    self.remove_menu_item(self._chat_toggle_item_id)
                except Exception:
                    pass
                self._chat_toggle_item_id = None
        except Exception:
            pass

    def _ensure_chat_toggle_menu_item(self):
        try:
            self._add_chat_toggle_menu_item()
        except Exception:
            pass

    def _handle_chat_toggle_click(self, ctx: Any = None):
        try:
            enabled = self._toggle_enabled()
            # Opcionalmente atualizar o texto do item conforme estado
            try:
                # Remove e adiciona novamente para refletir mudanças, mantendo simples
                self._add_chat_toggle_menu_item()
            except Exception:
                pass
        except Exception:
            pass
    # Subfragmento: Opções avançadas
    def _create_optional_subfragment(self, parent_view=None):
        try:
            # Importa classes de UI de settings
            try:
                from ui.settings import Divider, Switch, Selector, Input, Text
            except Exception:
                # Fallback: objetos já resolvidos pelo host
                pass
            try:
                self._log("Abrindo subfragment: Opções avançadas")
            except Exception:
                pass
            # Contexto do fragmento atual
            try:
                fragment = get_last_fragment()
                mc = get_messages_controller()
            except Exception:
                fragment = None
                mc = None
            items = []
            # Categoria: Comportamento de tradução
            try:
                items.append(Divider(text=self._t("advanced_cat_behavior")))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="fast_mode_enabled",
                    text=self._t("fast_mode_label"),
                    subtext=self._t("fast_mode_subtext"),
                    default=self._get_bool_setting("fast_mode_enabled", False),
                    icon="flash_on_remix",
                    link_alias="fast_mode_enabled",
                    on_change=self._on_change_fast_mode,
                ))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="always_correct_enabled",
                    text=self._t("always_correct_label"),
                    subtext=self._t("always_correct_subtext"),
                    default=self._get_bool_setting("always_correct_enabled", False),
                    icon="ai_chat_solar",
                    link_alias="always_correct_enabled",
                    on_change=self._on_change_always_correct,
                ))
            except Exception:
                pass
            # Categoria: Opcional (comportamentos não essenciais)
            try:
                items.append(Divider(text=self._t("advanced_cat_optional")))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="quick_dismiss_enabled",
                    text="Quick Dismiss",
                    subtext=self._t("quick_dismiss_subtext"),
                    default=self._get_bool_setting("quick_dismiss_enabled", False),
                    icon="msg_autodelete_badge2",
                    link_alias="quick_dismiss_enabled",
                    on_change=self._on_change_quick_dismiss,
                ))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="aura_enabled",
                    text="Aura",
                    subtext=self._t("aura_subtext"),
                    default=self._get_bool_setting("aura_enabled", False),
                    icon="msg_photo_curve",
                    link_alias="aura_enabled",
                    on_change=self._on_change_aura,
                ))
            except Exception:
                pass
            # Categoria: Prompt
            try:
                items.append(Divider(text=self._t("advanced_cat_prompt")))
            except Exception:
                pass
            try:
                raw = self.get_setting("prompt_mode", 0)
                try:
                    mode_idx = int(raw)
                except Exception:
                    try:
                        mode_idx = 0 if str(raw).lower() != "extra" else 1
                    except Exception:
                        mode_idx = 0
                items.append(Selector(
                    key="prompt_mode",
                    text=self._t("prompt_selector_label"),
                    default=mode_idx,
                    items=[self._t("prompt_mode_base"), self._t("prompt_mode_extra")],
                    icon="input_bot1",
                    link_alias="prompt_mode",
                    on_change=self._on_change_prompt_mode,
                ))
            except Exception:
                pass
            # Campo de complemento exibido quando o modo for Complement (índice 1)
            try:
                if int(mode_idx) == 1:
                    items.append(Input(
                        key="prompt_extra_text",
                        text=self._t("prompt_extra_input_label"),
                        default=str(self.get_setting("prompt_extra_text", "") or ""),
                        icon="msg_arrowright",
                        link_alias="prompt_extra_text",
                        on_change=self._on_change_prompt_extra_text,
                    ))
            except Exception:
                pass
            # Categoria: Idioma do plugin
            try:
                items.append(Divider(text=self._t("advanced_cat_language")))
            except Exception:
                pass
            try:
                plugin_lang_idx = self._get_plugin_lang_index()
                items.append(Selector(
                    key="plugin_lang",
                    text=self._t("plugin_language_label"),
                    default=plugin_lang_idx,
                    items=[
                        self._t("lang_english"),
                        self._t("lang_portuguese"),
                        self._t("lang_spanish"),
                        self._t("lang_russian"),
                    ],
                    icon="msg_language",
                    link_alias="plugin_language",
                    on_change=self._on_change_plugin_language,
                ))
            except Exception:
                pass
            # Categoria: Registros (última opção)
            try:
                items.append(Divider(text=self._t("advanced_cat_logging")))
            except Exception:
                pass
            try:
                items.append(Switch(
                    key="logs_disabled",
                    text=self._t("logs_disable_label"),
                    default=self._get_bool_setting("logs_disabled", False),
                    icon="msg_log",
                    link_alias="logs_disabled",
                    on_change=self._on_change_logs_disabled,
                ))
            except Exception:
                pass
            try:
                self._log(f"Opções avançadas: itens={len(items)}")
            except Exception:
                pass
            return items
        except Exception as e:
            return [Text(text=f"Erro: {e}")]

    # Handlers de Opções avançadas
    def _on_change_prompt_mode(self, idx):
        try:
            try:
                i = int(idx)
            except Exception:
                # Compatibilidade: se vier string "base"/"extra", mapeia para índice
                try:
                    s = str(idx).lower()
                    i = 0 if s != "extra" else 1
                except Exception:
                    i = 0
            # Persistir como índice numérico para evitar mismatch com o Selector
            self.set_setting("prompt_mode", int(i))
            # Atualizar UI para refletir visibilidade do campo de complemento
            try:
                self.reload_settings()
            except Exception:
                pass
        except Exception:
            pass

    def _on_change_prompt_extra_enabled(self, v):
        try:
            try:
                v_bool = bool(v) if isinstance(v, bool) else bool(int(v))
            except Exception:
                v_bool = False
            self.set_setting("prompt_extra_enabled", v_bool)
        except Exception:
            pass
    def _on_change_prompt_extra_text(self, v):
        try:
            self.set_setting("prompt_extra_text", str(v))
        except Exception:
            pass
