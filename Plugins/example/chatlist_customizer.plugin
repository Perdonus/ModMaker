from datetime import datetime
from java.util import Locale
from java.util import Calendar, TimeZone
from base_plugin import BasePlugin, MenuItemData, MenuItemType
from ui.settings import Header, Divider, Input, Switch, Text, Selector
from client_utils import get_last_fragment, get_messages_controller, send_request
from android_utils import run_on_ui_thread, log
from android_utils import OnClickListener
from org.telegram.messenger import LocaleController, R, AndroidUtilities
from org.telegram.ui.ActionBar import BottomSheet, Theme, SimpleTextView
from org.telegram.ui.Components import LayoutHelper
from android.view import Gravity
from android.widget import FrameLayout, TextView
from android.util import TypedValue
from hook_utils import find_class
from com.exteragram.messenger.plugins import PluginsController
from com.exteragram.messenger.plugins.ui import PluginSettingsActivity
from ui.bulletin import BulletinHelper
from client_utils import get_last_fragment
from org.telegram.messenger import R as R_tg
import requests
import time
import random


__id__ = "chatlist_customizer"
__name__ = "ChatList Customizer"
__description__ = (
    "Enhances your Chat List with dynamic time-based greetings, customizable titles, live Now Playing integration, and smart messages that adapt to the time of day. Also lets you follow local weather conditions in real time. Fully supports stats.fm and Last.fm for instant music updates.\n\nРасширяет список чатов динамическими приветствиями по времени суток, настраиваемыми заголовками, функцией «Сейчас играет» и умными сообщениями, которые адаптируются к времени дня. Позволяет также отслеживать местные погодные условия в реальном времени. Полная поддержка stats.fm и Last.fm для мгновенных музыкальных обновлений."
)
__author__ = "@AGeekApple"
__version__ = "1.0.3"
__min_version__ = "11.12.1"
__icon__ = "ApplePlugins/18"
__priority__ = 0

# Sistema de desativação de logs
_CHATLIST_LOGS_MUTED = False

def _set_log_muted(muted):
    global _CHATLIST_LOGS_MUTED
    _CHATLIST_LOGS_MUTED = muted

def _log_wrapper(original_log):
    def wrapper(*args, **kwargs):
        if not _CHATLIST_LOGS_MUTED:
            return original_log(*args, **kwargs)
    return wrapper

def _apply_log_wrapper():
    global log
    log = _log_wrapper(log)

# Aplicar wrapper de log
_apply_log_wrapper()

# Internal Smart Messages (sem fetch)
INTERNAL_SMART_MESSAGES = {
    "pt": {
        "morning": [
            "Bom dia",
            "Café pronto",
            "Começar bem",
            "Sol nascendo",
            "Dia novo",
            "Acordar leve",
            "Energia matinal",
            "Sorria hoje",
            "Manhã produtiva",
            "Respire fundo",
            "Primeiros raios",
            "Luz do dia",
            "Céu claro",
            "Bom despertar",
            "Amanhecer"
        ],
        "afternoon": [
            "Boa tarde",
            "Siga firme",
            "Foco total",
            "Energia alta",
            "Hora do almoço",
            "Dias corridos",
            "Continue forte",
            "Trabalho fluindo",
            "Aproveite o dia",
            "Meio do dia",
            "Sol brilhando",
            "Pausa rápida",
            "Momento de ação",
            "Metas em vista",
            "Atenção plena",
            "Almoço saboroso",
            "Pausa merecida",
            "Recarregar energias",
            "Momento de nutrir",
            "Saboreie o almoço",
            "Tempo de descanso",
            "Produtividade em alta",
            "Foco renovado",
            "Tarde inspiradora",
            "Conquiste seus objetivos"
        ],
        "evening": [
            "Boa noite",
            "Modo relax",
            "Luz suave",
            "Descanse bem",
            "Fim de tarde",
            "Paz e calma",
            "Hora do chá",
            "Relaxar agora",
            "Sol se pondo",
            "Fim do expediente",
            "Momento tranquilo",
            "Brisa leve",
            "Tarde serena",
            "Sons suaves",
            "Vibe calma"
        ],
        "night": [
            "Boa madrugada",
            "Silêncio",
            "Horário calmo",
            "Noite longa",
            "Lua alta",
            "Estrelas brilhando",
            "Hora de dormir",
            "Descanso profundo",
            "Tranquilidade",
            "Som da noite",
            "Pensamentos leves",
            "Sono reparador",
            "Noite tranquila",
            "Momento sereno",
            "Calmaria"
        ]
    },
    "en": {
        "morning": [
            "Good morning",
            "Coffee ready",
            "Start strong",
            "Sun rising",
            "New day",
            "Wake up light",
            "Morning energy",
            "Smile today",
            "Productive morning",
            "Breathe deeply",
            "First rays",
            "Daylight",
            "Clear sky",
            "Good awakening",
            "Dawn"
        ],
        "afternoon": [
            "Good afternoon",
            "Keep going",
            "Stay focused",
            "High energy",
            "Lunch time",
            "Busy day",
            "Stay strong",
            "Work flowing",
            "Enjoy your day",
            "Midday",
            "Sun shining",
            "Quick break",
            "Action time",
            "Goals in sight",
            "Mindful moments",
            "Delicious lunch",
            "Well-deserved break",
            "Recharge time",
            "Nourish yourself",
            "Savor your lunch",
            "Midday pause",
            "Peak productivity",
            "Renewed focus",
            "Inspiring afternoon",
            "Achieve your goals"
        ],
        "evening": [
            "Good evening",
            "Time to rest",
            "Soft lights",
            "Unwind now",
            "Late afternoon",
            "Peaceful moments",
            "Tea time",
            "Relax now",
            "Sunset",
            "End of workday",
            "Quiet moments",
            "Gentle breeze",
            "Serene evening",
            "Soft sounds",
            "Calm vibes"
        ],
        "night": [
            "Late night",
            "Quiet time",
            "Calm hours",
            "Long night",
            "Moon high",
            "Stars shining",
            "Bedtime",
            "Deep rest",
            "Tranquility",
            "Night sounds",
            "Light thoughts",
            "Restful sleep",
            "Peaceful night",
            "Serene moments",
            "Stillness"
        ]
    },
    "ru": {
        "morning": [
            "Доброе утро",
            "Кофе готов",
            "Начни день",
            "Солнце встало",
            "Новый день",
            "Легкое пробуждение",
            "Утренняя энергия",
            "Улыбнись сегодня",
            "Продуктивное утро",
            "Глубокий вдох",
            "Первые лучи",
            "Дневной свет",
            "Чистое небо",
            "Доброе пробуждение",
            "Рассвет"
        ],
        "afternoon": [
            "Добрый день",
            "Держись курса",
            "Больше фокуса",
            "Энергия выше",
            "Время обеда",
            "Загруженный день",
            "Оставайся сильным",
            "Работа идет",
            "Наслаждайся днем",
            "Полдень",
            "Солнце светит",
            "Короткий перерыв",
            "Время действий",
            "Цели на виду",
            "Полная концентрация",
            "Вкусный обед",
            "Заслуженный отдых",
            "Время восстановления",
            "Питай себя",
            "Наслаждайся обедом",
            "Полуденная пауза",
            "Пик продуктивности",
            "Обновленный фокус",
            "Вдохновляющий день",
            "Достигай целей"
        ],
        "evening": [
            "Добрый вечер",
            "Пора отдыхать",
            "Мягкий свет",
            "Расслабься",
            "Поздний вечер",
            "Мир и спокойствие",
            "Чайное время",
            "Отдохни сейчас",
            "Закат",
            "Конец рабочего дня",
            "Тихие моменты",
            "Легкий ветерок",
            "Спокойный вечер",
            "Мягкие звуки",
            "Успокаивающая атмосфера"
        ],
        "night": [
            "Поздняя ночь",
            "Тишина",
            "Спокойные часы",
            "Долгая ночь",
            "Луна в зените",
            "Светят звезды",
            "Время сна",
            "Глубокий отдых",
            "Спокойствие",
            "Звуки ночи",
            "Легкие мысли",
            "Восстанавливающий сон",
            "Тихая ночь",
            "Спокойные моменты",
            "Покой"
        ]
    }
}

# Dicionário de traduções simplificado
TRANSLATIONS = {
    # Novas traduções para o seletor de idioma e Keep Cover
    "language_section": {
        "en": "Language Settings",
        "pt": "Configurações de Idioma",
        "ru": "Настройки языка"
    },
    "plugin_language_label": {
        "en": "Plugin Language",
        "pt": "Idioma do Plugin",
        "ru": "Язык плагина"
    },
    "keep_cover_label": {
        "en": "Keep Cover",
        "pt": "Manter Capa",
        "ru": "Сохранить обложку"
    },
    "keep_cover_desc": {
        "en": "Keep the last cover displayed when no music is playing",
        "pt": "Mantém a última capa exibida quando não há música tocando",
        "ru": "Сохраняет последнюю обложку, когда музыка не воспроизводится"
    },
    "close_button": {
        "en": "Close",
        "pt": "Fechar",
        "ru": "Закрыть"
    },
    "chatlist_customizer": {
        "pt": "ChatList Customizer",
        "en": "ChatList Customizer", 
        "ru": "ChatList Customizer"
    },
    "welcome_message": {
        "pt": "Personalize o título da sua Chat List com saudações dinâmicas e texto customizado.",
        "en": "Customize your Chat List title with dynamic greetings and custom text.",
        "ru": "Настройте заголовок списка чатов с динамическими приветствиями и пользовательским текстом."
    },
    "enable_greeting": {
        "pt": "Ativar Saudação",
        "en": "Enable Greeting",
        "ru": "Включить приветствие"
    },
    "enable_greeting_desc": {
        "pt": "Ativa saudações dinâmicas baseadas no horário (manhã, tarde, noite)",
        "en": "Enable dynamic greetings based on time of day (morning, afternoon, evening)",
        "ru": "Включить динамические приветствия в зависимости от времени суток (утро, день, вечер)"
    },
    # Smart Messages — novo selector
    "smart_messages_label": {
        "pt": "Mensagens Inteligentes",
        "en": "Smart Messages",
        "ru": "Умные сообщения"
    },
    "smart_messages_activate": {
        "pt": "Desativado",
        "en": "Deactivated",
        "ru": "Деактивировано"
    },
    "smart_messages_deactivate": {
        "pt": "Ativado",
        "en": "Activated",
        "ru": "Включено"
    },

    # Smart Weather — selector e subfragmento
    "smart_weather_label": {
        "pt": "Clima Dinâmico",
        "en": "Smart Weather",
        "ru": "Умная погода"
    },
    "smart_weather_activate": {
        "pt": "Desativado",
        "en": "Deactivated",
        "ru": "Деактивировано"
    },
    "smart_weather_deactivate": {
        "pt": "Ativado",
        "en": "Activated",
        "ru": "Включено"
    },
    "weather_options_link": {
        "pt": "Opções de Clima",
        "en": "Weather Options",
        "ru": "Параметры погоды"
    },
    "weather_options_header": {
        "pt": "Opções de Clima",
        "en": "Weather Options",
        "ru": "Параметры погоды"
    },
    "weather_divider_options": {
        "pt": "Opções",
        "en": "Options",
        "ru": "Опции"
    },
    "weather_divider_details": {
        "pt": "Detalhes do Clima",
        "en": "Weather Details",
        "ru": "Детали погоды"
    },
    "weather_city_label": {
        "pt": "Cidade",
        "en": "City",
        "ru": "Город"
    },
    "weather_api_key_label": {
        "pt": "Chave de API",
        "en": "API Key",
        "ru": "API-ключ"
    },
    # Ajuda (How to Use) e botão Get the API
    "motion_theme_rainy_night": {
        "pt": "Rainy Night",
        "en": "Rainy Night",
        "ru": "Rainy Night"
    },
    "motion_theme_flowing": {
        "pt": "Flowing",
        "en": "Flowing",
        "ru": "Flowing"
    },  
    "motion_theme_burst": {
        "pt": "Burst",
        "en": "Burst",
        "ru": "Burst"
    },  
    "motion_theme_motion": {
        "pt": "Motion",
        "en": "Motion",
        "ru": "Motion"
    },   
    "motion_theme_lofi": {
        "pt": "Lofi Chill Sreet",
        "en": "Lofi Chill Sreet",
        "ru": "Lofi Chill Sreet"
    },    
    "howto_title": {
        "pt": "Obter a API",
        "en": "Get the API",
        "ru": "Получить API"
    },
    "howto_description": {
        "pt": "A chave é necessária para se conectar ao WeatherAPI, o serviço que fornece dados de clima em tempo real, previsões, histórico e informações sobre a qualidade do ar em qualquer lugar do mundo.\n",
        "en": "The key is required to connect to WeatherAPI, the service that provides real-time weather data, forecasts, history, and air quality information for any location in the world.\n",
        "ru": "Ключ необходим для подключения к WeatherAPI, сервису, который предоставляет данные о погоде в реальном времени, прогнозы, историю и информацию о качестве воздуха в любой точке мира.\n"
    },
    "get_api_button": {
        "pt": "Obter a API",
        "en": "Get the API",
        "ru": "Получить API"
    },
    "weather_units_label": {
        "pt": "Unidade de Temperatura",
        "en": "Temperature Unit",
        "ru": "Единица температуры"
    },
    "weather_units_celsius": {
        "pt": "Celsius (°C)",
        "en": "Celsius (°C)",
        "ru": "Цельсий (°C)"
    },
    "weather_units_fahrenheit": {
        "pt": "Fahrenheit (°F)",
        "en": "Fahrenheit (°F)",
        "ru": "Фаренгейт (°F)"
    },
    "weather_show_condition": {
        "pt": "Condição",
        "en": "Condition",
        "ru": "Состояние"
    },
    "weather_show_condition_subtext": {
        "pt": "Exibe a condição climática atual (ensolarado, nublado, etc.)",
        "en": "Shows current weather condition (sunny, cloudy, etc.)",
        "ru": "Показывает текущее состояние погоды (солнечно, облачно и т.д.)"
    },
    "weather_show_wind": {
        "pt": "Vento",
        "en": "Wind",
        "ru": "Ветер"
    },
    "weather_show_wind_subtext": {
        "pt": "Mostra velocidade e direção do vento",
        "en": "Shows wind speed and direction",
        "ru": "Показывает скорость и направление ветра"
    },
    "weather_show_humidity": {
        "pt": "Umidade",
        "en": "Humidity",
        "ru": "Влажность"
    },
    "weather_show_humidity_subtext": {
        "pt": "Exibe o percentual de umidade do ar",
        "en": "Shows air humidity percentage",
        "ru": "Показывает процент влажности воздуха"
    },
    "weather_show_feelslike": {
        "pt": "Sensação",
        "en": "Feels like",
        "ru": "Ощущается как"
    },
    "weather_show_feelslike_subtext": {
        "pt": "Mostra a temperatura que realmente se sente",
        "en": "Shows the temperature it actually feels like",
        "ru": "Показывает температуру, которая ощущается на самом деле"
    },
    # Novo: suporte opcional a emojis no Smart Weather
    "weather_enable_emojis": {
        "pt": "Ativar Emojis",
        "en": "Enable Emojis",
        "ru": "Включить эмодзи"
    },
    "weather_enable_emojis_subtext": {
        "pt": "Adiciona emojis conforme a condição climática",
        "en": "Adds emojis based on weather condition",
        "ru": "Добавляет эмодзи в зависимости от погодных условий"
    },
    # Novo: seletor de idioma para Weather API
    "weather_language_label": {
        "pt": "Idioma",
        "en": "Language",
        "ru": "Язык"
    },
    "weather_language_subtext": {
        "pt": "Idioma dos dados climáticos exibidos",
        "en": "Language of displayed weather data",
        "ru": "Язык отображаемых погодных данных"
    },
    "weather_language_english": {
        "pt": "Inglês",
        "en": "English",
        "ru": "Английский"
    },
    "weather_language_portuguese": {
        "pt": "Português",
        "en": "Portuguese",
        "ru": "Португальский"
    },
    "weather_language_russian": {
        "pt": "Russo",
        "en": "Russian",
        "ru": "Русский"
    },
    # Novo: divider para configurações de idioma e emojis
    "weather_display_section": {
        "pt": "Exibição",
        "en": "Display",
        "ru": "Отображение"
    },
    "weather_condition_prefix": {
        "pt": "Condition:",
        "en": "Condition:",
        "ru": "Состояние:"
    },
    "weather_wind_prefix": {
        "pt": "Wind:",
        "en": "Wind:",
        "ru": "Ветер:"
    },
    "weather_humidity_prefix": {
        "pt": "Humidity:",
        "en": "Humidity:",
        "ru": "Влажность:"
    },
    "weather_feels_prefix": {
        "pt": "Feels Like:",
        "en": "Feels Like:",
        "ru": "Ощущается:"
    },
    "weather_missing_config": {
        "pt": "Defina cidade e API Key para ativar.",
        "en": "Set city and API Key to enable.",
        "ru": "Укажите город и API-ключ для включения."
    },
    "display_name_option": {
        "pt": "Título Exibido",
        "en": "Display Title",
        "ru": "Отображаемый заголовок"
    },
    "name_option_none": {
        "pt": "Nenhum",
        "en": "None",
        "ru": "Нет"
    },
    "name_option_my_name": {
        "pt": "Nome",
        "en": "First Name",
        "ru": "Имя"
    },
    "name_option_my_username": {
        "pt": "Nome de usuário",
        "en": "Username",
        "ru": "Имя пользователя"
    },
    "name_option_custom": {
        "pt": "Personalizado",
        "en": "Custom",
        "ru": "Пользовательский"
    },
    "custom_name_input": {
        "pt": "Nome Personalizado",
        "en": "Custom Name",
        "ru": "Пользовательское имя"
    },
    "custom_name_desc": {
        "pt": "Digite o nome que deseja exibir na saudação",
        "en": "Enter the name you want to display in the greeting",
        "ru": "Введите имя, которое хотите отображать в приветствии"
    },
    # Novas traduções para Advanced Options
    "show_chat_menu_title": {
        "pt": "Mostrar no menu do chat",
        "en": "Show in chat menu",
        "ru": "Показывать в меню чата"
    },
    "show_chat_menu_subtext": {
        "pt": "Adiciona 'ChatList Customizer' em Plugins no menu do chat",
        "en": "Adds 'ChatList Customizer' to the chat Plugins menu",
        "ru": "Добавляет 'ChatList Customizer' в Plugins в меню чата"
    },
    "show_side_menu_title": {
        "pt": "Mostrar no menu lateral",
        "en": "Show in side menu",
        "ru": "Показывать в боковом меню"
    },
    "show_side_menu_subtext": {
        "pt": "Adiciona um atalho do ChatList Customizer no menu lateral",
        "en": "Adds a ChatList Customizer shortcut to the side menu",
        "ru": "Добавляет ярлык ChatList Customizer в боковое меню"
    },
    "disable_logs_title": {
        "pt": "Desativar logs",
        "en": "Disable logs",
        "ru": "Отключить логи"
    },
    "disable_logs_subtext": {
        "pt": "Desativa completamente todos os logs do ChatList Customizer",
        "en": "Completely disables all ChatList Customizer logs",
        "ru": "Полностью отключает все логи ChatList Customizer"
    },
    "advanced_options_section": {
        "pt": "Opções Avançadas",
        "en": "Advanced Options",
        "ru": "Дополнительные параметры"
    },
    "interface_integration_section": {
        "pt": "Integração de Interface",
        "en": "Interface Integration",
        "ru": "Интеграция интерфейса"
    },
    "system_section": {
        "pt": "Sistema",
        "en": "System",
        "ru": "Система"
    },
    "fix_title": {
        "pt": "Fixar Título",
        "en": "Fix Title",
        "ru": "Зафиксировать заголовок"
    },
    "fix_title_desc": {
        "pt": "Tenta manter o título personalizado visível",
        "en": "Tries to keep the custom title visible",
        "ru": "Пытается удерживать пользовательский заголовок видимым"
    },
    
    # Dialog de restart
    "restart_required_title": {
        "pt": "Reinicialização Necessária",
        "en": "Restart Required",
        "ru": "Требуется перезапуск"
    },
    "restart_required_message": {
        "pt": "Reiniciar ajuda a aplicar as alterações.",
        "en": "Restarting helps apply changes.",
        "ru": "Перезапуск помогает применить изменения."
    },
    "restart_button": {
        "pt": "Reiniciar",
        "en": "Restart",
        "ru": "Перезапустить"
    },
    "cancel_button": {
        "pt": "Cancelar",
        "en": "Cancel",
        "ru": "Отмена"
    },
    
    # Seções da interface
    "greeting_settings_section": {
        "pt": "Configurações de Saudação",
        "en": "Greeting Settings",
        "ru": "Настройки приветствия"
    },
    "display_settings_section": {
        "pt": "Configurações de Exibição",
        "en": "Display Settings",
        "ru": "Настройки отображения"
    },
    "motion_themes_label": {
        "pt": "Motion",
        "en": "Motion",
        "ru": "Motion"
    },
     "motion_themes_styles": {
        "pt": "Estilos do Motion",
        "en": "Motion Styles",
        "ru": "Стили Motion"
    },   
    "motion_theme_sl_jinwoo": {
        "pt": "SL Jinwoo",
        "en": "SL Jinwoo",
        "ru": "SL Jinwoo"
    },
    "motion_theme_dbs_goku": {
        "pt": "DBS Goku",
        "en": "DBS Goku",
        "ru": "DBS Goku"
    },
    "motion_theme_hxh_killua": {
        "pt": "HxH Killua",
        "en": "HxH Killua",
        "ru": "HxH Killua"
    },
    "motion_theme_custom": {
        "pt": "Personalizado",
        "en": "Custom",
        "ru": "Пользовательский"
    },
    "motion_theme_custom_url": {
        "pt": "Link da imagem/GIF",
        "en": "Image/GIF link",
        "ru": "Ссылка на изображение/GIF"
    },
    "advanced_settings_section": {
        "pt": "Extra",
        "en": "Extra",
        "ru": "Дополнительно"
    },
    # Fuso horário e aparência
    "time_settings_section": {
        "pt": "Configurações de Fuso Horário",
        "en": "Time Zone Settings",
        "ru": "Настройки часового пояса"
    },
    "timezone_label": {
        "pt": "Fuso Horário",
        "en": "Time Zone",
        "ru": "Часовой пояс"
    },
    "timezone_system": {
        "pt": "Sistema",
        "en": "System Default",
        "ru": "Системный"
    },
    "timezone_utc": {
        "pt": "UTC",
        "en": "UTC",
        "ru": "UTC"
    },
    "timezone_moscow": {
        "pt": "Europa/Moscou (UTC+3)",
        "en": "Europe/Moscow (UTC+3)",
        "ru": "Европа/Москва (UTC+3)"
    },
    "timezone_sao_paulo": {
        "pt": "América/São Paulo (UTC-3)",
        "en": "America/São Paulo (UTC-3)",
        "ru": "Америка/Сан-Паулу (UTC-3)"
    },
    "timezone_custom_offset": {
        "pt": "Fuso Personalizado",
        "en": "Custom Offset",
        "ru": "Пользовательский часовой сдвиг"
    },
    "timezone_offset_label": {
        "pt": "Fuso (horas)",
        "en": "Offset (hours)",
        "ru": "Смещение (часы)"
    },
    "timezone_offset_desc": {
        "pt": "Selecione o fuso horário UTC (ex.: +3 para Moscou)",
        "en": "Select UTC offset (e.g., +3 for Moscow)",
        "ru": "Выберите смещение UTC (например, +3 для Москвы)"
    },
    
    # Títulos e seções avançadas
    "advanced_settings_link": {
        "pt": "Opções avançadas",
        "en": "Advanced options",
        "ru": "Расширенные параметры"
    },
    "appearance_section": {
        "pt": "Aparência",
        "en": "Appearance",
        "ru": "Внешний вид"
    },
    "behavior_section": {
        "pt": "Comportamento",
        "en": "Behavior",
        "ru": "Поведение"
    },
    "now_playing_filter_titles_label": {
        "pt": "Filtrar títulos (Tocando Agora)",
        "en": "Filter titles (Now Playing)",
        "ru": "Фильтровать названия (Сейчас играет)"
    },
    "now_playing_filter_titles_desc": {
        "pt": "Remove parênteses e 'feat./ft.' dos nomes de músicas.",
        "en": "Removes parentheses and 'feat./ft.' from song titles.",
        "ru": "Удаляет скобки и 'feat./ft.' из названий треков."
    },
    
    # Now Playing (Stats.fm)
    "now_playing_section": {
        "pt": "Tocando Agora",
        "en": "Now Playing",
        "ru": "Сейчас играет"
    },
    "now_playing_label": {
        "pt": "Tocando Agora",
        "en": "Now Playing",
        "ru": "Сейчас играет"
    },
    "now_playing_mode_enabled": {
        "pt": "Ativado",
        "en": "Enabled",
        "ru": "Включено"
    },
    "now_playing_mode_disabled": {
        "pt": "Desativado",
        "en": "Disabled",
        "ru": "Выключено"
    },
    "now_playing_mode_hidden": {
        "pt": "Ocultado",
        "en": "Hidden",
        "ru": "Скрыто"
    },
    "now_playing_mode_expand": {
        "pt": "Expandir",
        "en": "Expand",
        "ru": "Развернуть"
    },
    "statsfm_username_label": {
        "pt": "Usuário do Stats.fm",
        "en": "Stats.fm Username",
        "ru": "Имя пользователя Stats.fm"
    },
    "now_playing_style_label": {
        "pt": "Estilo do Tocando Agora",
        "en": "Now Playing Style",
        "ru": "Стиль Сейчас играет"
    },
    "now_playing_show_cover": {
        "pt": "Mostrar Capa",
        "en": "Show Cover",
        "ru": "Показывать обложку"
    },
    "now_playing_show_cover_sub": {
        "pt": "Aplica a capa do álbum no ActionBar (Chat List).",
        "en": "Apply album cover on ActionBar (Chat List).",
        "ru": "Показывать обложку на панели действий (Список чатов)."
    },
    "now_playing_style_single": {
        "pt": "Padrão",
        "en": "Default",
        "ru": "По умолчанию"
    },
    "now_playing_style_typing": {
        "pt": "Digitando",
        "en": "Typing",
        "ru": "Печать"
    },
    "now_playing_style_music_only": {
        "pt": "Somente Música",
        "en": "Music Only",
        "ru": "Только трек"
    },
    "now_playing_provider_label": {
        "pt": "Fonte do Tocando Agora",
        "en": "Now Playing Source",
        "ru": "Источник Сейчас играет"
    },
    "provider_statsfm": {
        "pt": "Stats.fm",
        "en": "Stats.fm",
        "ru": "Stats.fm"
    },
    "provider_lastfm": {
        "pt": "Last.fm",
        "en": "Last.fm",
        "ru": "Last.fm"
    },
    "lastfm_username_label": {
        "pt": "Usuário do Last.fm",
        "en": "Last.fm Username",
        "ru": "Имя пользователя Last.fm"
    },
    "lastfm_api_key_label": {
        "pt": "Chave de API",
        "en": "API Key",
        "ru": "API-ключ"
    },
    "api_key_option_show": {
        "pt": "Exibir Key",
        "en": "Show Key",
        "ru": "Показать ключ"
    },
    "api_key_option_hide": {
        "pt": "Ocultar Chave",
        "en": "Hide Key",
        "ru": "Скрыть ключ"
    },
    "now_playing_divider_source": {
        "pt": "Fonte",
        "en": "Source",
        "ru": "Источник"
    },
    "now_playing_divider_credentials": {
        "pt": "Credenciais",
        "en": "Credentials",
        "ru": "Учетные данные"
    },
    "api_key_selector_label": {
        "pt": "Token de Acesso",
        "en": "Access Token",
        "ru": "Токен доступа"
    },
    
    # Bulletins - Now Playing Mode
    "bulletin_now_playing_hidden": {
        "pt": "Tocando Agora minimizado",
        "en": "Now Playing collapsed",
        "ru": "Сейчас играет свернуто"
    },
    "bulletin_now_playing_enabled": {
        "pt": "Tocando Agora ativado",
        "en": "Now Playing enabled",
        "ru": "Сейчас играет включено"
    },
    "bulletin_now_playing_disabled": {
        "pt": "Tocando Agora desativado",
        "en": "Now Playing disabled",
        "ru": "Сейчас играет отключено"
    },
    "bulletin_no_music_playing": {
        "pt": "Volte para o chat ;)",
        "en": "Back to chat ;)",
        "ru": "Вернитесь в чат ;)"
    },
    
    # Bulletins - General Settings
    "bulletin_greeting_enabled": {
        "pt": "Saudação ativada",
        "en": "Greeting enabled",
        "ru": "Приветствие включено"
    },
    "bulletin_greeting_disabled": {
        "pt": "Saudação desativada",
        "en": "Greeting disabled",
        "ru": "Приветствие отключено"
    },
    "bulletin_logs_disabled": {
        "pt": "Logs desativados",
        "en": "Logs disabled",
        "ru": "Логи отключены"
    },
    "bulletin_logs_enabled": {
        "pt": "Logs ativados",
        "en": "Logs enabled",
        "ru": "Логи включены"
    },
    "bulletin_chat_menu_enabled": {
        "pt": "Menu do chat ativado",
        "en": "Chat menu enabled",
        "ru": "Меню чата включено"
    },
    "bulletin_chat_menu_disabled": {
        "pt": "Menu do chat desativado",
        "en": "Chat menu disabled",
        "ru": "Меню чата отключено"
    },
    "bulletin_side_menu_enabled": {
        "pt": "Menu lateral ativado",
        "en": "Side menu enabled",
        "ru": "Боковое меню включено"
    },
    "bulletin_side_menu_disabled": {
        "pt": "Menu lateral desativado",
        "en": "Side menu disabled",
        "ru": "Боковое меню отключено"
    },    
    
    # Bulletins - Motion Themes
    "bulletin_motion_themes_enabled": {
        "pt": "Motion Themes ativado",
        "en": "Motion Themes enabled",
        "ru": "Движущиеся темы включены"
    },
    "bulletin_motion_themes_disabled": {
        "pt": "Motion Themes desativado",
        "en": "Motion Themes disabled",
        "ru": "Движущиеся темы отключены"
    },
    
    # Estilo do título (shape)
    "title_style": {
        "pt": "Estilo do título",
        "en": "Title style",
        "ru": "Стиль заголовка"
    },
    "title_style_none": {
        "pt": "Sem shape",
        "en": "None",
        "ru": "Без бейджа"
    },
    "title_style_dark": {
        "pt": "Shape escuro arredondado",
        "en": "Dark rounded shape",
        "ru": "Тёмный скруглённый бейдж"
    },
    "title_style_glow": {
        "pt": "Glow pill",
        "en": "Glow pill",
        "ru": "Светящаяся плашка"
    },
    "title_style_aurora": {
        "pt": "Aurora",
        "en": "Aurora",
        "ru": "Аврора"
    },
    
    # Créditos Dotted - Apple
    "credits": {
        "pt": "Dotted Plugins",
        "en": "Dotted Plugins",
        "ru": "Dotted Plugins"
    },
    # Saudações Padrões - Greeting
    "good_morning": {
        "pt": "Bom dia",
        "en": "Good morning",
        "ru": "Доброе утро"
    },
    "good_afternoon": {
        "pt": "Boa tarde",
        "en": "Good afternoon", 
        "ru": "Добрый день"
    },
    "good_evening": {
        "pt": "Boa noite",
        "en": "Good evening",
        "ru": "Добрый вечер"
    },
    "user_fallback": {
        "pt": "Usuário",
        "en": "User",
        "ru": "Пользователь"
    },
    "default_title": {
        "pt": "Conversas",
        "en": "Chats",
        "ru": "Чаты"
    },
    "default_custom_text": {
        "pt": "Hey, configure-me!",
        "en": "Hey, set me up!",
        "ru": "Эй, настрой меня!"
    }
    ,
    # BottomSheet de Suporte
    "support_title": {
        "pt": "Suporte ao Dev",
        "en": "Support",
        "ru": "Поддержка"
    },
    "support_description": {
        "pt": "Oi. Sou o Apple, dev do plugin ChatList Customizer. Curtiu o projeto? Você pode apoiar enviando um presente no Telegram. É só tocar no meu nome de usuário ou me chamar se quiser ajudar de outro jeito. Qualquer apoio mantém as ideias vivas e traz coisas novas. Obrigado.",
        "en": "Hey. I am Apple, dev of the ChatList Customizer plugin. Like the project? You can support it by sending a Telegram gift. Just tap my username or reach out if you would like to help in another way. Any support keeps ideas alive and new things coming. Thank you.",
        "ru": "Привет. Я Apple, разработчик плагина ChatList Customizer. Нравится проект? Вы можете поддержать его подарком в Telegram. Просто нажмите на мое имя пользователя или напишите, если хотите помочь иначе. Любая поддержка помогает развивать идеи и приносит новые функции. Спасибо."
    },
    "support_button": {
        "pt": "@AGeekApple",
        "en": "@AGeekApple",
        "ru": "@AGeekApple"
    }
    ,
    # Botão para abrir opções de doação
    "donate_options_button": {
        "pt": "Opções de Doação",
        "en": "Donate Options",
        "ru": "Опции доната"
    },
    # Textos do subfragmento de doação (replicado do padrão existente)
    "about_plugin_description": {
        "pt": "Apoie o desenvolvimento e ajude a manter novas ideias.",
        "en": "Support development and help keep new ideas coming.",
        "ru": "Поддержите разработку и помогите новым идеям появляться."
    },
    "about_plugin_header": {
        "pt": "Opções de Doação",
        "en": "Donate Options",
        "ru": "Опции доната"
    },
    "about_plugin_donate": {
        "pt": "Livepix",
        "en": "Livepix",
        "ru": "Livepix"
    },
    "about_plugin_donate_kofi": {
        "pt": "Ko-fi",
        "en": "Ko-fi",
        "ru": "Ko-fi"
    },
    "donate_ton": {
        "pt": "TON",
        "en": "TON",
        "ru": "TON"
    },
    "donate_ton_telegram": {
        "pt": "TON Telegram",
        "en": "TON Telegram",
        "ru": "TON Telegram"
    },
    "donate_btc": {
        "pt": "BTC",
        "en": "BTC",
        "ru": "BTC"
    },
    "donate_eth_erc20": {
        "pt": "Ethereum (ERC20)",
        "en": "Ethereum (ERC20)",
        "ru": "Ethereum (ERC20)"
    }
}

# Variável global para idioma atual
_LANG = "en"

def _detect_lang():
    """Detecta o idioma do sistema"""
    try:
        code = Locale.getDefault().getLanguage()
        if str(code).startswith("pt"):
            return "pt"
        if str(code).startswith("ru"):
            return "ru"
    except Exception:
        pass
    return "en"

def tr(key):
    """Função de tradução que usa o idioma do aplicativo"""
    try:
        # Usa diretamente o idioma do aplicativo
        plugin_lang = _LANG
            
        # Busca a tradução
        d = TRANSLATIONS.get(key, {})
        return d.get(plugin_lang) or d.get("en") or key
    except Exception:
        return key

class ChatListCustomizerPlugin(BasePlugin):
    """Plugin para personalizar o título da Chat List do TG"""
    
    def __init__(self):
        super().__init__()
        self._refresh_worker_thread = None
        self._refresh_worker_stop = None
        # Flags e refs para hooks no ActionBar
        self._is_setting_title = False
        self._hook_set_title_ref = None
        self._hook_set_title_anim_ref = None

    def _setup_actionbar_hooks(self):
        """Configura hooks para interceptar mudanças de título do ActionBar"""
        try:
            ActionBarCls = find_class("org.telegram.ui.ActionBar.ActionBar")
            if not ActionBarCls:
                log("[ChatListCustomizer] ActionBar class not found for hooks")
                return

            # Procurar métodos relevantes por nome
            methods = ActionBarCls.getClass().getDeclaredMethods()
            set_title = None
            set_title_anim = None
            try:
                for m in methods:
                    try:
                        name = str(m.getName())
                        params_len = 0
                        try:
                            params_len = m.getParameterTypes().length
                        except Exception:
                            pass
                        if name == "setTitle" and params_len == 1:
                            set_title = m
                        elif name == "setTitleAnimated" and params_len == 3:
                            set_title_anim = m
                    except Exception:
                        pass
            except Exception:
                pass

            # Instalar hooks, se encontrados
            if set_title:
                try:
                    set_title.setAccessible(True)
                    self._hook_set_title_ref = self.hook_method(set_title, _ActionBarTitleHook(self))
                except Exception as e:
                    log(f"[ChatListCustomizer] Failed to hook setTitle: {e}")
            if set_title_anim:
                try:
                    set_title_anim.setAccessible(True)
                    self._hook_set_title_anim_ref = self.hook_method(set_title_anim, _ActionBarTitleHook(self))
                except Exception as e:
                    log(f"[ChatListCustomizer] Failed to hook setTitleAnimated: {e}")

            if self._hook_set_title_ref or self._hook_set_title_anim_ref:
                log("[ChatListCustomizer] ActionBar title hooks installed")
            else:
                log("[ChatListCustomizer] No ActionBar title methods hooked")
        except Exception as e:
            log(f"[ChatListCustomizer] Failed to setup ActionBar hooks: {e}")

    def _get_user_first_name(self):
        """Obtém o primeiro nome do usuário"""
        try:
            from org.telegram.messenger import UserConfig
            try:
                uc = UserConfig.getInstance(0)
                user = uc.getCurrentUser()
                if user and getattr(user, 'first_name', None):
                    return str(user.first_name)
            except Exception:
                pass
            try:
                # Usar string do sistema
                return str(LocaleController.getString("ActionBarTitleName", R.string.ActionBarTitleName))
            except Exception:
                return tr("user_fallback")
        except Exception:
            return tr("user_fallback")

    def _get_user_username(self):
        """Obtém o username do usuário"""
        try:
            from org.telegram.messenger import UserConfig
            try:
                uc = UserConfig.getInstance(0)
                user = uc.getCurrentUser()
                if user and getattr(user, 'username', None):
                    username = str(user.username)

                    return f"@{username}" if not username.startswith("@") else username
            except Exception:
                pass
            try:
                # Usar string do sistema
                return str(LocaleController.getString("ActionBarTitleUsername", R.string.ActionBarTitleUsername))
            except Exception:
                return tr("user_fallback")
        except Exception:
            return tr("user_fallback")

    def _handle_custom_name_change(self, value):
        """Lida com mudanças no nome customizado"""
        try:
            # Salvar o valor
            self.set_setting("custom_name", value)
            self._apply_settings()
            
            # Se o valor não está vazio, mostrar dialog de restart
            if value.strip():
                self._show_restart_dialog()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança de nome customizado: {e}")
            
    def _handle_greeting_change(self, value):
        """Lida com mudanças na configuração de saudação"""
        try:
            # Salvar o valor
            self.set_setting("enable_greeting", bool(value))
            self._apply_settings()
            
            # Forçar atualização imediata
            self._force_now_playing_update = True
            
            # Recarregar configurações
            self.reload_settings()
            
            # Mostrar bulletin informativo
            try:
                current_fragment = get_last_fragment()
                if bool(value):
                    run_on_ui_thread(lambda: BulletinHelper.show_success(tr("bulletin_greeting_enabled"), current_fragment))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(tr("bulletin_greeting_disabled"), current_fragment))
            except Exception as bulletin_error:
                log(f"[ChatListCustomizer] Erro ao mostrar bulletin de saudação: {bulletin_error}")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança na saudação: {e}")
            
    def _handle_smart_messages_change(self, value):
        """Lida com mudanças na configuração de Smart Messages"""
        try:
            # Salvar o valor
            self.set_setting("smart_messages_enabled", int(value))
            self._apply_settings()
            
            # Forçar atualização imediata
            self._force_now_playing_update = True
            
            # Recarregar configurações
            self.reload_settings()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança em Smart Messages: {e}")

    def _handle_smart_weather_change(self, value):
        """Ativa/Desativa o Smart Weather e mostra/oculta o subfragmento.
        Espera `value` como índice do Selector: 1 = Ativado, 0 = Desativado.
        """
        try:
            self.set_setting("smart_weather_enabled", int(value))
            self._apply_settings()
            # Força reconstrução da lista para exibir/ocultar "Weather Options"
            self.reload_settings()
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança em Smart Weather: {e}")
            
    def _handle_now_playing_change(self, value):
        """Lida com mudanças na configuração de Now Playing"""
        try:
            # Salvar o valor
            self.set_setting("now_playing_enabled", bool(value))
            self._apply_settings()
            
            # Forçar atualização imediata
            self._force_now_playing_update = True
            
            # Recarregar configurações
            self.reload_settings()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança em Now Playing: {e}")
    
    def _get_now_playing_selector_config(self, current_mode):
        """Gera dinamicamente os itens e índice padrão do seletor Now Playing baseado no estado atual"""
        try:
            if current_mode == 1:  # Disabled
                # Quando Disabled, Hidden não deve aparecer
                items = [
                    tr("now_playing_mode_enabled"),   # 0
                    tr("now_playing_mode_disabled")   # 1
                ]
                default_index = 1  # Disabled está selecionado
                
            elif current_mode == 2:  # Hidden
                # Quando Hidden, Enabled vira "Expandir"
                items = [
                    tr("now_playing_mode_expand"),    # 0 
                    tr("now_playing_mode_disabled"),  # 1
                    tr("now_playing_mode_hidden")     # 2
                ]
                default_index = 2  # Hidden está selecionado
                
            else:  # Enabled (0) ou qualquer outro valor
                # Estado padrão: todos os itens normais
                items = [
                    tr("now_playing_mode_enabled"),   # 0
                    tr("now_playing_mode_disabled"),  # 1
                    tr("now_playing_mode_hidden")     # 2
                ]
                default_index = 0  # Enabled está selecionado
                
            return items, default_index
            
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao gerar configuração do seletor Now Playing: {e}")
            # Fallback para configuração padrão
            return [
                tr("now_playing_mode_enabled"),
                tr("now_playing_mode_disabled"),
                tr("now_playing_mode_hidden")
            ], current_mode
            
    def _handle_now_playing_mode_change(self, value):
        """Controla o selector tri-estado do Now Playing com lógica dinâmica.
        Mapeia o índice selecionado para o modo real baseado no estado atual.
        """
        try:
            selected_index = int(value)
            current_mode = int(self.get_setting("now_playing_mode", 1))  # Default: Disabled
            
            # Mapear índice selecionado para modo real baseado no estado atual
            if current_mode == 1:  # Atualmente Disabled
                # Opções: [Enabled, Disabled]
                if selected_index == 0:
                    new_mode = 0  # Enabled
                else:  # selected_index == 1
                    new_mode = 1  # Disabled
                    
            elif current_mode == 2:  # Atualmente Hidden
                # Opções: [Expand, Disabled, Hidden]
                if selected_index == 0:
                    new_mode = 0  # Expand -> Enabled
                elif selected_index == 1:
                    new_mode = 1  # Disabled
                else:  # selected_index == 2
                    new_mode = 2  # Hidden
                    
            else:  # Atualmente Enabled (0) ou outro
                # Opções: [Enabled, Disabled, Hidden]
                if selected_index == 0:
                    new_mode = 0  # Enabled
                elif selected_index == 1:
                    new_mode = 1  # Disabled
                else:  # selected_index == 2
                    new_mode = 2  # Hidden
            
            # Persistir novo modo
            self.set_setting("now_playing_mode", new_mode)
            
            # Apenas Ativado/Desativado alteram o estado real
            if new_mode in (0, 1):
                self.set_setting("now_playing_enabled", bool(new_mode == 0))
                self._apply_settings()
                # Forçar atualização imediata
                self._force_now_playing_update = True
            
            # Em todos os casos, recarregar para refletir expansão/colapso
            self.reload_settings()
            
            # Mostrar bulletins informativos
            try:
                def show_bulletin():
                    current_fragment = get_last_fragment()
                    if new_mode == 0:  # Ativado
                        BulletinHelper.show_success(tr("bulletin_now_playing_enabled"), current_fragment)
                        # Verificar se há música tocando e mostrar bulletin de duas linhas
                        self._show_current_music_bulletin()
                        
                        # Forçar atualização imediata da capa no ActionBar
                        self._force_now_playing_update = True
                    elif new_mode == 1:  # Desativado
                        BulletinHelper.show_info(tr("bulletin_now_playing_disabled"), current_fragment)
                    elif new_mode == 2:  # Ocultado
                        BulletinHelper.show_info(tr("bulletin_now_playing_hidden"), current_fragment)
                
                run_on_ui_thread(show_bulletin)
            except Exception as bulletin_error:
                log(f"[ChatListCustomizer] Erro ao mostrar bulletin: {bulletin_error}")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança no modo de Now Playing: {e}")
            
    def _handle_now_playing_cover_change(self, value):
        """Lida com mudanças na configuração de exibição da capa"""
        try:
            # Salvar o valor
            self.set_setting("now_playing_show_cover", bool(value))
            self._apply_settings()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança na exibição da capa: {e}")
            
    def _handle_keep_cover_change(self, value):
        """Lida com mudanças na configuração de manter capa quando não está tocando"""
        try:
            # Salvar o valor
            self.set_setting("keep_cover_when_not_playing", bool(value))
            self._apply_settings()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança em manter capa: {e}")
    
    def _show_current_music_bulletin(self):
        """Mostra bulletin de duas linhas com a música atual tocando, se houver"""
        try:
            def check_and_show_music():
                try:
                    current_fragment = get_last_fragment()
                    
                    # Limpar cache para forçar nova consulta às APIs
                    if hasattr(self, '_statsfm_cache_time'):
                        self._statsfm_cache_time = 0
                    if hasattr(self, '_lastfm_cache_time'):
                        self._lastfm_cache_time = 0
                    
                    # Obter dados da música atual
                    provider = int(self.get_setting("now_playing_provider", 0))
                    track = None
                    
                    if provider == 0:  # Stats.fm
                        stats_user = self.get_setting("statsfm_username", "").strip()
                        if stats_user:
                            track = self._get_statsfm_current_track(stats_user)
                    elif provider == 1:  # Last.fm
                        last_user = self.get_setting("lastfm_username", "").strip()
                        last_key = self.get_setting("lastfm_api_key", "").strip()
                        if last_user and last_key:
                            track = self._get_lastfm_current_track(last_user, last_key)
                    
                    if track and track.get('title') and track.get('artist'):
                        # Mostrar bulletin de duas linhas com música e artista
                        song = str(track.get('title'))
                        artist = str(track.get('artist'))
                        
                        # Usar ícone de música do Telegram
                        BulletinHelper.show_two_line(
                            song, 
                            artist, 
                            R_tg.raw.msg_theme_remix,  # Ícone de música
                            current_fragment
                        )
                    else:
                        # Nenhuma música tocando
                        BulletinHelper.show_info(tr("bulletin_no_music_playing"), current_fragment)
                        
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao verificar música atual: {e}")
                    # Fallback: mostrar que não há música tocando
                    try:
                        current_fragment = get_last_fragment()
                        BulletinHelper.show_info(tr("bulletin_no_music_playing"), current_fragment)
                    except Exception:
                        pass
            
            # Executar verificação com pequeno delay para permitir consulta às APIs
            from threading import Timer
            timer = Timer(1.5, check_and_show_music)  # 1.5 segundos de delay
            timer.start()
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao mostrar bulletin de música atual: {e}")
            # Fallback: mostrar que não há música tocando
            try:
                current_fragment = get_last_fragment()
                BulletinHelper.show_info(tr("bulletin_no_music_playing"), current_fragment)
            except Exception:
                pass
    
    def _handle_show_chat_menu_change(self, value):
        """Lida com mudanças na configuração de mostrar no menu do chat"""
        try:
            self.set_setting("show_chat_menu", bool(value))
            self._toggle_chat_menu_item(bool(value))
            self.reload_settings()
            
            # Mostrar bulletin informativo
            try:
                current_fragment = get_last_fragment()
                if bool(value):
                    BulletinHelper.show_success(tr("bulletin_chat_menu_enabled"), current_fragment)
                else:
                    BulletinHelper.show_info(tr("bulletin_chat_menu_disabled"), current_fragment)
            except Exception as bulletin_error:
                log(f"[ChatListCustomizer] Erro ao mostrar bulletin de menu do chat: {bulletin_error}")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança em mostrar no menu do chat: {e}")
    
    def _handle_show_side_menu_change(self, value):
        """Lida com mudanças na configuração de mostrar no menu lateral"""
        try:
            self.set_setting("show_side_menu", bool(value))
            self._toggle_side_menu_item(bool(value))
            self.reload_settings()
            
            # Mostrar bulletin informativo
            try:
                current_fragment = get_last_fragment()
                if bool(value):
                    BulletinHelper.show_success(tr("bulletin_side_menu_enabled"), current_fragment)
                else:
                    BulletinHelper.show_info(tr("bulletin_side_menu_disabled"), current_fragment)
            except Exception as bulletin_error:
                log(f"[ChatListCustomizer] Erro ao mostrar bulletin de menu lateral: {bulletin_error}")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança em mostrar no menu lateral: {e}")
    
    def _handle_disable_logs_change(self, value):
        """Lida com mudanças na configuração de desativar logs"""
        try:
            self.set_setting("disable_logs", bool(value))
            _set_log_muted(bool(value))
            _apply_log_wrapper()
            self.reload_settings()
            
            # Mostrar bulletin informativo
            try:
                current_fragment = get_last_fragment()
                if bool(value):
                    BulletinHelper.show_info(tr("bulletin_logs_disabled"), current_fragment)
                else:
                    BulletinHelper.show_success(tr("bulletin_logs_enabled"), current_fragment)
            except Exception as bulletin_error:
                log(f"[ChatListCustomizer] Erro ao mostrar bulletin de logs: {bulletin_error}")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com mudança em desativar logs: {e}")

    def reload_settings(self):
        """Reaplica configurações e força uma atualização imediata do título.
        Evita o erro de atributo ausente e mantém a UI consistente após mudanças.
        """
        try:
            # Reaplicar configurações principais
            self._apply_settings()

            # Tentar aplicar o título imediatamente no fragmento atual
            try:
                fragment = get_last_fragment()
                if fragment:
                    final_title = self._build_final_title()
                    if final_title is not None:
                        action_bar = fragment.getActionBar()
                        if action_bar:
                            try:
                                title_view = action_bar.getTitleTextView()
                                if title_view:
                                    title_view.setText(final_title)
                                else:
                                    action_bar.setTitle(final_title)
                            except Exception:
                                action_bar.setTitle(final_title)
            except Exception:
                # Caso não seja possível, o worker/hook atualizará em seguida
                pass
        except Exception as e:
            log(f"[ChatListCustomizer] Erro em reload_settings: {e}")

    def _open_plugin_settings(self):
        """Abre a interface de configurações do plugin (create_settings)"""
        try:
            def present():
                try:
                    controller = PluginsController.getInstance()
                    plugin = controller.plugins.get(self.id)
                    fragment = get_last_fragment()
                    if plugin and fragment:
                        fragment.presentFragment(PluginSettingsActivity(plugin))
                        return
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao apresentar configurações: {e}")

            run_on_ui_thread(present)
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao abrir configurações: {e}")
    
    def _add_chat_menu_item(self):
        """Adiciona item no menu do chat"""
        try:
            # Evita duplicatas removendo o ID anterior salvo
            if hasattr(self, "chat_menu_item_id") and self.chat_menu_item_id:
                try:
                    self.remove_menu_item(self.chat_menu_item_id)
                except Exception:
                    pass

            item_id = self.add_menu_item(MenuItemData(
                menu_type=MenuItemType.CHAT_ACTION_MENU,
                text="ChatList Customizer",
                icon="msg_list",
                priority=5,
                on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings())
            ))
            try:
                self.chat_menu_item_id = item_id
            except Exception:
                pass
            log("[ChatListCustomizer] Item adicionado ao menu do chat")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao adicionar item ao menu do chat: {e}")
    
    def _remove_chat_menu_item(self):
        """Remove item do menu do chat"""
        try:
            if hasattr(self, "chat_menu_item_id") and self.chat_menu_item_id:
                try:
                    self.remove_menu_item(self.chat_menu_item_id)
                except Exception:
                    pass
                self.chat_menu_item_id = None
            log("[ChatListCustomizer] Item removido do menu do chat")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao remover item do menu do chat: {e}")
    
    def _toggle_chat_menu_item(self, enabled):
        """Alterna item do menu do chat"""
        try:
            if enabled:
                self._add_chat_menu_item()
            else:
                self._remove_chat_menu_item()
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao alternar item do menu do chat: {e}")
    
    def _ensure_side_menu_item(self):
        """Adiciona item no menu lateral"""
        try:
            if not getattr(self, "_side_menu_item_id", None):
                self._side_menu_item_id = self.add_menu_item(MenuItemData(
                    menu_type=MenuItemType.DRAWER_MENU,
                    text="ChatList Customizer",
                    icon="msg_list",
                    priority=160,
                    on_click=lambda ctx: run_on_ui_thread(lambda: self._open_plugin_settings())
                ))
            log("[ChatListCustomizer] Item adicionado ao menu lateral")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao adicionar item ao menu lateral: {e}")
    
    def _remove_side_menu_item(self):
        """Remove item do menu lateral"""
        try:
            if getattr(self, "_side_menu_item_id", None):
                self.remove_menu_item(self._side_menu_item_id)
                self._side_menu_item_id = None
            log("[ChatListCustomizer] Item removido do menu lateral")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao remover item do menu lateral: {e}")
    
    def _toggle_side_menu_item(self, enabled):
        """Alterna item do menu lateral"""
        try:
            if enabled:
                self._ensure_side_menu_item()
            else:
                self._remove_side_menu_item()
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao alternar item do menu lateral: {e}")

    def _show_restart_dialog(self):
        """Mostra dialog perguntando se quer reiniciar o tg"""
        try:
            from ui.alert import AlertDialogBuilder
            from android.content import Intent
            from android.net import Uri
            from org.telegram.messenger import ApplicationLoader
            
            fragment = get_last_fragment()
            if not fragment:
                return
                
            ctx = fragment.getParentActivity() if fragment.getParentActivity() else ApplicationLoader.applicationContext
            if not ctx:
                return
            
            def restart_telegram():
                try:
                    # Usar tg://restart para reiniciar
                    intent = Intent(Intent.ACTION_VIEW, Uri.parse("tg://restart"))
                    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                    ctx.startActivity(intent)
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao reiniciar: {e}")
            
            def show_dialog():
                try:
                    builder = AlertDialogBuilder(ctx)
                    builder.set_title(tr("restart_required_title"))
                    builder.set_message(tr("restart_required_message"))
                    # O listener de botão recebe (dialog, which); aceite-os para evitar TypeError
                    builder.set_positive_button(tr("restart_button"), lambda d, w: restart_telegram())
                    builder.set_negative_button(tr("cancel_button"), None)
                    builder.show()
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao mostrar dialog: {e}")
            
            run_on_ui_thread(show_dialog)
            
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no dialog de restart: {e}")

    def _get_default_chat_list_title(self):
        """Obtém o título padrão da Chat List usando string do sistema"""
        try:
            # Usar string do sistema
            return str(LocaleController.getString("ListOfChats", R.string.ListOfChats))
        except Exception:
            return tr("default_title")

    def _get_display_name_by_option(self):
        """Obtém o nome baseado na opção selecionada"""
        try:
            name_option = self.get_setting("display_name_option", 0)
            
            if name_option == 0:  # Custom (agora é a primeira opção)
                custom_name = self.get_setting("custom_name", "").strip()
                if not custom_name:
                    # Se não há custom name, usar o texto padrão
                    return tr("default_custom_text")
                return custom_name
            elif name_option == 1:  # None
                return None
            elif name_option == 2:  # First Name
                return self._get_user_first_name()
            elif name_option == 3:  # Username
                return self._get_user_username()
            else:
                return tr("default_custom_text")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao obter display name: {e}")
            return tr("default_custom_text")

    def _get_time_based_greeting(self):
        """Retorna saudação baseada no horário atual"""
        try:
            hour = self._get_local_hour()
            
            if hour < 12:
                return tr("good_morning")
            elif hour < 18:
                return tr("good_afternoon")
            else:
                return tr("good_evening")
        except Exception:
            return tr("good_morning")

    # Smart Messages
    def _fetch_smart_messages(self):
        """Retorna o dicionário interno de frases curtas por período.
        Não faz mais requisição remota. Mantém cache em memória.
        """
        try:
            # Reutiliza cache se já carregado
            cached = getattr(self, "_smart_messages_cache", None)
            if isinstance(cached, dict) and cached:
                return cached
            # Usar o dicionário interno embedado
            self._smart_messages_cache = INTERNAL_SMART_MESSAGES
            return INTERNAL_SMART_MESSAGES
        except Exception as e:
            log(f"[ChatListCustomizer] Smart Messages fetch error: {e}")
            return None

    def _get_smart_phrase(self):
        """Retorna uma frase curta de acordo com o horário local e idioma atual.
        Períodos: morning (<12), afternoon (<18), evening (<23), night (>=23 ou <5).
        """
        try:
            data = self._fetch_smart_messages()
            if not isinstance(data, dict):
                return None
            # Idioma atual do app
            try:
                lang = str(LocaleController.getInstance().currentLocale.language)
            except Exception:
                lang = "en"
            # Normalizar idioma: usar base (pt_BR/pt-BR -> pt)
            try:
                lang = (lang or "en").strip()
                if "_" in lang:
                    lang = lang.split("_", 1)[0]
                if "-" in lang:
                    lang = lang.split("-", 1)[0]
                lang = lang.lower()
            except Exception:
                lang = "en"
            if lang not in data:
                lang = "en"
            hour = self._get_local_hour()
            # Mapear período
            if hour < 12:
                bucket = "morning"
            elif hour < 18:
                bucket = "afternoon"
            elif hour < 23:
                bucket = "evening"
            else:
                bucket = "night"
            phrases = data.get(lang, {}).get(bucket, [])
            # Ajuste sensível ao horário: prioriza frases de "almoço" próximo do meio‑dia
            try:
                if 11 <= int(hour) <= 13 and bucket == "afternoon":
                    lunch_keywords = {
                        "pt": ["almoço", "meio do dia"],
                        "en": ["lunch", "midday"],
                        "ru": ["обед", "полдень"],
                    }
                    keys = lunch_keywords.get(lang, [])
                    preferred = [p for p in phrases if any(k.lower() in str(p).lower() for k in keys)]
                    if preferred:
                        phrases = preferred
            except Exception:
                pass
            if not phrases:
                return None
            # Escolha estável por janela de tempo para não "spammar"
            import time, random
            now = int(time.time())
            window_secs = 30 * 60  # 30 minutos por frase
            last_bucket = getattr(self, "_smart_last_bucket", None)
            last_pick_time = int(getattr(self, "_smart_last_pick_time", 0))
            last_phrase = getattr(self, "_smart_last_phrase", None)

            same_bucket = (last_bucket == bucket)
            within_window = (now - last_pick_time) < window_secs if last_pick_time else False
            if same_bucket and within_window and last_phrase:
                return str(last_phrase)

            # Nova seleção aleatória para o bucket atual
            try:
                # Deterministic-ish seed por data+bucket para mais estabilidade
                day_key = time.strftime("%Y-%m-%d", time.localtime(now))
                seed = hash((day_key, bucket, lang)) & 0xFFFFFFFF
                rnd = random.Random(seed)
                phrase = str(rnd.choice(phrases))
            except Exception:
                phrase = str(random.choice(phrases))

            self._smart_last_bucket = bucket
            self._smart_last_pick_time = now
            self._smart_last_phrase = phrase
            
            # Anexar nome de exibição quando disponível
            try:
                display_name = self._get_display_name_by_option()
                if display_name and display_name.strip():
                    # Adicionar vírgula e nome para frases contextuais
                    phrase_with_name = f"{phrase}, {display_name}!"
                    self._smart_last_phrase = phrase_with_name
                    return phrase_with_name
                else:
                    return f"{phrase}!"
            except Exception:
                return f"{phrase}!"
        except Exception as e:
            log(f"[ChatListCustomizer] Smart phrase error: {e}")
            return None

    def _get_local_hour(self):
        """Obtém hora local conforme seleção de fuso horário"""
        try:
            sel = int(self.get_setting("timezone_selection", 0))
            if sel == 0:  # System Default
                cal = Calendar.getInstance()
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 1:  # UTC
                cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 2:  # Europe/Moscow
                cal = Calendar.getInstance(TimeZone.getTimeZone("Europe/Moscow"))
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 3:  # America/Sao_Paulo
                cal = Calendar.getInstance(TimeZone.getTimeZone("America/Sao_Paulo"))
                return int(cal.get(Calendar.HOUR_OF_DAY))
            elif sel == 4:  # Custom Offset (horas)
                try:
                    # Base em UTC e aplica offset de horas
                    cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"))
                    hour = int(cal.get(Calendar.HOUR_OF_DAY))
                    off = int(self.get_setting("timezone_offset_hours", 0))
                    return (hour + off) % 24
                except Exception:
                    cal = Calendar.getInstance()
                    return int(cal.get(Calendar.HOUR_OF_DAY))
            else:
                cal = Calendar.getInstance()
                return int(cal.get(Calendar.HOUR_OF_DAY))
        except Exception:
            try:
                cal = Calendar.getInstance()
                return int(cal.get(Calendar.HOUR_OF_DAY))
            except Exception:
                return datetime.now().hour

    def _format_now_playing_text(self, data):
        """Formata texto do Now Playing para estilo padrão"""
        try:
            song = str(data.get("song", "")).strip()
            artist = str(data.get("artist", "")).strip()
            
            if not song and not artist:
                return ""
            elif song and not artist:
                return song
            elif artist and not song:
                return artist
            else:
                # Alternar entre música e artista (sem marquee)
                try:
                    toggle = int(getattr(self, "_np_toggle_state", 0))
                except Exception:
                    toggle = 0
                return song if toggle == 0 else artist
        except Exception:
            return ""

    def _build_final_title(self):
        """Constrói título final com alternância dinâmica entre funcionalidades"""
        try:
            # Obter configurações
            now_playing_enabled = bool(self.get_setting("now_playing_enabled", False))
            smart_weather_enabled = int(self.get_setting("smart_weather_enabled", 0)) == 1
            smart_messages_enabled = int(self.get_setting("smart_messages_enabled", 0)) == 1
            greeting_enabled = bool(self.get_setting("enable_greeting", False))
            
            # Log de estado das funcionalidades
            log(f"[ChatListCustomizer] Estado das funcionalidades - Now Playing: {now_playing_enabled}, Smart Weather: {smart_weather_enabled}, Smart Messages: {smart_messages_enabled}, Greeting: {greeting_enabled}")
            
            # Obter dados do Now Playing
            now_playing_data = None
            if now_playing_enabled:
                try:
                    provider = int(self.get_setting("now_playing_provider", 0))
                    stats_user = str(self.get_setting("statsfm_username", "")).strip()
                    last_user = str(self.get_setting("lastfm_username", "")).strip()
                    last_key = str(self.get_setting("lastfm_api_key", "")).strip()
                    
                    # Verificar se está configurado corretamente
                    if provider == 0 and stats_user:
                        track = self._get_statsfm_current_track(stats_user)
                    elif provider == 1 and last_user and last_key:
                        track = self._get_lastfm_current_track(last_user, last_key)
                    else:
                        track = None
                    
                    if track and track.get('title') and track.get('artist'):
                        now_playing_data = {
                            "song": str(track.get('title')),
                            "artist": str(track.get('artist'))
                        }
                        # Sanitização opcional
                        try:
                            if bool(self.get_setting("now_playing_filter_titles", True)):
                                now_playing_data["song"] = self._sanitize_now_playing_title(now_playing_data["song"])
                        except Exception:
                            pass
                        
                        # Log quando música está tocando
                        log(f"[ChatListCustomizer] Now Playing active: {now_playing_data['song']} - {now_playing_data['artist']}")
                    else:
                        # Log quando não há música tocando (pausada ou parada) ou não configurado
                        log(f"[ChatListCustomizer] Now Playing: No music playing (paused/stopped) or not configured")
                        # Reduzir cache time quando música parar para atualização mais rápida
                        try:
                            self._statsfm_cache_time = int(time.time()) - 25  # Forçar expiração em 5s
                            self._lastfm_cache_time = int(time.time()) - 25
                            # Forçar atualização imediata para remover capa
                            self._force_now_playing_update = True
                        except Exception:
                            pass
                except Exception as e:
                    log(f"[ChatListCustomizer] Now Playing error: {e}")
                    now_playing_data = None
            
            # Armazenar dados para uso posterior e para o worker
            self._now_playing_data = now_playing_data
            now_playing_style = int(self.get_setting("now_playing_style", 0))
            
            # Estilos especiais do Now Playing (sempre imediatos) - SOMENTE se houver dados válidos
            if now_playing_enabled and now_playing_data:
                if now_playing_style == 1:  # Digitando
                    song = str(now_playing_data.get("song", "")).strip()
                    artist = str(now_playing_data.get("artist", "")).strip()
                    
                    # Inicializar estado de digitação se mudou a música
                    if (getattr(self, "_typing_prev_song", None) != song or 
                        getattr(self, "_typing_prev_artist", None) != artist):
                        self._typing_phase = 0
                        self._typing_index = 0
                        self._typing_prev_song = song
                        self._typing_prev_artist = artist
                    
                    try:
                        phase = int(getattr(self, "_typing_phase", 0))
                        idx = int(getattr(self, "_typing_index", 0))
                        source = song if phase == 0 else artist
                        
                        if idx < len(source):
                            fragment = source[:max(1, idx + 1)]
                            self._typing_index = idx + 1
                            return fragment
                        else:
                            # Trocar fase quando completar
                            self._typing_phase = 1 if phase == 0 else 0
                            self._typing_index = 0
                            next_source = song if self._typing_phase == 0 else artist
                            return next_source[:1] if next_source else ""
                    except Exception:
                        return self._format_now_playing_text(now_playing_data)
                
                elif now_playing_style == 2:  # Somente Música
                    song = str(now_playing_data.get("song", "")).strip()
                    return song
            
            # Criar lista de opções disponíveis para alternância (estilo padrão Now Playing)
            available_options = []
            
            # 1. Now Playing estilo padrão (se ativo e com dados válidos)
            if now_playing_enabled and now_playing_data and now_playing_style == 0:
                available_options.append({
                    "type": "now_playing",
                    "content": self._format_now_playing_text(now_playing_data),
                    "priority": 1
                })
            
            # Se Now Playing está ativado mas não tem dados, permitir que outras funcionalidades funcionem
            # Não bloquear as outras opções quando Now Playing está habilitado mas não configurado
            
            # 2. Smart Weather (se ativo e configurado)
            if smart_weather_enabled:
                city = str(self.get_setting("weather_city", "")).strip()
                wkey = str(self.get_setting("weather_api_key", "")).strip()
                if city and wkey:
                    log(f"[ChatListCustomizer] Smart Weather: Configurado - Cidade: {city}, API Key: {'*' * len(wkey) if wkey else 'vazia'}")
                    try:
                        w = self._fetch_weather_current(city, wkey)
                        frames = self._get_weather_frames(w) if w else []
                        if frames:
                            # Adicionar saudação aos frames do weather se greeting estiver ativo
                            if greeting_enabled:
                                greeting = self._get_time_based_greeting()
                                display_name = self._get_display_name_by_option()
                                if display_name is None:
                                    frames.insert(0, f"{greeting}!")
                                else:
                                    frames.insert(0, f"{greeting}, {display_name}!")
                            
                            available_options.append({
                                "type": "smart_weather",
                                "content": frames,
                                "priority": 2
                            })
                            log(f"[ChatListCustomizer] Smart Weather: Frames adicionados - {len(frames)} frames")
                        else:
                            log(f"[ChatListCustomizer] Smart Weather: Sem frames disponíveis")
                    except Exception as e:
                        log(f"[ChatListCustomizer] Smart Weather erro: {e}")
                        pass
                else:
                    log(f"[ChatListCustomizer] Smart Weather: Não configurado - Cidade: '{city}', API Key: {'*' * len(wkey) if wkey else 'vazia'}")
            
            # 3. Smart Messages (se ativo e na janela de exibição)
            if smart_messages_enabled and int(getattr(self, "_smart_toggle_state", 0)) == 1:
                try:
                    phrase = self._get_smart_phrase()
                    if phrase and phrase.strip():
                        available_options.append({
                            "type": "smart_messages",
                            "content": phrase,
                            "priority": 3
                        })
                        log(f"[ChatListCustomizer] Smart Messages: Adicionado - '{phrase}'")
                    else:
                        log(f"[ChatListCustomizer] Smart Messages: Sem frases disponíveis")
                except Exception as e:
                    log(f"[ChatListCustomizer] Smart Messages erro: {e}")
                    pass
            
            # 4. Enable Greeting (se ativo)
            if greeting_enabled:
                try:
                    greeting = self._get_time_based_greeting()
                    display_name = self._get_display_name_by_option()
                    if display_name is None:
                        greeting_text = f"{greeting}!"
                    else:
                        greeting_text = f"{greeting}, {display_name}!"
                    
                    available_options.append({
                        "type": "greeting",
                        "content": greeting_text,
                        "priority": 4
                    })
                    log(f"[ChatListCustomizer] Enable Greeting: Adicionado - '{greeting_text}'")
                except Exception as e:
                    log(f"[ChatListCustomizer] Enable Greeting erro: {e}")
                    pass
            
            # Se não houver opções disponíveis, usar nome padrão
            if not available_options:
                log(f"[ChatListCustomizer] No dynamic options available, using default display name")
                display_name = self._get_display_name_by_option()
                if display_name is None:
                    return None
                return display_name
            else:
                # Log das opções disponíveis para alternância
                option_types = [opt["type"] for opt in available_options]
                log(f"[ChatListCustomizer] Available dynamic options: {option_types}")
            
            # Sistema de alternância dinâmica
            current_time = time.time()
            cycle_interval = 8  # Segundos para cada ciclo de alternância
            
            # Obter índice do ciclo atual (baseado no tempo)
            try:
                cycle_index = int((current_time // cycle_interval) % len(available_options))
            except Exception:
                cycle_index = 0
            
            # Selecionar opção baseada no ciclo
            selected_option = available_options[cycle_index]
            
            # Log de depuração para alternância
            log(f"[ChatListCustomizer] Dynamic cycle: {cycle_index + 1}/{len(available_options)} - Type: {selected_option['type']} - Time: {int(current_time % (len(available_options) * cycle_interval))}s")
            
            # Processar conteúdo baseado no tipo
            if selected_option["type"] == "smart_weather":
                # Para Smart Weather, usar o índice de alternância existente
                frames = selected_option["content"]
                try:
                    alt_idx = int(getattr(self, "_alt_index", 0))
                except Exception:
                    alt_idx = 0
                return frames[alt_idx % len(frames)]
            else:
                # Para outros tipos, retornar diretamente
                return selected_option["content"]
                
        except Exception as e:
            log(f"[ChatListCustomizer] Error building title with dynamic cycling: {e}")
            return None

    def _sanitize_now_playing_title(self, title: str) -> str:
        """Remove conteúdo entre parênteses e qualquer sufixo de 'feat./ft./featuring'"""
        try:
            import re
            t = str(title or "")
            # Remover conteúdo entre parênteses, múltiplas ocorrências
            t = re.sub(r"\([^\)]*\)", "", t)
            # Remover sufixos de feat/ft/featuring e tudo depois disso
            t = re.sub(r"\b(feat(?:uring)?|ft)\b\.?\s*.*$", "", t, flags=re.IGNORECASE)
            # Limpar separadores residuais no fim
            t = re.sub(r"[\-–|•\/]+\s*$", "", t)
            # Normalizar espaços
            t = re.sub(r"\s+", " ", t).strip()
            return t
        except Exception:
            return str(title or "")

    def _get_statsfm_current_track(self, username):
        """Consulta a API do Stats.fm e retorna a música atual.
        Retorna dict com 'title', 'artist' e 'image_url' (capa oficial) quando estiver tocando; caso contrário, None.
        Implementa cache para reduzir chamadas à API e melhorar desempenho.
        """
        try:
            # Verificar cache para reduzir chamadas à API
            force = bool(getattr(self, "_force_now_playing_update", False))
            cache_time = getattr(self, "_statsfm_cache_time", 0)
            cache_data = getattr(self, "_statsfm_cache_data", None)
            current_time = int(time.time())
            
            # Usar cache se disponível e não expirado (15 segundos para atualização mais rápida)
            if not force and cache_data and (current_time - cache_time) < 15:
                return cache_data
                
            url = f"https://api.stats.fm/api/v1/users/{username}/streams/current"
            headers = {
                "Accept": "application/json",
                "User-Agent": "ChatListCustomizer/1.0"
            }
            data = None
            try:
                import requests
                log(f"[ChatListCustomizer] Stats.fm fazendo request para: {url}")
                resp = requests.get(url, headers=headers, timeout=3)  # Reduzido timeout para 3s
                log(f"[ChatListCustomizer] Stats.fm response status: {resp.status_code}")
                if resp.status_code == 200:
                    data = resp.json()
                    log(f"[ChatListCustomizer] Stats.fm response data: {data}")
                else:
                    log(f"[ChatListCustomizer] Stats.fm HTTP {resp.status_code}")
                    return None
            except Exception:
                # Fallback mínimo usando Java URLConnection (ambiente Android)
                try:
                    import json
                    from java.net import URL
                    u = URL(url)
                    con = u.openConnection()
                    con.setRequestProperty("Accept", "application/json")
                    con.setRequestProperty("User-Agent", "ChatListCustomizer/1.0")
                    con.setConnectTimeout(5000)
                    con.setReadTimeout(5000)
                    stream = con.getInputStream()
                    try:
                        from java.io import BufferedReader, InputStreamReader
                        reader = BufferedReader(InputStreamReader(stream))
                        sb = []
                        line = reader.readLine()
                        while line is not None:
                            sb.append(line)
                            line = reader.readLine()
                        reader.close()
                        raw = "".join(sb)
                        data = json.loads(raw)
                    finally:
                        stream.close()
                except Exception as e2:
                    log(f"[ChatListCustomizer] Stats.fm fallback error: {str(e2)}")
                    return None

            try:
                item = data.get("item") if isinstance(data, dict) else None
                if item and item.get("isPlaying"):
                    track_info = item.get("track", {})
                    # Extrair nomes dos artistas
                    artists_raw = track_info.get("artists", [])
                    artists = []
                    try:
                        artists = [a.get("name", "") for a in artists_raw]
                    except Exception:
                        artists = []
                    # Limitar a 1-2 artistas para evitar listas longas (feat.)
                    artists = [s for s in artists if s][:2]
                    title = str(track_info.get("name", ""))
                    artist = ", ".join(artists)

                    # Extrair URL da capa usando campos oficiais do Stats.fm
                    cover_url = None
                    try:
                        album = track_info.get("album", {}) if isinstance(track_info, dict) else {}
                        images = album.get("images", []) if isinstance(album, dict) else []
                        log(f"[ChatListCustomizer] Stats.fm album: {album}")
                        log(f"[ChatListCustomizer] Stats.fm images: {images}")
                        if isinstance(images, list) and images:
                            try:
                                # Escolher a imagem com maior largura, quando disponível
                                best = sorted(
                                    [img for img in images if isinstance(img, dict) and img.get("url")],
                                    key=lambda x: int(x.get("width", 0)),
                                    reverse=True
                                )
                                cover_url = (best[0].get("url") if best else None) or (images[0].get("url") if isinstance(images[0], dict) else None)
                            except Exception:
                                cover_url = (images[0].get("url") if isinstance(images[0], dict) else None)
                        if not cover_url:
                            cov = album.get("cover")
                            if isinstance(cov, dict):
                                cover_url = cov.get("url") or cov.get("source")
                            elif isinstance(cov, str):
                                cover_url = cov
                        if not cover_url:
                            timgs = track_info.get("images", [])
                            if isinstance(timgs, list) and timgs:
                                cover_url = timgs[0].get("url") if isinstance(timgs[0], dict) else None
                        log(f"[ChatListCustomizer] Stats.fm cover_url final: {cover_url}")
                    except Exception as e:
                        log(f"[ChatListCustomizer] Stats.fm erro ao extrair cover_url: {str(e)}")
                        cover_url = None

                    if title and artist:
                        result = { 'title': title, 'artist': artist }
                        if cover_url:
                            result['image_url'] = cover_url
                        log(f"[ChatListCustomizer] Stats.fm dados extraídos: {result}")
                        # Atualizar cache
                        self._statsfm_cache_data = result
                        self._statsfm_cache_time = int(time.time())
                        # Limpar força após atualização bem-sucedida
                        try:
                            self._force_now_playing_update = False
                        except Exception:
                            pass
                        return result
            except Exception as e3:
                log(f"[ChatListCustomizer] Stats.fm parse error: {str(e3)}")
                return None

            return None
        except Exception as e:
            log(f"[ChatListCustomizer] Stats.fm error: {str(e)}")
            return None

    def _get_lastfm_current_track(self, username, api_key):
        """Consulta a API do Last.fm e retorna a música atual"""
        try:
            if not username or not api_key:
                return None
                
            # Verificar cache para reduzir chamadas à API
            force = bool(getattr(self, "_force_now_playing_update", False))
            cache_time = getattr(self, "_lastfm_cache_time", 0)
            cache_data = getattr(self, "_lastfm_cache_data", None)
            current_time = int(time.time())
            
            # Usar cache se disponível e não expirado (15 segundos para atualização mais rápida)
            if not force and cache_data and (current_time - cache_time) < 15:
                return cache_data
                
            # Endpoint para obter faixa recente e verificar se está tocando agora
            url = (
                "https://ws.audioscrobbler.com/2.0/?method=user.getrecenttracks"
                f"&user={username}&api_key={api_key}&format=json&limit=1"
            )
            headers = {
                "Accept": "application/json",
                "User-Agent": "ChatListCustomizer/1.0"
            }
            data = None
            try:
                import requests
                resp = requests.get(url, headers=headers, timeout=3)  # Reduzido timeout para 3s
                if resp.status_code == 200:
                    data = resp.json()
                else:
                    log(f"[ChatListCustomizer] Last.fm HTTP {resp.status_code}")
            except Exception as e:
                log(f"[ChatListCustomizer] Last.fm request error: {str(e)}")
                return None

            if not data:
                return None

            try:
                recent = data.get("recenttracks", {})
                tracks = recent.get("track", [])
                # Quando limit=1, 'track' pode ser dict ou lista com um item
                item = None
                if isinstance(tracks, list):
                    item = tracks[0] if tracks else None
                elif isinstance(tracks, dict):
                    item = tracks
                if not item:
                    return None

                # Verificar se está tocando agora via atributo @attr.nowplaying
                attrs = item.get("@attr", {}) if isinstance(item, dict) else {}
                is_playing = False
                try:
                    is_playing = bool(attrs.get("nowplaying", False))
                except Exception:
                    is_playing = False
                if not is_playing:
                    return None

                # Extrair título e artista, limitando artistas
                title = str(item.get("name", ""))
                artist_obj = item.get("artist", {})
                artist_name = ""
                try:
                    artist_name = str(artist_obj.get("#text", ""))
                except Exception:
                    artist_name = ""

                artists = []
                if artist_name:
                    # Last.fm geralmente retorna um único artista; manter o nome
                    artists = [artist_name]
                # Limitar a 1–2 artistas por legibilidade
                artists = [s for s in artists if s][:2]
                artist = ", ".join(artists)
                
                # Preparar resultado para cache
                result = {'title': title, 'artist': artist}

                # Extrair imagem (maior disponível)
                image_url = None
                try:
                    images = item.get("image", []) if isinstance(item, dict) else []
                    # Buscar por ordem de preferência
                    preferred_sizes = ["extralarge", "mega", "large", "medium"]
                    size_map = {}
                    for im in images:
                        try:
                            sz = str(im.get("size", "") or "").lower()
                            url_txt = str(im.get("#text", "") or "").strip()
                            if url_txt:
                                size_map[sz] = url_txt
                        except Exception:
                            pass
                    for sz in preferred_sizes:
                        if sz in size_map and size_map[sz]:
                            image_url = size_map[sz]
                            break
                    if not image_url and images:
                        # fallback para qualquer disponível
                        for im in images:
                            url_txt = str(im.get("#text", "") or "").strip()
                            if url_txt:
                                # Melhorar qualidade da imagem substituindo URLs de baixa resolução
                                url_txt = url_txt.replace("-64.", "-300.").replace("-34.", "-300.")
                                image_url = url_txt
                                break
                                
                    # Melhorar qualidade da imagem substituindo tamanhos pequenos por maiores
                    if image_url:
                        if "-64." in image_url:
                            image_url = image_url.replace("-64.", "-300.")
                        elif "-34." in image_url:
                            image_url = image_url.replace("-34.", "-300.")
                except Exception:
                    image_url = None

                if title and artist:
                    result = { 'title': title, 'artist': artist, 'image_url': image_url }
                    # Atualizar cache
                    self._lastfm_cache_data = result
                    self._lastfm_cache_time = int(time.time())
                    return result
            except Exception as e3:
                log(f"[ChatListCustomizer] Last.fm parse error: {str(e3)}")
                return None

            return None
        except Exception as e:
            log(f"[ChatListCustomizer] Last.fm error: {str(e)}")
            return None

    # Smart Weather
    def _get_weatherapi_lang_code(self):
        """Retorna o código de idioma para WeatherAPI baseado na configuração do usuário"""
        try:
            # Usa o idioma configurado pelo usuário nas opções do Weather
            user_lang = self.get_setting("weather_language", "en")
            
            # Mapeia para códigos suportados pelo WeatherAPI
            lang_map = {
                'pt': 'pt',
                'en': 'en', 
                'ru': 'ru'
            }
            
            # Retorna o código ou padrão 'en'
            return lang_map.get(user_lang, 'en')
        except Exception:
            return 'en'

    def _fetch_weather_current(self, city: str, api_key: str):
        """Consulta a WeatherAPI e retorna dados atuais básicos.
        Usa cache por 5 minutos para evitar excesso de chamadas.
        """
        try:
            if not city or not api_key:
                return None

            now = int(time.time())
            cache_key = f"{city.lower()}|{api_key[-4:] if len(api_key) >= 4 else 'key'}"
            cache = getattr(self, "_weather_cache", {}) or {}
            cached_entry = cache.get(cache_key)
            if cached_entry and (now - cached_entry.get("ts", 0)) < 300:
                return cached_entry.get("data")

            # Obter código de idioma para WeatherAPI
            lang_code = self._get_weatherapi_lang_code()
            url = f"http://api.weatherapi.com/v1/current.json?key={api_key}&q={city}&aqi=no&lang={lang_code}"
            headers = {"Accept": "application/json", "User-Agent": "ChatListCustomizer/1.0"}
            data = None
            try:
                import requests
                resp = requests.get(url, headers=headers, timeout=3)
                if resp.status_code == 200:
                    data = resp.json()
                else:
                    return None
            except Exception:
                # Fallback Java URLConnection (ambiente Android)
                try:
                    import json
                    from java.net import URL
                    u = URL(url)
                    con = u.openConnection()
                    con.setRequestProperty("Accept", "application/json")
                    con.setRequestProperty("User-Agent", "ChatListCustomizer/1.0")
                    con.setConnectTimeout(4000)
                    con.setReadTimeout(4000)
                    stream = con.getInputStream()
                    try:
                        from java.io import BufferedReader, InputStreamReader
                        reader = BufferedReader(InputStreamReader(stream))
                        sb = []
                        line = reader.readLine()
                        while line is not None:
                            sb.append(line)
                            line = reader.readLine()
                        reader.close()
                        raw = "".join(sb)
                        data = json.loads(raw)
                    finally:
                        stream.close()
                except Exception as e2:
                    log(f"[ChatListCustomizer] Weather fetch fallback error: {e2}")
                    return None

            if not isinstance(data, dict):
                return None

            # Extrair campos mínimos usados na apresentação
            try:
                loc = data.get("location", {}) or {}
                cur = data.get("current", {}) or {}
                result = {
                    "city": str(loc.get("name", city)),
                    "temp_c": cur.get("temp_c"),
                    "temp_f": cur.get("temp_f"),
                    "condition": (cur.get("condition") or {}).get("text"),
                    "wind_kph": cur.get("wind_kph"),
                    "wind_mph": cur.get("wind_mph"),
                    "humidity": cur.get("humidity"),
                    "feelslike_c": cur.get("feelslike_c"),
                    "feelslike_f": cur.get("feelslike_f"),
                }
            except Exception:
                return None

            # Atualiza cache
            cache[cache_key] = {"ts": now, "data": result}
            self._weather_cache = cache
            return result
        except Exception as e:
            log(f"[ChatListCustomizer] Weather fetch error: {e}")
            return None

    # Helper de Emojis para Condições Climáticas
    def _get_condition_emoji(self, cond_text: str) -> str:
        """Retorna um emoji representativo da condição do clima"""
        try:
            t = str(cond_text or "").strip().lower()
            if not t:
                return ""
            # Parcialmente ensolarado / parcialmente nublado
            if ("partly" in t or "intermittent" in t) and ("cloud" in t or "sun" in t):
                return "⛅️"
            # Ensolarado / Claro
            if "sunny" in t or "clear" in t:
                return "☀️"
            # Nublado / Encoberto
            if "cloud" in t or "overcast" in t:
                return "☁️"
            # Tempestade / Trovoadas
            if "thunder" in t or "storm" in t:
                return "⛈️"
            # Chuva / Garoa / Pancadas
            if "rain" in t or "drizzle" in t or "shower" in t:
                return "🌧️"
            # Granizo / Sleet
            if "sleet" in t or "hail" in t:
                return "🌨️"
            # Neve
            if "snow" in t or "blizzard" in t:
                return "❄️"
            # Névoa / Neblina / Haze / Fumaça
            if "fog" in t or "mist" in t or "haze" in t or "smoke" in t:
                return "🌫️"
            # Vento / Brisa / Rajadas
            if "wind" in t or "breeze" in t or "gust" in t:
                return "🌬️"
            # Calor
            if "hot" in t or "heat" in t:
                return "🔥"
            # Frio / Congelante / Gelo
            if "cold" in t or "freezing" in t or "ice" in t:
                return "🧊"
            return ""
        except Exception:
            return ""

    def _get_weather_frames(self, w: dict) -> list:
        """Retorna uma lista de frames de título para o clima, sem emojis.
        Primeiro frame: "Cidade Temp". Frames seguintes: Condition, Wind, Humidity, Feels Like conforme switches.
        """
        try:
            frames = []
            if not isinstance(w, dict):
                return frames
            unit = int(self.get_setting("weather_units", 0))  # 0=Celsius, 1=Fahrenheit
            temp = w.get("temp_c") if unit == 0 else w.get("temp_f")
            feels = w.get("feelslike_c") if unit == 0 else w.get("feelslike_f")
            t_unit = "°C" if unit == 0 else "°F"
            city = str(w.get("city") or "")

            # Base frame: City + Temperature
            if temp is not None:
                try:
                    frames.append(f"{city} {int(round(float(temp)))}{t_unit}")
                except Exception:
                    frames.append(f"{city} {temp}{t_unit}")
            else:
                frames.append(city or "")

            # Optional frames
            try:
                if bool(self.get_setting("weather_show_condition", True)):
                    cond = w.get("condition")
                    if cond:
                        # Sem prefixo "Condition:" — apenas o texto da condição
                        # Se emojis estiverem ativos, anexar o emoji correspondente
                        try:
                            if bool(self.get_setting("weather_enable_emojis", False)):
                                emoji = self._get_condition_emoji(cond)
                                frames.append(f"{cond} {emoji}".strip()) if emoji else frames.append(str(cond))
                            else:
                                frames.append(str(cond))
                        except Exception:
                            frames.append(str(cond))
            except Exception:
                pass

            try:
                if bool(self.get_setting("weather_show_wind", False)):
                    # wind: kph or mph depending on unit
                    if unit == 0:
                        wk = w.get("wind_kph")
                        if wk is not None:
                            try:
                                frames.append(f"{tr('weather_wind_prefix')} {int(round(float(wk)))} km/h")
                            except Exception:
                                frames.append(f"{tr('weather_wind_prefix')} {wk} km/h")
                    else:
                        wm = w.get("wind_mph")
                        if wm is not None:
                            try:
                                frames.append(f"{tr('weather_wind_prefix')} {int(round(float(wm)))} mph")
                            except Exception:
                                frames.append(f"{tr('weather_wind_prefix')} {wm} mph")
            except Exception:
                pass

            try:
                if bool(self.get_setting("weather_show_humidity", False)):
                    h = w.get("humidity")
                    if h is not None:
                        try:
                            frames.append(f"{tr('weather_humidity_prefix')} {int(h)}%")
                        except Exception:
                            frames.append(f"{tr('weather_humidity_prefix')} {h}%")
            except Exception:
                pass

            try:
                if bool(self.get_setting("weather_show_feelslike", False)) and feels is not None:
                    try:
                        frames.append(f"{tr('weather_feels_prefix')} {int(round(float(feels)))}{t_unit}")
                    except Exception:
                        frames.append(f"{tr('weather_feels_prefix')} {feels}{t_unit}")
            except Exception:
                pass

            return [f for f in frames if f]
        except Exception:
            return []

    def _set_chat_list_title(self, title):
        """Aplica título personalizado na Chat List"""
        try:
            log(f"[ChatListCustomizer] Tentando aplicar título: {title}")
            fragment = get_last_fragment()
            log(f"[ChatListCustomizer] Fragment obtido: {fragment}")
            
            if fragment:
                fragment_name = fragment.getClass().getName()
                log(f"[ChatListCustomizer] Fragment name: {fragment_name}")
                
                if "DialogsActivity" in fragment_name:
                    action_bar = fragment.getActionBar()
                    log(f"[ChatListCustomizer] ActionBar obtido: {action_bar}")
                    
                    if action_bar:
                        def apply_title():
                            try:
                                # Primeiro tentar TextView do título
                                try:
                                    title_view = action_bar.getTitleTextView()
                                    if title_view:
                                        title_view.setText(title)
                                        try:
                                            # Aplicar estilo visual do título (badge/shape)
                                            style_idx = int(self.get_setting("title_style", 0))
                                            if style_idx == 1:
                                                from android.graphics.drawable import GradientDrawable
                                                shape = GradientDrawable()
                                                shape.setColor(0x66000000)
                                                shape.setCornerRadius(float(AndroidUtilities.dp(8)))
                                                title_view.setBackground(shape)
                                                pad_h = int(AndroidUtilities.dp(8))
                                                pad_v = int(AndroidUtilities.dp(4))
                                                title_view.setPadding(pad_h, pad_v, pad_h, pad_v)
                                                # garantir que não haja blur aplicado
                                                try:
                                                    if hasattr(title_view, "setRenderEffect"):
                                                        title_view.setRenderEffect(None)
                                                except Exception:
                                                    pass
                                                # remove qualquer sombra prévia
                                                if hasattr(title_view, "setShadowLayer"):
                                                    try:
                                                        title_view.setShadowLayer(0.0, 0.0, 0.0, 0)
                                                    except Exception:
                                                        pass
                                                # resetar letter spacing caso exista
                                                if hasattr(title_view, "setLetterSpacing"):
                                                    try:
                                                        title_view.setLetterSpacing(0.0)
                                                    except Exception:
                                                        pass
                                            elif style_idx == 2:
                                                # Novo estilo: Glow Pill (contorno + brilho)
                                                from android.graphics.drawable import GradientDrawable
                                                shape = GradientDrawable()
                                                # Fundo transparente com contorno sutil
                                                shape.setColor(0x00000000)
                                                try:
                                                    shape.setCornerRadius(float(AndroidUtilities.dp(12)))
                                                except Exception:
                                                    shape.setCornerRadius(12.0)
                                                try:
                                                    shape.setStroke(int(AndroidUtilities.dp(1)), 0x44FFFFFF)
                                                except Exception:
                                                    shape.setStroke(1, 0x44FFFFFF)
                                                # Aplicar pequeno inset para evitar corte inferior
                                                try:
                                                    from android.graphics.drawable import InsetDrawable
                                                    inset_bottom = int(AndroidUtilities.dp(2))
                                                    inset = InsetDrawable(shape, int(AndroidUtilities.dp(1)), int(AndroidUtilities.dp(1)), int(AndroidUtilities.dp(1)), inset_bottom)
                                                    title_view.setBackground(inset)
                                                except Exception:
                                                    # Fallback: usar shape diretamente
                                                    try:
                                                        title_view.setBackground(shape)
                                                    except Exception:
                                                        pass
                                                # Padding confortável
                                                pad_h = int(AndroidUtilities.dp(10))
                                                pad_v = int(AndroidUtilities.dp(4))
                                                extra_b = int(AndroidUtilities.dp(2))
                                                title_view.setPadding(pad_h, pad_v, pad_h, pad_v + extra_b)
                                                # garantir que não haja blur aplicado
                                                try:
                                                    if hasattr(title_view, "setRenderEffect"):
                                                        title_view.setRenderEffect(None)
                                                except Exception:
                                                    pass
                                                # Brilho sutil ao redor do texto
                                                if hasattr(title_view, "setShadowLayer"):
                                                    try:
                                                        # raio ~6dp, deslocamento 0, cor branca translúcida
                                                        title_view.setShadowLayer(float(AndroidUtilities.dp(6)), 0.0, 0.0, 0x55FFFFFF)
                                                    except Exception:
                                                        try:
                                                            title_view.setShadowLayer(6.0, 0.0, 0.0, 0x55FFFFFF)
                                                        except Exception:
                                                            pass
                                                # Espaçamento sutil entre letras para efeito premium
                                                if hasattr(title_view, "setLetterSpacing"):
                                                    try:
                                                        title_view.setLetterSpacing(0.03)
                                                    except Exception:
                                                        pass
                                            elif style_idx == 3:
                                                # Novo estilo: Aurora Blur (cápsula sem borda, com leve blur)
                                                # Objetivo: cápsula com gradiente suave e suavização sem stroke
                                                try:
                                                    from android.graphics.drawable import GradientDrawable
                                                    shape = GradientDrawable()
                                                    # Orientação do gradiente esquerda->direita
                                                    try:
                                                        shape.setOrientation(GradientDrawable.Orientation.LEFT_RIGHT)
                                                    except Exception:
                                                        pass
                                                    # Cores do gradiente (mais preenchidas, sem borda)
                                                    try:
                                                        shape.setColors([0x663A7BD5, 0x66D16BA5])
                                                    except Exception:
                                                        # Fallback: cor única caso setColors não esteja disponível
                                                        shape.setColor(0x443A7BD5)
                                                    # Raio mais suave
                                                    try:
                                                        shape.setCornerRadius(float(AndroidUtilities.dp(14)))
                                                    except Exception:
                                                        shape.setCornerRadius(14.0)
                                                    # Aplicar pequeno inset para evitar corte inferior
                                                    try:
                                                        from android.graphics.drawable import InsetDrawable
                                                        inset_bottom = int(AndroidUtilities.dp(2))
                                                        inset = InsetDrawable(shape, int(AndroidUtilities.dp(1)), int(AndroidUtilities.dp(1)), int(AndroidUtilities.dp(1)), inset_bottom)
                                                        title_view.setBackground(inset)
                                                    except Exception:
                                                        # Fallback: usar shape diretamente
                                                        try:
                                                            title_view.setBackground(shape)
                                                        except Exception:
                                                            pass
                                                    # O efeito visual fica por conta do gradiente no background apenas
                                                    # Padding confortável
                                                    pad_h = int(AndroidUtilities.dp(12))
                                                    pad_v = int(AndroidUtilities.dp(5))
                                                    extra_b = int(AndroidUtilities.dp(2))
                                                    title_view.setPadding(pad_h, pad_v, pad_h, pad_v + extra_b)
                                                    # Brilho sutil para simular blur no entorno do texto
                                                    if hasattr(title_view, "setShadowLayer"):
                                                        try:
                                                            title_view.setShadowLayer(float(AndroidUtilities.dp(8)), 0.0, 0.0, 0x333A7BD5)
                                                        except Exception:
                                                            try:
                                                                title_view.setShadowLayer(8.0, 0.0, 0.0, 0x333A7BD5)
                                                            except Exception:
                                                                pass
                                                    # Espaçamento sutil
                                                    if hasattr(title_view, "setLetterSpacing"):
                                                        try:
                                                            title_view.setLetterSpacing(0.03)
                                                        except Exception:
                                                            pass
                                                except Exception as eAur:
                                                    # Em caso de erro, não quebrar UI
                                                    log(f"[ChatListCustomizer] Aurora style failed: {eAur}")
                                            else:
                                                try:
                                                    title_view.setBackground(None)
                                                except Exception:
                                                    pass
                                                title_view.setPadding(0, 0, 0, 0)
                                                # remover sombra e espaçamento de letra
                                                if hasattr(title_view, "setShadowLayer"):
                                                    try:
                                                        title_view.setShadowLayer(0.0, 0.0, 0.0, 0)
                                                    except Exception:
                                                        pass
                                                if hasattr(title_view, "setLetterSpacing"):
                                                    try:
                                                        title_view.setLetterSpacing(0.0)
                                                    except Exception:
                                                        pass
                                            # Configuração segura de elipsização (sem rolamento)
                                            try:
                                                from android.text import TextUtils
                                                # SimpleTextView não possui setSingleLine; usar setMaxLines(1)
                                                title_view.setMaxLines(1)
                                                # Verificar métodos antes de chamar para evitar AttributeError
                                                if hasattr(title_view, "setHorizontallyScrolling"):
                                                    try:
                                                        title_view.setHorizontallyScrolling(False)
                                                    except Exception:
                                                        pass
                                                if hasattr(title_view, "setEllipsize"):
                                                    try:
                                                        title_view.setEllipsize(TextUtils.TruncateAt.END)
                                                    except Exception:
                                                        pass
                                                if hasattr(title_view, "setMarqueeRepeatLimit"):
                                                    try:
                                                        title_view.setMarqueeRepeatLimit(0)
                                                    except Exception:
                                                        pass
                                            except Exception as e3:
                                                log(f"[ChatListCustomizer] Ellipsize setup failed: {e3}")
                                        except Exception as e2:
                                            log(f"[ChatListCustomizer] Title style apply failed: {e2}")
                                        log(f"[ChatListCustomizer] Título aplicado via TextView: {title}")
                                        return
                                except Exception as e:
                                    log(f"[ChatListCustomizer] TextView falhou: {e}")
                                
                                # Fallback para setTitle diretamente
                                action_bar.setTitle(title)
                                log(f"[ChatListCustomizer] Título aplicado via ActionBar: {title}")
                                
                            except Exception as e:
                                log(f"[ChatListCustomizer] Erro ao aplicar título: {e}")
                        
                        run_on_ui_thread(apply_title)
                        log(f"[ChatListCustomizer] Comando de aplicação enviado: {title}")
                    else:
                        log("[ChatListCustomizer] ActionBar é None!")
                else:
                    log(f"[ChatListCustomizer] Fragment não é DialogsActivity: {fragment_name}")
            else:
                log("[ChatListCustomizer] Fragment é None!")
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao aplicar título: {e}")

    # Banner de capa no ActionBar (Beta)
    def _ensure_plugin_dir(self):
        try:
            from org.telegram.messenger import ApplicationLoader
            from java.io import File
            base_dir = ApplicationLoader.getFilesDirFixed()
            if base_dir:
                plugin_folder = File(base_dir, self.id)
                if not plugin_folder.exists():
                    plugin_folder.mkdirs()
                return plugin_folder.getAbsolutePath()
        except Exception:
            return None

    def _download_image_to_cache(self, url: str):
        try:
            if not url:
                return None
            import hashlib, os
            cache_dir = self._ensure_plugin_dir()
            if not cache_dir:
                return None
            name = hashlib.md5(url.encode('utf-8')).hexdigest() + ".img"
            path = os.path.join(cache_dir, name)
            # Se já existe, reutiliza
            try:
                if os.path.exists(path) and os.path.getsize(path) > 0:
                    return path
            except Exception:
                pass
            # Download
            import requests
            r = requests.get(url, timeout=10)
            if r.status_code != 200:
                return None
            with open(path, 'wb') as f:
                f.write(r.content)
            return path
        except Exception as e:
            log(f"[ChatListCustomizer] Download image error: {e}")
            return None
    # Funcionalidade para banner no ActionBar - Menção honrosa: @devRooni (pelo método)
    def _remove_chat_list_cover_banner(self):
        """Remove a capa do ActionBar e restaura o tema original"""
        try:
            fragment = get_last_fragment()
            if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                return
            action_bar = fragment.getActionBar()
            if not action_bar:
                return

            orig_draw = getattr(self, "_original_drawable", None)
            orig_color = getattr(self, "_original_color", None)
            
            def restore_bg():
                try:
                    if orig_draw is not None:
                        action_bar.setBackgroundDrawable(orig_draw)
                    if orig_color is not None:
                        action_bar.setBackgroundColor(orig_color)
                    self._banner_applied = False
                    log("[ChatListCustomizer] Capa removida do ActionBar")
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao restaurar banner: {e}")
            
            run_on_ui_thread(restore_bg, delay=0)
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao remover capa: {e}")

    def _apply_chat_list_cover_banner(self, image_path: str):
        try:
            fragment = get_last_fragment()
            if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                return
            action_bar = fragment.getActionBar()
            if not action_bar:
                return

            # Capturar original uma vez
            try:
                if getattr(self, "_original_drawable", None) is None:
                    self._original_drawable = action_bar.getBackground()
                if getattr(self, "_original_color", None) is None:
                    from org.telegram.ui.ActionBar import Theme
                    self._original_color = Theme.getColor(Theme.key_actionBarDefault)
            except Exception:
                pass

            from android.graphics import BitmapFactory, Color
            from android.graphics.drawable import (
                Drawable,
                BitmapDrawable,
                GradientDrawable,
                LayerDrawable,
                ColorDrawable,
            )
            from android.view import Gravity
            from java import jarray, jint

            if not image_path:
                return

            bitmap = BitmapFactory.decodeFile(image_path)
            if not bitmap:
                return

            parent_activity = fragment.getParentActivity()
            if not parent_activity:
                return

            # Aplicar corte inteligente (crop) com viés superior para Stats.fm
            try:
                # Obter dimensões do ActionBar
                ab_w = int(action_bar.getWidth())
                ab_h = int(action_bar.getHeight())
                src_w = int(bitmap.getWidth())
                src_h = int(bitmap.getHeight())

                if src_w > 0 and src_h > 0 and ab_w > 0 and ab_h > 0:
                    from android.graphics import Bitmap, Canvas, Paint, Matrix

                    # Criar bitmap de destino com tamanho do ActionBar
                    target_bitmap = Bitmap.createBitmap(ab_w, ab_h, bitmap.getConfig())
                    canvas = Canvas(target_bitmap)
                    paint = Paint()
                    paint.setFilterBitmap(True)
                    paint.setAntiAlias(True)

                    # Calcular escala para cobrir toda a área
                    sx = float(ab_w) / float(src_w) if src_w > 0 else 1.0
                    sy = float(ab_h) / float(src_h) if src_h > 0 else 1.0
                    s = max(sx, sy)  # Escala máxima para garantir cobertura total

                    scaled_w = float(src_w) * s
                    scaled_h = float(src_h) * s

                    # Centralizar horizontalmente
                    dx = (float(ab_w) - scaled_w) / 2.0

                    # Definir viés vertical: Stats.fm usa viés superior (~18%), Last.fm permanece centralizado (50%)
                    try:
                        provider = int(self.get_setting("now_playing_provider", 0))  # 0 = Stats.fm, 1 = Last.fm
                    except Exception:
                        provider = 0
                    # Viés superior similar ao Nowfy (0.18) quando Stats.fm está ativo
                    top_bias_ratio = 0.18 if provider == 0 else 0.5
                    excess_h = scaled_h - float(ab_h)
                    if excess_h > 0:
                        dy = -(excess_h * top_bias_ratio)
                    else:
                        dy = (float(ab_h) - scaled_h) / 2.0

                    # Aplicar transformação
                    matrix = Matrix()
                    matrix.setScale(s, s)
                    matrix.postTranslate(dx, dy)
                    canvas.drawBitmap(bitmap, matrix, paint)

                    image_drawable = BitmapDrawable(parent_activity.getResources(), target_bitmap)
                else:
                    image_drawable = BitmapDrawable(parent_activity.getResources(), bitmap)
            except Exception as _ce:
                log(f"[ChatListCustomizer] Cover crop error: {_ce}")
                image_drawable = BitmapDrawable(parent_activity.getResources(), bitmap)

            image_drawable.setGravity(Gravity.FILL)

            try:
                base_color = getattr(self, "_original_color", None)
                if base_color is None:
                    from org.telegram.ui.ActionBar import Theme
                    base_color = Theme.getColor(Theme.key_actionBarDefault)
            except Exception:
                base_color = 0xFF222222

            try:
                gradient_colors = jarray(jint)([Color.TRANSPARENT, base_color])
                gradient = GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM, gradient_colors)
            except Exception:
                gradient = None

            scrim_drawable = ColorDrawable(0x4D000000)

            layers = [image_drawable, scrim_drawable]
            if gradient is not None:
                layers.append(gradient)

            # Montar array Java
            try:
                from java import jclass
                DrawableClass = jclass("android.graphics.drawable.Drawable")
                arr = jarray(DrawableClass)(layers)
                custom_drawable = LayerDrawable(arr)
            except Exception:
                # Fallback: usa apenas imagem
                custom_drawable = image_drawable

            def apply_background_task():
                try:
                    if get_last_fragment() == fragment:
                        from android.graphics import Color as _Color
                        action_bar.setBackgroundColor(_Color.TRANSPARENT)
                        action_bar.setBackgroundDrawable(custom_drawable)
                        self._banner_applied = True
                        # Resetar força de atualização após aplicar capa
                        try:
                            self._force_now_playing_update = False
                        except Exception:
                            pass
                except Exception as e:
                    log(f"[ChatListCustomizer] Apply banner error: {e}")

            run_on_ui_thread(apply_background_task, delay=50)
        except Exception as e:
            log(f"[ChatListCustomizer] Banner error: {e}")

    # Motion Themes: aplica banner no ActionBar (suporta GIF em Android 9+)
    def _apply_motion_theme_banner(self, image_path: str):
        try:
            fragment = get_last_fragment()
            if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                return
            action_bar = fragment.getActionBar()
            if not action_bar:
                return

            # Capturar original uma vez
            try:
                if getattr(self, "_original_drawable", None) is None:
                    self._original_drawable = action_bar.getBackground()
                if getattr(self, "_original_color", None) is None:
                    from org.telegram.ui.ActionBar import Theme
                    self._original_color = Theme.getColor(Theme.key_actionBarDefault)
            except Exception:
                pass

            if not image_path:
                return

            parent_activity = fragment.getParentActivity()
            if not parent_activity:
                return

            from android.view import Gravity
            from android.graphics.drawable import LayerDrawable, ColorDrawable
            from java import jarray

            # Fallback: usar WebView como camada para animar GIF/WebP sem Glide
            try:
                WebView = find_class("android.webkit.WebView")
                View = find_class("android.view.View")
                LayoutHelper = find_class("org.telegram.ui.Components.LayoutHelper")
                from android.graphics.drawable import GradientDrawable
                from android.graphics.drawable import ColorDrawable
                from android.graphics import Color

                def apply_webview():
                    try:
                        if WebView is None:
                            return
                        wv = getattr(self, "_motion_webview", None)
                        if wv is None:
                            wv = WebView(parent_activity)
                            try:
                                s = wv.getSettings()
                                s.setJavaScriptEnabled(True)
                                s.setSupportZoom(False)
                                s.setDomStorageEnabled(True)
                                s.setLoadWithOverviewMode(True)
                                s.setUseWideViewPort(True)
                                # Ajustes extras para garantir carregamento de GIF/WebP
                                try:
                                    s.setLoadsImagesAutomatically(True)
                                except Exception:
                                    pass
                                try:
                                    s.setAllowFileAccess(True)
                                    s.setAllowContentAccess(True)
                                except Exception:
                                    pass
                                try:
                                    WS = find_class("android.webkit.WebSettings")
                                    if WS is not None and hasattr(WS, "MIXED_CONTENT_ALWAYS_ALLOW"):
                                        s.setMixedContentMode(WS.MIXED_CONTENT_ALWAYS_ALLOW)
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            try:
                                wv.setBackgroundColor(0x00000000)
                                if View is not None and hasattr(View, "LAYER_TYPE_HARDWARE"):
                                    wv.setLayerType(View.LAYER_TYPE_HARDWARE, None)
                                try:
                                    from android.view import View as _View
                                    if hasattr(_View, "OVER_SCROLL_NEVER"):
                                        wv.setOverScrollMode(_View.OVER_SCROLL_NEVER)
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            try:
                                params = LayoutHelper.createFrame(-1, -1)
                            except Exception:
                                from android.widget import FrameLayout
                                params = FrameLayout.LayoutParams(-1, -1)
                            try:
                                action_bar.addView(wv, 0, params)
                            except Exception:
                                action_bar.addView(wv, params)
                            self._motion_webview = wv

                        # Carregar imagem como HTML com object-fit: cover
                        img_src = image_path
                        try:
                            if isinstance(img_src, str) and img_src.startswith("/"):
                                img_src = "file:///" + img_src
                        except Exception:
                            pass
                        try:
                            base_color = getattr(self, "_original_color", None)
                            if base_color is None:
                                from org.telegram.ui.ActionBar import Theme
                                base_color = Theme.getColor(Theme.key_actionBarDefault)
                        except Exception:
                            base_color = 0xFF222222
                        # Converter cor base para hex (#RRGGBB) e aplicar efeitos padrão (scrim + gradiente)
                        try:
                            rgb = base_color & 0x00FFFFFF
                            base_hex = "#%06X" % rgb
                        except Exception:
                            base_hex = "#222222"
                        html = f"""
                            <html><head><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/>
                            <style>
                            html,body{{margin:0;height:100%;background:transparent}}
                            .container{{position:relative;width:100%;height:100%}}
                            .img{{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}}
                            .scrim{{position:absolute;inset:0;background:rgba(0,0,0,0.30);pointer-events:none}}
                            .gradient{{position:absolute;inset:0;background:linear-gradient(to bottom, rgba(0,0,0,0), {base_hex});pointer-events:none}}
                            </style>
                            </head><body>
                              <div class=\"container\">
                                <img class=\"img\" src=\"{img_src}\" />
                                <div class=\"scrim\"></div>
                                <div class=\"gradient\"></div>
                              </div>
                            </body></html>
                        """
                        try:
                            wv.loadDataWithBaseURL("file:///", html, "text/html", "utf-8", None)
                        except Exception:
                            wv.loadData(html, "text/html", "utf-8")
                        try:
                            wv.resumeTimers()
                        except Exception:
                            pass

                        try:
                            from android.graphics import Color as _Color
                            action_bar.setBackgroundColor(_Color.TRANSPARENT)
                        except Exception:
                            pass
                        self._banner_applied = True
                    except Exception as _e:
                        log(f"[ChatListCustomizer] WebView apply error: {_e}")

                run_on_ui_thread(apply_webview, delay=50)
                return
            except Exception as wve:
                log(f"[ChatListCustomizer] WebView fallback setup error: {wve}")

            # Detectar GIF pelo sufixo
            is_gif = False
            try:
                is_gif = str(image_path).lower().endswith(".gif")
            except Exception:
                is_gif = False

            animated_drawable = None
            if is_gif:
                try:
                    # Android 9+ (API 28) - AnimatedImageDrawable
                    from android.graphics import ImageDecoder
                    from android.graphics.drawable import AnimatedImageDrawable
                    from java.io import File as JFile
                    src = ImageDecoder.createSource(JFile(image_path))
                    drawable = ImageDecoder.decodeDrawable(src)
                    # Iniciar animação quando suportado
                    if "AnimatedImageDrawable" in drawable.getClass().getName():
                        try:
                            drawable.setGravity(Gravity.FILL)
                        except Exception:
                            pass
                        try:
                            # Repetição infinita quando suportado
                            if hasattr(drawable, "setRepeatCount"):
                                try:
                                    drawable.setRepeatCount(-1)
                                except Exception:
                                    pass
                            drawable.start()
                            # Guardar referência para evitar GC e permitir stop
                            self._motion_animated_drawable = drawable
                        except Exception:
                            pass
                        animated_drawable = drawable
                except Exception as _gif_e:
                    log(f"[ChatListCustomizer] GIF decode fallback: {_gif_e}")

            custom_drawable = None
            if animated_drawable is not None:
                # Camadas: GIF + scrim + gradiente suave
                try:
                    from android.graphics import Color
                    from android.graphics.drawable import GradientDrawable
                    base_color = getattr(self, "_original_color", None)
                    if base_color is None:
                        from org.telegram.ui.ActionBar import Theme
                        base_color = Theme.getColor(Theme.key_actionBarDefault)
                    gradient = GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM, jarray(int)([Color.TRANSPARENT, base_color]))
                except Exception:
                    gradient = None

                scrim_drawable = ColorDrawable(0x4D000000)
                layers = [animated_drawable, scrim_drawable]
                if gradient is not None:
                    layers.append(gradient)

                try:
                    from java import jclass
                    DrawableClass = jclass("android.graphics.drawable.Drawable")
                    arr = jarray(DrawableClass)(layers)
                    custom_drawable = LayerDrawable(arr)
                except Exception:
                    custom_drawable = animated_drawable
            else:
                # Fallback para imagem estática com o mesmo crop inteligente do Now Playing
                from android.graphics import BitmapFactory, Color
                from android.graphics.drawable import (
                    BitmapDrawable,
                    GradientDrawable,
                )
                bitmap = BitmapFactory.decodeFile(image_path)
                if not bitmap:
                    return
                action_w = int(action_bar.getWidth())
                action_h = int(action_bar.getHeight())
                src_w = int(bitmap.getWidth())
                src_h = int(bitmap.getHeight())
                try:
                    if src_w > 0 and src_h > 0 and action_w > 0 and action_h > 0:
                        from android.graphics import Bitmap, Canvas, Paint, Matrix
                        target = Bitmap.createBitmap(action_w, action_h, bitmap.getConfig())
                        canvas = Canvas(target)
                        paint = Paint()
                        paint.setFilterBitmap(True)
                        paint.setAntiAlias(True)
                        sx = float(action_w) / float(src_w)
                        sy = float(action_h) / float(src_h)
                        s = max(sx, sy)
                        scaled_w = float(src_w) * s
                        scaled_h = float(src_h) * s
                        dx = (float(action_w) - scaled_w) / 2.0
                        # Viés superior 18% (igual Stats.fm)
                        top_bias_ratio = 0.18
                        excess_h = scaled_h - float(action_h)
                        dy = -(excess_h * top_bias_ratio) if excess_h > 0 else (float(action_h) - scaled_h) / 2.0
                        matrix = Matrix()
                        matrix.setScale(s, s)
                        matrix.postTranslate(dx, dy)
                        canvas.drawBitmap(bitmap, matrix, paint)
                        image_drawable = BitmapDrawable(parent_activity.getResources(), target)
                    else:
                        image_drawable = BitmapDrawable(parent_activity.getResources(), bitmap)
                except Exception as _ce:
                    log(f"[ChatListCustomizer] Motion crop error: {_ce}")
                    image_drawable = BitmapDrawable(parent_activity.getResources(), bitmap)

                image_drawable.setGravity(Gravity.FILL)
                try:
                    base_color = getattr(self, "_original_color", None)
                    if base_color is None:
                        from org.telegram.ui.ActionBar import Theme
                        base_color = Theme.getColor(Theme.key_actionBarDefault)
                except Exception:
                    base_color = 0xFF222222
                try:
                    from android.graphics.drawable import GradientDrawable
                    gradient = GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM, jarray(int)([Color.TRANSPARENT, base_color]))
                except Exception:
                    gradient = None
                scrim = ColorDrawable(0x4D000000)
                layers = [image_drawable, scrim]
                if gradient is not None:
                    layers.append(gradient)
                try:
                    from java import jclass
                    DrawableClass = jclass("android.graphics.drawable.Drawable")
                    arr = jarray(DrawableClass)(layers)
                    custom_drawable = LayerDrawable(arr)
                except Exception:
                    custom_drawable = image_drawable

            def apply_bg():
                try:
                    if get_last_fragment() == fragment:
                        from android.graphics import Color as _Color
                        action_bar.setBackgroundColor(_Color.TRANSPARENT)
                        action_bar.setBackgroundDrawable(custom_drawable)
                        self._banner_applied = True
                        # Resetar força de atualização para evitar alternâncias desnecessárias
                        try:
                            self._force_now_playing_update = False
                        except Exception:
                            pass
                        # Se for animado, garantir que está rodando
                        try:
                            a = getattr(self, "_motion_animated_drawable", None)
                            if a is not None:
                                a.start()
                                # Forçar invalidação periódica do ActionBar para manter animação fluida
                                try:
                                    self._schedule_motion_animation_tick()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                except Exception as e:
                    log(f"[ChatListCustomizer] Apply Motion Theme error: {e}")

            run_on_ui_thread(apply_bg, delay=50)
        except Exception as e:
            log(f"[ChatListCustomizer] Motion Theme banner error: {e}")

    def _schedule_motion_animation_tick(self):
        """Agenda invalidações periódicas do ActionBar para atualizar frames do GIF.
        Necessário em alguns dispositivos onde o background não redesenha automaticamente.
        """
        try:
            # Evitar múltiplas agendas concorrentes
            if getattr(self, "_motion_anim_tick_scheduled", False):
                return
            self._motion_anim_tick_scheduled = True

            def _tick():
                try:
                    # Marcar como não agendado antes de re-agendar
                    self._motion_anim_tick_scheduled = False
                    fragment = get_last_fragment()
                    if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                        return
                    action_bar = fragment.getActionBar()
                    if not action_bar:
                        return
                    # Se ainda existe drawable animado e a feature está ativa, invalidar e continuar
                    a = getattr(self, "_motion_animated_drawable", None)
                    if a is not None and bool(self.get_setting("motion_theme_enabled", False)):
                        try:
                            action_bar.invalidate()
                        except Exception:
                            pass
                        # Re-agendar próximo tick
                        try:
                            run_on_ui_thread(_tick, delay=66)
                        except Exception:
                            pass
                except Exception:
                    # Em caso de erro, não re-agendar para evitar loop
                    pass

            # Agendar primeiro tick
            run_on_ui_thread(_tick, delay=66)
        except Exception as e:
            log(f"[ChatListCustomizer] Motion anim tick error: {e}")

    def _restore_action_bar_background(self):
        try:
            fragment = get_last_fragment()
            if not fragment or "DialogsActivity" not in fragment.getClass().getName():
                return
            action_bar = fragment.getActionBar()
            if not action_bar:
                return
            # Remover camadas em UI thread
            def cleanup_ui():
                try:
                    iv = getattr(self, "_motion_glide_image_view", None)
                    if iv is not None and iv.getParent() == action_bar:
                        try:
                            action_bar.removeView(iv)
                        except Exception:
                            pass
                    self._motion_glide_image_view = None
                    sv = getattr(self, "_motion_scrim_view", None)
                    if sv is not None and sv.getParent() == action_bar:
                        try:
                            action_bar.removeView(sv)
                        except Exception:
                            pass
                    self._motion_scrim_view = None
                    gv = getattr(self, "_motion_gradient_view", None)
                    if gv is not None and gv.getParent() == action_bar:
                        try:
                            action_bar.removeView(gv)
                        except Exception:
                            pass
                    self._motion_gradient_view = None
                    # Remover WebView se existir
                    wv = getattr(self, "_motion_webview", None)
                    if wv is not None and wv.getParent() == action_bar:
                        try:
                            action_bar.removeView(wv)
                        except Exception:
                            pass
                    self._motion_webview = None
                except Exception:
                    pass

            try:
                run_on_ui_thread(cleanup_ui, delay=0)
            except Exception:
                cleanup_ui()
            # Parar animação de Motion Theme se estiver ativa
            try:
                a = getattr(self, "_motion_animated_drawable", None)
                if a is not None and hasattr(a, "stop"):
                    try:
                        a.stop()
                    except Exception:
                        pass
                self._motion_animated_drawable = None
                # Cancelar agendamento de invalidações
                self._motion_anim_tick_scheduled = False
            except Exception:
                pass
            orig_draw = getattr(self, "_original_drawable", None)
            orig_color = getattr(self, "_original_color", None)
            def restore_bg():
                try:
                    if orig_draw is not None:
                        action_bar.setBackgroundDrawable(orig_draw)
                    if orig_color is not None:
                        action_bar.setBackgroundColor(orig_color)
                except Exception:
                    pass
            try:
                run_on_ui_thread(restore_bg, delay=0)
            except Exception:
                restore_bg()
            self._banner_applied = False
        except Exception as e:
            log(f"[ChatListCustomizer] Restore banner error: {e}")

    def _get_keep_cover_url(self):
        """Obtém URL da capa para Keep Cover (independente do Now Playing)"""
        try:
            keep_cover = bool(self.get_setting("keep_cover_when_not_playing", False))
            if not keep_cover:
                return None
            
            last_cover = getattr(self, "_last_track_image", None)
            return last_cover
        except Exception as e:
            log(f"[ChatListCustomizer] Keep Cover error: {e}")
            return None

    def _get_motion_theme_url(self):
        """Retorna a URL do Motion Theme selecionado (inclui presets e Custom)."""
        try:
            idx = int(self.get_setting("motion_theme", 0))
            if idx == 0:
                return "https://giffiles.alphacoders.com/223/223415.gif"
            elif idx == 1:
                return "https://www.icegif.com/wp-content/uploads/2022/04/icegif-1214.gif"
            elif idx == 2:
                return "https://wallpapers-clan.com/wp-content/uploads/2024/08/hxh-killua-dark-blue-gif-desktop-wallpaper-preview.gif"
            elif idx == 3:
                # Rainy Night
                return "https://i.pinimg.com/originals/f8/25/1e/f8251e2481934013421b0bb62570ebcc.gif"
            elif idx == 4:
                # Flowing
                return "https://cdn.dribbble.com/userupload/42125332/file/original-18586296fd8b159cd1026cc48d55aaa5.gif"
            elif idx == 5:
                # Burst
                return "https://i.pinimg.com/originals/da/99/65/da996519e3270d5e338d4f66de5478c6.gif"
            elif idx == 6:
                # Lofi Chill Sreet
                return "https://64.media.tumblr.com/e8052aa7ed30b7472b24dca9a04d6401/tumblr_p5qc30HIn51x5p4g9o1_1280.gif"
            elif idx == 7:
                # Custom URL
                url = str(self.get_setting("motion_theme_custom_url", "")).strip()
                return url if url else None
            return None
        except Exception as e:
            log(f"[ChatListCustomizer] Motion Theme URL error: {e}")
            return None

    def _handle_motion_theme_change(self, value):
        """Ativa/Desativa Motion Themes, mostra bulletins e atualiza UI."""
        try:
            enabled = bool(value)
            self.set_setting("motion_theme_enabled", enabled)
            self._apply_settings()
            # Forçar atualização imediata para aplicar/remover banner
            self._force_now_playing_update = True
            self.reload_settings()

            # Mostrar bulletins
            try:
                current_fragment = get_last_fragment()
                if enabled:
                    run_on_ui_thread(lambda: BulletinHelper.show_success(tr("bulletin_motion_themes_enabled"), current_fragment))
                else:
                    run_on_ui_thread(lambda: BulletinHelper.show_info(tr("bulletin_motion_themes_disabled"), current_fragment))
            except Exception as bulletin_error:
                log(f"[ChatListCustomizer] Erro ao mostrar bulletin Motion Themes: {bulletin_error}")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao lidar com toggle Motion Themes: {e}")

    def _handle_motion_theme_selection_change(self, idx: int):
        """Aplica imediatamente o Motion Theme escolhido, mostra bulletin de sucesso e oferece restart."""
        try:
            self.set_setting("motion_theme", int(idx))
            self._apply_settings()

            # Mostrar sucesso com o nome do tema selecionado
            try:
                labels = [
                    tr("motion_theme_sl_jinwoo"),
                    tr("motion_theme_dbs_goku"),
                    tr("motion_theme_hxh_killua"),
                    tr("motion_theme_rainy_night"),
                    tr("motion_theme_flowing"),
                    tr("motion_theme_burst"),
                    tr("motion_theme_lofi"),
                    tr("motion_theme_custom"),
                ]
                sel_label = labels[int(idx)] if 0 <= int(idx) < len(labels) else tr("motion_themes_label")
                fragment = get_last_fragment()
                run_on_ui_thread(lambda: BulletinHelper.show_success(f"{tr('motion_themes_label')}: {sel_label}", fragment))
            except Exception:
                pass

            # Forçar ciclo de atualização e aplicar imediatamente se não houver capa ativa
            self._force_now_playing_update = True

            mt_enabled = bool(self.get_setting("motion_theme_enabled", False))
            cover_present = getattr(self, "_current_cover_url", None) is not None
            if mt_enabled and not cover_present:
                theme_url = self._get_motion_theme_url()
                if theme_url:
                    self._current_motion_theme_url = theme_url
                    img_path = self._download_image_to_cache(theme_url)
                    if img_path:
                        self._apply_motion_theme_banner(img_path)

            # Mostrar dialog de restart para aplicar o tema corretamente
            self._show_restart_dialog()

            # Atualizar a UI de configurações
            self.reload_settings()
        except Exception:
            log_exception("_handle_motion_theme_selection_change")

    def _get_current_cover_url(self):
        """Obtém URL de capa atual quando Now Playing ativo (apenas Last.fm/Stats.fm quando disponível)"""
        try:
            log("[ChatListCustomizer] _get_current_cover_url chamado")
            np_enabled = bool(self.get_setting("now_playing_enabled", False))
            log(f"[ChatListCustomizer] Now Playing enabled: {np_enabled}")
            if not np_enabled:
                log("[ChatListCustomizer] Now Playing desabilitado, não buscando capa")
                return None
            provider = int(self.get_setting("now_playing_provider", 0))
            log(f"[ChatListCustomizer] Provider Now Playing: {provider}")
            if provider == 1:
                # Last.fm
                last_user = str(self.get_setting("lastfm_username", "")).strip()
                last_key = str(self.get_setting("lastfm_api_key", "")).strip()
                log(f"[ChatListCustomizer] Last.fm - User: {last_user}, Key: {'***' if last_key else 'vazia'}")
                if not (last_user and last_key):
                    log("[ChatListCustomizer] Last.fm não configurado corretamente")
                    return None
                track = self._get_lastfm_current_track(last_user, last_key)
                log(f"[ChatListCustomizer] Last.fm track data: {track}")
                if track:
                    if track.get('image_url'):
                        # Melhorar qualidade da imagem substituindo tamanhos pequenos por maiores
                        img_url = str(track.get('image_url'))
                        log(f"[ChatListCustomizer] Last.fm image URL original: {img_url}")
                        if "-64." in img_url:
                            img_url = img_url.replace("-64.", "-300.")
                        log(f"[ChatListCustomizer] Last.fm image URL final: {img_url}")
                        return img_url
                    else:
                        log("[ChatListCustomizer] Last.fm não retornou image_url, tentando YouTube fallback")
                        # Fallback YouTube: tentar thumbnail pela busca do vídeo
                        try:
                            yt = self._get_youtube_thumbnail_for_song(track.get('artist'), track.get('title'))
                            log(f"[ChatListCustomizer] Last.fm YouTube fallback: {yt}")
                            if yt:
                                log(f"[ChatListCustomizer] YouTube fallback encontrado para Last.fm: {yt}")
                                return yt
                            else:
                                log("[ChatListCustomizer] YouTube fallback não encontrou thumbnail")
                                # Tentar fallback alternativo com diferentes termos de busca
                                try:
                                    # Tentar busca com apenas o título da música
                                    yt_alt = self._get_youtube_thumbnail_for_song(None, track.get('title'))
                                    log(f"[ChatListCustomizer] Last.fm YouTube fallback alternativo (apenas título): {yt_alt}")
                                    if yt_alt:
                                        log(f"[ChatListCustomizer] YouTube fallback alternativo encontrado: {yt_alt}")
                                        return yt_alt
                                except Exception as e2:
                                    log(f"[ChatListCustomizer] Erro no YouTube fallback alternativo: {e2}")
                        except Exception as e:
                            log(f"[ChatListCustomizer] Last.fm YouTube fallback erro: {e}")
                            pass
            else:
                # Stats.fm: usar a função existente que já retorna image_url corretamente
                stats_user = str(self.get_setting("statsfm_username", "")).strip()
                log(f"[ChatListCustomizer] Stats.fm - User: {stats_user}")
                if not stats_user:
                    log("[ChatListCustomizer] Stats.fm não configurado corretamente")
                    return None
                data = None
                try:
                    # Reutiliza chamada existente que já retorna image_url
                    data = self._get_statsfm_current_track(stats_user)
                    log(f"[ChatListCustomizer] Stats.fm track data: {data}")
                except Exception as e:
                    log(f"[ChatListCustomizer] Stats.fm erro ao buscar track: {e}")
                    data = None
                if data and data.get('image_url'):
                    # A função _get_statsfm_current_track já retorna image_url corretamente
                    img_url = str(data.get('image_url'))
                    log(f"[ChatListCustomizer] Stats.fm image URL encontrada: {img_url}")
                    return img_url
                elif data:
                    # Fallback: tentar thumbnail do YouTube usando artista + título
                    try:
                        artist = data.get('artist')
                        title = data.get('title')
                        log(f"[ChatListCustomizer] Stats.fm YouTube fallback - Artist: {artist}, Title: {title}")
                        if artist and title:
                            yt = self._get_youtube_thumbnail_for_song(artist, title)
                            log(f"[ChatListCustomizer] Stats.fm YouTube fallback result: {yt}")
                            if yt:
                                return yt
                    except Exception as e:
                        log(f"[ChatListCustomizer] Stats.fm YouTube fallback erro: {e}")
                        pass
            log("[ChatListCustomizer] Nenhuma capa encontrada")
            return None
        except Exception as e:
            log(f"[ChatListCustomizer] Erro geral em _get_current_cover_url: {e}")
            return None

    def _get_youtube_thumbnail_for_song(self, artist: str, title: str):
        """Funcionalidade exclusiva do Nowfy - Obtém thumbnail do YouTube com base em 'artist - title' (sem API oficial).
        Aborda página de resultados e extrai o primeiro videoId encontrado.
        """
        try:
            if not artist or not title:
                return None
            import urllib.parse
            query = f"{artist} - {title}"
            cache = getattr(self, "_yt_thumb_cache", {})
            if query in cache:
                return cache.get(query)
            q = urllib.parse.quote_plus(query)
            url = f"https://www.youtube.com/results?search_query={q}"
            r = requests.get(url, timeout=6, headers={"User-Agent": "Mozilla/5.0"})
            if r.status_code != 200:
                return None
            text = r.text or ""
            vid = None
            for marker in ["\"videoId\":\"", "\"videoId\": \""]:
                i = text.find(marker)
                if i != -1:
                    s = i + len(marker)
                    e = text.find("\"", s)
                    if e != -1:
                        vid = text[s:e]
                        break
            if not vid:
                return None
            thumb = f"https://i.ytimg.com/vi/{vid}/hqdefault.jpg"
            cache[query] = thumb
            self._yt_thumb_cache = cache
            return thumb
        except Exception:
            return None

    def _restore_chat_list_title(self):
        """Restaura o título original usando strings do sistema"""
        try:
            orig = self.get_setting("_original_title", "")
            if not orig:
                # Usar string do sistema como fallback
                orig = self._get_default_chat_list_title()
            self._set_chat_list_title(orig)
            log(f"[ChatListCustomizer] Título original restaurado: {orig}")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao restaurar título: {e}")

    def _toggle_customizer(self, should_be_active):
        """Ativa/desativa o customizador do título baseado se há algo para mostrar"""
        try:
            log(f"[ChatListCustomizer] Toggle customizer: {should_be_active}")
            
            if should_be_active:
                # Capturar título original quando habilitar
                try:
                    fragment = get_last_fragment()
                    if fragment and "DialogsActivity" in fragment.getClass().getName():
                        action_bar = fragment.getActionBar()
                        if action_bar and not self.get_setting("_original_title", ""):
                            try:
                                current_title = str(action_bar.getTitle())
                                if current_title:
                                    self.set_setting("_original_title", current_title)
                                    log(f"[ChatListCustomizer] Título original capturado: {current_title}")
                            except Exception as e:
                                log(f"[ChatListCustomizer] Erro ao capturar título: {e}")
                except Exception:
                    pass
                
                # Aplicar título customizado imediatamente
                final_title = self._build_final_title()
                if final_title:
                    self._set_chat_list_title(final_title)
                
                # Iniciar worker de refresh periódico (15s)
                self._start_refresh_worker(15)
                    
            else:
                # Parar worker e restaurar título original quando desabilitar
                self._stop_refresh_worker()
                self._restore_chat_list_title()
                # Restaurar banner caso ativo
                try:
                    self._restore_action_bar_background()
                except Exception:
                    pass
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no toggle: {e}")

    def _apply_settings(self):
        """Aplica configurações - chamado quando algo muda"""
        try:
            # Verificar se deve estar ativo baseado se há algo para mostrar
            final_title = self._build_final_title()
            # Forçar ativação quando Now Playing estiver habilitado e configurado
            try:
                np_enabled = bool(self.get_setting("now_playing_enabled", False))
                provider = int(self.get_setting("now_playing_provider", 0))
                stats_user = str(self.get_setting("statsfm_username", "")).strip()
                last_user = str(self.get_setting("lastfm_username", "")).strip()
                last_key = str(self.get_setting("lastfm_api_key", "")).strip()
                np_configured = (provider == 0 and bool(stats_user)) or (provider == 1 and bool(last_user) and bool(last_key))
                
                # Aplicar capa imediatamente se Now Playing estiver ativado e show_cover também
                show_cover = bool(self.get_setting("now_playing_show_cover", True))
                if np_enabled and np_configured and show_cover:
                    cover_url = self._get_current_cover_url()
                    if cover_url:
                        self._current_cover_url = cover_url
                        img_path = self._download_image_to_cache(cover_url)
                        if img_path:
                            self._apply_chat_list_cover_banner(img_path)
                else:
                    # Sem capa imediata de Now Playing: tentar aplicar Motion Theme se habilitado
                    mt_enabled = bool(self.get_setting("motion_theme_enabled", False))
                    if mt_enabled:
                        theme_url = self._get_motion_theme_url()
                        if theme_url:
                            self._current_motion_theme_url = theme_url
                            img_path = self._download_image_to_cache(theme_url)
                            if img_path:
                                self._apply_motion_theme_banner(img_path)
            except Exception as e:
                log(f"[ChatListCustomizer] Cover immediate apply error: {e}")
                np_enabled, np_configured = False, False
            
            # Manter worker ativo também quando Motion Theme estiver habilitado
            try:
                mt_enabled = bool(self.get_setting("motion_theme_enabled", False))
            except Exception:
                mt_enabled = False
            
            should_be_active = (final_title is not None) or (np_enabled and np_configured) or mt_enabled
            
            log(f"[ChatListCustomizer] Should be active: {should_be_active}, final_title: {final_title}")
            self._toggle_customizer(should_be_active)
                
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao aplicar configurações: {e}")
    
    def _start_refresh_worker(self, interval_sec=10):
        """Inicia worker de refresh periódico"""
        try:
            # Parar worker anterior
            self._stop_refresh_worker()
            
            import threading
            import time
            
            # Inicializar caches e variáveis de estado
            if not hasattr(self, "_lastfm_cache_data"):
                self._lastfm_cache_data = None
                self._lastfm_cache_time = 0
                
            # Inicializar variáveis de Now Playing
            if not hasattr(self, "_now_playing_data"):
                self._now_playing_data = None
                
            if not hasattr(self, "_np_toggle_state"):
                self._np_toggle_state = 0
            
            # Alternância geral de frames (Weather/Greeting)
            if not hasattr(self, "_alt_index"):
                self._alt_index = 0
            if not hasattr(self, "_alt_last_switch"):
                self._alt_last_switch = 0
            alt_interval = 4  # segundos
                
            # Forçar atualização inicial
            self._force_now_playing_update = True
                
            if not hasattr(self, "_statsfm_cache_data"):
                self._statsfm_cache_data = None
                self._statsfm_cache_time = 0
                
            # Intervalo de atualização do Now Playing (em segundos)
            now_playing_update_interval = 2  # Reduzido para atualização mais frequente
            
            stop_event = threading.Event()
            self._refresh_worker_stop = stop_event
            
            # Inicializar cache para APIs de música
            self._lastfm_cache_time = 0
            self._lastfm_cache_data = None
            self._statsfm_cache_time = 0
            self._statsfm_cache_data = None
            # Inicializar variáveis para controle de atualização do Now Playing
            self._last_track_title = ""
            self._last_track_artist = ""
            self._last_track_image = None
            self._force_now_playing_update = True
            # Inicializar dados do Now Playing
            self._now_playing_data = None
            self._prev_now_playing_data = None
            self._prev_np_enabled = None
            self._np_toggle_state = 0
            
            def _run():
                try:
                    # Intervalo de atualização para Now Playing (mais rápido que o worker principal)
                    now_playing_update_interval = 2  # segundos (reduzido para atualização mais frequente)
                    now_playing_last_update = 0
                    
                    while not stop_event.is_set():
                        current_time = time.time()
                        
                        # Alternar frames de Weather/Greeting suavemente
                        try:
                            if (current_time - getattr(self, "_alt_last_switch", 0)) >= alt_interval:
                                self._alt_index = int(getattr(self, "_alt_index", 0)) + 1
                                self._alt_last_switch = current_time
                        except Exception:
                            self._alt_index = 0

                        # Verificar se Now Playing precisa ser atualizado
                        try:
                            np_enabled = bool(self.get_setting("now_playing_enabled", False))
                            prev_np_enabled = getattr(self, "_prev_np_enabled", None)
                            
                            # Detectar quando Now Playing foi ativado/desativado
                            if np_enabled != prev_np_enabled:
                                log(f"[ChatListCustomizer] Now Playing estado mudou: {prev_np_enabled} -> {np_enabled}")
                                self._force_now_playing_update = True
                                self._prev_np_enabled = np_enabled
                                # Limpar dados anteriores quando desativado
                                if not np_enabled:
                                    self._now_playing_data = None
                                    self._prev_now_playing_data = None
                            
                            if np_enabled and (current_time - now_playing_last_update) >= now_playing_update_interval:
                                # Alternar estado de Now Playing apenas para estilos que alternam
                                np_style = int(self.get_setting("now_playing_style", 0))
                                if np_style == 0:
                                    current = int(getattr(self, "_np_toggle_state", 0))
                                    self._np_toggle_state = 1 if current == 0 else 0
                                else:
                                    # Reset alternância para estilos que não alternam
                                    self._np_toggle_state = 0
                                now_playing_last_update = current_time
                            elif not np_enabled:
                                self._np_toggle_state = 0
                        except Exception:
                            self._np_toggle_state = 0
                            
                        # Agendamento de Smart Messages: mostrar em janelas aleatórias, não contínuo (Beta)
                        try:
                            sel = int(self.get_setting("smart_messages_enabled", 0))  # Default desativado
                            if sel == 1:  # Ativado
                                now = int(time.time())
                                next_ts = int(getattr(self, "_smart_next_show_ts", 0))
                                until_ts = int(getattr(self, "_smart_show_until_ts", 0))
                                in_window = (now >= next_ts) and (now < until_ts) if (next_ts and until_ts) else False

                                if not in_window:
                                    # Janela inicial imediata quando habilitado pela primeira vez
                                    first_time = (not next_ts) and (not until_ts)
                                    dur_sec = random.randint(20, 45)
                                    if first_time:
                                        self._smart_next_show_ts = now
                                        self._smart_show_until_ts = now + dur_sec
                                        self._smart_toggle_state = 1
                                    else:
                                        # Próximas janelas: entre 3–10min, duração 20–45s
                                        gap_min = random.randint(3, 10)
                                        self._smart_next_show_ts = now + (gap_min * 60)
                                        self._smart_show_until_ts = self._smart_next_show_ts + dur_sec
                                        self._smart_toggle_state = 0
                                else:
                                    # Dentro da janela, habilitar frase
                                    self._smart_toggle_state = 1
                            else:
                                # Quando desativado, garantir que não exiba mensagens
                                self._smart_toggle_state = 0
                                self._smart_next_show_ts = 0
                                self._smart_show_until_ts = 0
                        except Exception as e:
                            log(f"[ChatListCustomizer] Smart Messages error: {e}")
                            self._smart_toggle_state = 0
                            
                        # Verificar se deve aplicar título baseado se há algo para mostrar
                        final_title = self._build_final_title()
                        should_be_active = final_title is not None
                        
                        if should_be_active:
                            # Tentar aplicar título
                            fragment = get_last_fragment()
                            if fragment and "DialogsActivity" in fragment.getClass().getName():
                                # Verificar título atual
                                action_bar = fragment.getActionBar()
                                if action_bar:
                                    try:
                                        current_title = str(action_bar.getTitle())
                                        # Aplicar baseado na configuração Fix Title
                                        fix_title = self.get_setting("fix_title", False)
                                        if fix_title or current_title != final_title:
                                            self._set_chat_list_title(final_title)
                                            if fix_title:
                                                log(f"[ChatListCustomizer] Título fixado aplicado: {final_title}")
                                    except Exception:
                                        self._set_chat_list_title(final_title)

                        # Aplicar/atualizar capa do ActionBar
                        try:
                            show_cover = bool(self.get_setting("now_playing_show_cover", True))
                            np_enabled = bool(self.get_setting("now_playing_enabled", False))
                            keep_cover_enabled = bool(self.get_setting("keep_cover_when_not_playing", False))
                            
                            cover_url = None
                            
                            # Prioridade 1: Now Playing ativo com show_cover
                            if show_cover and np_enabled:
                                # Consultar Now Playing sem reimpor refresh do Motion Theme
                                log("[ChatListCustomizer] Buscando capa do Now Playing...")
                                cover_url = self._get_current_cover_url()
                                log(f"[ChatListCustomizer] Capa retornada: {cover_url}")
                                if cover_url:
                                    # Armazenar a última capa para "Keep Cover"
                                    self._last_track_image = cover_url
                            
                            # Prioridade 2: Keep Cover (apenas capa, sem texto)
                            if not cover_url and keep_cover_enabled:
                                cover_url = self._get_keep_cover_url()
                            
                            # Aplicar capa se houver
                            if cover_url:
                                prev_cover = getattr(self, "_current_cover_url", None)
                                force_update = getattr(self, "_force_now_playing_update", False)
                                
                                if cover_url != prev_cover or force_update:
                                    self._current_cover_url = cover_url
                                    img_path = self._download_image_to_cache(cover_url)
                                    if img_path:
                                        self._apply_chat_list_cover_banner(img_path)
                                        log(f"[ChatListCustomizer] Capa aplicada: {cover_url}")
                                        # Limpar flag de força após aplicar
                                        self._force_now_playing_update = False
                            else:
                                # Sem capa de Now Playing: verificar se deve remover capa e aplicar Motion Theme
                                prev_cover = getattr(self, "_current_cover_url", None)
                                if prev_cover:
                                    log("[ChatListCustomizer] Música parou, removendo capa do ActionBar")
                                    self._current_cover_url = None
                                    self._remove_chat_list_cover_banner()
                                
                                # Sem capa de Now Playing: tentar aplicar Motion Theme se habilitado
                                mt_enabled = bool(self.get_setting("motion_theme_enabled", False))
                                if mt_enabled:
                                    theme_url = self._get_motion_theme_url()
                                    if theme_url:
                                        prev_theme = getattr(self, "_current_motion_theme_url", None)
                                        # Não re-aplicar em loop: só quando mudar URL ou primeira aplicação
                                        if theme_url != prev_theme or not getattr(self, "_banner_applied", False):
                                            self._current_motion_theme_url = theme_url
                                            img_path = self._download_image_to_cache(theme_url)
                                            if img_path:
                                                self._apply_motion_theme_banner(img_path)
                                                log(f"[ChatListCustomizer] Motion Theme aplicado (música parou): {theme_url}")
                                            else:
                                                log(f"[ChatListCustomizer] Motion Theme falhou ao baixar: {theme_url}")
                                        else:
                                            log(f"[ChatListCustomizer] Motion Theme já está aplicado: {theme_url}")
                                    else:
                                        # Habilitado mas sem URL: restaurar
                                        if getattr(self, "_banner_applied", False):
                                            log("[ChatListCustomizer] Motion Theme sem URL, restaurando ActionBar")
                                            self._current_cover_url = None
                                            self._current_motion_theme_url = None
                                            self._restore_action_bar_background()
                                else:
                                    # Desabilitado: restaurar se não há capa
                                    if getattr(self, "_banner_applied", False):
                                        log("[ChatListCustomizer] Nenhuma funcionalidade ativa, restaurando ActionBar")
                                        self._current_cover_url = None
                                        self._current_motion_theme_url = None
                                        self._restore_action_bar_background()
                        except Exception as _e:
                            log(f"[ChatListCustomizer] Cover update error: {_e}")
                        
                        # Aguardar próximo ciclo (suporta sub-segundos para estilo Digitando)
                        try:
                            fix_title = self.get_setting("fix_title", False)
                            np_enabled = bool(self.get_setting("now_playing_enabled", False))
                            np_style = int(self.get_setting("now_playing_style", 0))
                            
                            # Lógica inteligente de intervalos baseada no estado
                            current_np_data = getattr(self, "_now_playing_data", None)
                            prev_np_data = getattr(self, "_prev_now_playing_data", None)
                            
                            # Detectar mudança de estado (tocando/parado) para forçar atualização
                            if current_np_data != prev_np_data:
                                log(f"[ChatListCustomizer] Mudança de estado detectada: {prev_np_data} -> {current_np_data}")
                                self._force_now_playing_update = True
                                self._prev_now_playing_data = current_np_data
                            
                            if np_style == 1:
                                # Estilo Digitando: intervalo muito curto
                                cycle_secs = 0.06
                            elif np_enabled and current_np_data:
                                # Música tocando: atualização rápida (1.5s)
                                cycle_secs = 1.5
                            elif np_enabled and not current_np_data:
                                # Música parada: atualização mais rápida ainda (1s) para detectar quando voltar
                                cycle_secs = 1.0
                            else:
                                # Modo normal: usar intervalo configurado ou padrão
                                base_secs = float(interval_sec) if interval_sec and interval_sec > 0 else 10.0
                                cycle_secs = 2.0 if fix_title else base_secs
                            
                            # Log do intervalo para depuração
                            if np_enabled:
                                state = "playing" if current_np_data else "stopped"
                                log(f"[ChatListCustomizer] Refresh interval: {cycle_secs}s (NP: {state})")
                            
                            # Espera com possibilidade de interrupção
                            if stop_event.wait(cycle_secs):
                                break
                        except Exception:
                            if stop_event.wait(15.0):
                                break
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro no worker: {e}")
            
            t = threading.Thread(target=_run, name="ChatListCustomizerRefresh", daemon=True)
            self._refresh_worker_thread = t
            t.start()
            

            fix_title = self.get_setting("fix_title", False)
            if fix_title:
                log("[ChatListCustomizer] Worker de refresh iniciado (modo fixo - 3s)")
            else:
                log("[ChatListCustomizer] Worker de refresh iniciado (modo normal - 15s)")
            
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao iniciar worker: {e}")

    def _stop_refresh_worker(self):
        """Para o worker de refresh"""
        try:
            if self._refresh_worker_stop:
                self._refresh_worker_stop.set()
                self._refresh_worker_stop = None
            
            if self._refresh_worker_thread:
                self._refresh_worker_thread = None
                
            log("[ChatListCustomizer] Worker de refresh parado")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao parar worker: {e}")

    def create_settings(self):
        """ Interface de configurações do ChatList Customizer"""
        try:
            settings = []
            
            # Seção de Configurações de Exibição
            settings.append(Divider(text=tr("display_settings_section")))
            settings.append(Selector(
                key="display_name_option",
                text=tr("display_name_option"),
                default=self.get_setting("display_name_option", 0),
                items=[
                    tr("name_option_custom"),
                    tr("name_option_none"),
                    tr("name_option_my_name"),
                    tr("name_option_my_username")
                ],
                icon="msg_filled_menu_users",
                link_alias="display_name_option",
                on_change=lambda v: (
                    self.set_setting("display_name_option", int(v)),
                    self._apply_settings(),
                    # Só mostrar restart se não for "Custom" (opção 0) e não for "None" (opção 1)
                    self._show_restart_dialog() if int(v) != 0 and int(v) != 1 else None,
                    self.reload_settings()
                )
            ))
            

            if self.get_setting("display_name_option", 0) == 0:  # Custom option
                settings.append(Input(
                    key="custom_name",
                    text=tr("custom_name_input"),
                    subtext=tr("custom_name_desc"),
                    default=self.get_setting("custom_name", tr("default_custom_text")),
                    icon="msg_edit",
                    link_alias="custom_name",
                    on_change=lambda v: self._handle_custom_name_change(str(v))
                ))
            
            # Motion Themes: Switch que revela selector ao ativar
            settings.append(Switch(
                key="motion_theme_enabled",
                text=tr("motion_themes_label"),
                default=self.get_setting("motion_theme_enabled", False),
                icon="msg_palette",
                link_alias="motion_theme_enabled",
                on_change=lambda v: self._handle_motion_theme_change(v)
            ))
            if bool(self.get_setting("motion_theme_enabled", False)):
                settings.append(Selector(
                    key="motion_theme",
                    text=tr("motion_themes_styles"),
                    default=self.get_setting("motion_theme", 0),
                    items=[
                        tr("motion_theme_sl_jinwoo"),
                        tr("motion_theme_dbs_goku"),
                        tr("motion_theme_hxh_killua"),
                        tr("motion_theme_rainy_night"),
                        tr("motion_theme_flowing"),
                        tr("motion_theme_burst"),
                        tr("motion_theme_lofi"),
                        tr("motion_theme_custom"),
                    ],
                    icon="msg_expand",
                    link_alias="motion_theme",
                    on_change=lambda idx: self._handle_motion_theme_selection_change(int(idx))
                ))
                # Campo de URL custom quando selecionar "Custom"
                if int(self.get_setting("motion_theme", 0)) == 7:
                    settings.append(Input(
                        key="motion_theme_custom_url",
                        text=tr("motion_theme_custom_url"),
                        default=self.get_setting("motion_theme_custom_url", ""),
                        icon="menu_feature_links",
                        link_alias="motion_theme_custom_url",
                        on_change=lambda v: (
                            self.set_setting("motion_theme_custom_url", str(v).strip()),
                            self._apply_settings()
                        )
                    ))
            
            # Seção de Configurações de Saudação
            settings.append(Divider(text=tr("greeting_settings_section")))
            settings.append(Switch(
                key="enable_greeting",
                text=tr("enable_greeting"),
                subtext=tr("enable_greeting_desc"),
                default=self.get_setting("enable_greeting", False),
                icon="menu_feature_status",
                link_alias="enable_greeting",
                on_change=lambda v: self._handle_greeting_change(v)
            ))
            # Smart Messages: mover para logo após Enable Greeting
            settings.append(Selector(
                key="smart_messages_enabled",
                text=tr("smart_messages_label"),
                default=self.get_setting("smart_messages_enabled", 0),  # Default desativado
                items=[
                    tr("smart_messages_activate"),
                    tr("smart_messages_deactivate")
                ],
                icon="input_message",
                link_alias="smart_messages_enabled",
                on_change=lambda v: self._handle_smart_messages_change(v)
            ))
            
            # Smart Weather: Ativado exibe link "Weather Options" para subfragmento.
            settings.append(Selector(
                key="smart_weather_enabled",
                text=tr("smart_weather_label"),
                default=self.get_setting("smart_weather_enabled", 0),  # 0=Desativado, 1=Ativado
                items=[
                    tr("smart_weather_activate"),
                    tr("smart_weather_deactivate")
                ],
                icon="msg_settings_ny",
                link_alias="smart_weather_enabled",
                on_change=lambda v: self._handle_smart_weather_change(v)
            ))
            if int(self.get_setting("smart_weather_enabled", 0)) == 1:
                settings.append(Text(
                    text=tr("weather_options_link"),
                    icon="media_settings",
                    create_sub_fragment=self._create_weather_subfragment
                ))
           
            # Now Playing: divider e selector tri-estado (Ativado/Desativado/Ocultado)
            settings.append(Divider(text=tr("now_playing_section")))
            
            # Lógica dinâmica para o seletor Now Playing
            current_mode = int(self.get_setting(
                "now_playing_mode",
                0 if bool(self.get_setting("now_playing_enabled", False)) else 1
            ))
            
            # Gerar itens dinamicamente baseado no estado atual
            selector_items, selector_default = self._get_now_playing_selector_config(current_mode)
            
            settings.append(Selector(
                key="now_playing_mode",
                text=tr("now_playing_label"),
                default=selector_default,
                items=selector_items,
                icon="filled_widget_music",
                link_alias="now_playing_mode",
                on_change=lambda v: self._handle_now_playing_mode_change(v)
            ))
            # Exibir funcionalidades internas apenas quando modo = Ativado
            _np_mode = int(self.get_setting(
                "now_playing_mode",
                0 if bool(self.get_setting("now_playing_enabled", False)) else 1
            ))
            if _np_mode == 0:
                # Exibir opção para mostrar capa no ActionBar
                settings.append(Switch(
                    key="now_playing_show_cover",
                    text=tr("now_playing_show_cover"),
                    subtext=tr("now_playing_show_cover_sub"),
                    default=self.get_setting("now_playing_show_cover", True),
                    icon="msg_theme_remix",
                    link_alias="now_playing_show_cover",
                    on_change=lambda v: self._handle_now_playing_cover_change(v)
                ))
                
                # Opção para manter a capa quando não há música tocando
                settings.append(Switch(
                    key="keep_cover_when_not_playing",
                    text=tr("keep_cover_label"),
                    subtext=tr("keep_cover_desc"),
                    default=self.get_setting("keep_cover_when_not_playing", False),
                    icon="ic_gallery_background",
                    link_alias="keep_cover_when_not_playing",
                    on_change=lambda v: self._handle_keep_cover_change(v)
                ))
                # Divisor: Fonte
                settings.append(Divider(text=tr("now_playing_divider_source")))
                # Seletor de provedor
                settings.append(Selector(
                    key="now_playing_provider",
                    text=tr("now_playing_provider_label"),
                    default=self.get_setting("now_playing_provider", 0),
                    items=[
                        tr("provider_statsfm"),
                        tr("provider_lastfm")
                    ],
                    icon="msg_noise_on_solar",
                    link_alias="now_playing_provider",
                    on_change=lambda v: (
                        self.set_setting("now_playing_provider", int(v)),
                        self._apply_settings(),
                        self.reload_settings()
                    )
                ))
                prov = int(self.get_setting("now_playing_provider", 0))
                # Divisor: Credenciais
                settings.append(Divider(text=tr("now_playing_divider_credentials")))
                if prov == 0:
                    # Stats.fm: solicitar somente username
                    settings.append(Input(
                        key="statsfm_username",
                        text=tr("statsfm_username_label"),
                        default=self.get_setting("statsfm_username", ""),
                        icon="menu_username_change",
                        link_alias="statsfm_username",
                        on_change=lambda v: (
                            self.set_setting("statsfm_username", str(v).strip()),
                            self._apply_settings()
                        )
                    ))
                else:
                    # Last.fm: solicitar username e API key
                    settings.append(Input(
                        key="lastfm_username",
                        text=tr("lastfm_username_label"),
                        default=self.get_setting("lastfm_username", ""),
                        icon="menu_username_change",
                        link_alias="lastfm_username",
                        on_change=lambda v: (
                            self.set_setting("lastfm_username", str(v).strip()),
                            self._apply_settings()
                        )
                    ))
                    # Selector que controla apenas a visibilidade do campo de API Key
                    settings.append(Selector(
                        key="api_key_visibility",
                        text=tr("api_key_selector_label"),
                        default=self.get_setting("api_key_visibility", 0),
                        items=[
                            tr("api_key_option_show"),
                            tr("api_key_option_hide")
                        ],
                        icon="msg2_proxy_on",
                        link_alias="api_key_visibility",
                        on_change=lambda v: (
                            self.set_setting("api_key_visibility", int(v)),
                            self.reload_settings()
                        )
                    ))
                    # Mostrar campo API Key apenas se visibilidade = Exibir
                    if int(self.get_setting("api_key_visibility", 0)) == 0:
                        settings.append(Input(
                            key="lastfm_api_key",
                            text=tr("lastfm_api_key_label"),
                            default=self.get_setting("lastfm_api_key", ""),
                            icon="msg2_permissions",
                            link_alias="lastfm_api_key",
                            on_change=lambda v: (
                                self.set_setting("lastfm_api_key", str(v).strip()),
                                self._apply_settings()
                            )
                        ))
                # Divisor: Estilo
                settings.append(Selector(
                    key="now_playing_style",
                    text=tr("now_playing_style_label"),
                    default=self.get_setting("now_playing_style", 0),
                    items=[
                        tr("now_playing_style_single"),
                        tr("now_playing_style_typing"),
                        tr("now_playing_style_music_only")
                    ],
                    icon="msg_theme_remix",
                    link_alias="now_playing_style",
                    on_change=lambda v: (
                        self.set_setting("now_playing_style", int(v)),
                        self._apply_settings()
                    )
                ))
            # Configurações de fuso horário
            settings.append(Divider(text=tr("time_settings_section")))
            settings.append(Selector(
                key="timezone_selection",
                text=tr("timezone_label"),
                default=self.get_setting("timezone_selection", 0),
                items=[
                    tr("timezone_system"),
                    tr("timezone_utc"),
                    tr("timezone_moscow"),
                    tr("timezone_sao_paulo"),
                    tr("timezone_custom_offset")
                ],
                icon="menu_premium_clock",
                link_alias="timezone_selection",
                on_change=lambda v: (
                    self.set_setting("timezone_selection", int(v)),
                    self._apply_settings(),
                    self.reload_settings()
                )
            ))
            # Mostrar seletor de offset quando Custom Offset estiver selecionado
            if int(self.get_setting("timezone_selection", 0)) == 4:
                # Lista de offsets de -12 a +14
                offset_items = []
                for h in range(-12, 15):
                    label = f"UTC{h:+d}"
                    offset_items.append(label)
                current_off = int(self.get_setting("timezone_offset_hours", 0))
                current_index = current_off + 12  # map -12..+14 to 0..26
                settings.append(Selector(
                    key="timezone_offset_hours",
                    text=tr("timezone_offset_label"),
                    default=current_index,
                    items=offset_items,
                    icon="filled_premium_hours",
                    link_alias="timezone_offset_hours",
                    on_change=lambda idx: (
                        self.set_setting("timezone_offset_hours", int(idx) - 12),
                        self._apply_settings(),
                        self.reload_settings()
                    )
                ))
                
            # Separador e link para Opções Avançadas em subfragmento
            settings.append(Divider(text=tr("advanced_settings_section")))
            settings.append(Text(
                text=tr("advanced_settings_link"),
                icon="msg_settings",
                # Abre página secundária de configurações avançadas
                create_sub_fragment=self._create_advanced_subfragment
            ))
            
            settings.append(Divider())
            settings.append(Text(
                text=tr("credits") if "credits" in TRANSLATIONS else "Dotted Plugins",
                icon="etg_settings",
                accent=True,
                on_click=lambda view: run_on_ui_thread(lambda: get_messages_controller().openByUserName("exteraDevPlugins", get_last_fragment(), 1))
            ))

            # BottomSheet "Support" ao estilo Apple
            settings.append(Text(
                text=tr("support_title") if "support_title" in TRANSLATIONS else "Support",
                icon="msg_reactions",
                accent=True,
                on_click=lambda view: run_on_ui_thread(self._show_support_sheet)
            ))
            
            return settings
            
        except Exception as e:
            log(f"[ChatListCustomizer] Error creating settings: {e}")
            return [
                Header(text="ChatList Customizer"),
                Text(text=(tr("error_loading_settings") if "error_loading_settings" in TRANSLATIONS else "Error loading settings") + f": {e}")
            ]

    def _create_advanced_subfragment(self, parent_view=None):
        """Cria subfragmento de Opções Avançadas"""
        try:
            advanced = []

            # Seção de Aparência
            advanced.append(Divider(text=tr("appearance_section")))
            advanced.append(Selector(
                key="title_style",
                text=tr("title_style"),
                # Obs.: 0 = sem shape, 1 = shape escuro arredondado
                default=self.get_setting("title_style", 0),
                items=[
                    tr("title_style_none"),
                    tr("title_style_dark"),
                    tr("title_style_glow"),
                    tr("title_style_aurora"),
                ],
                icon="msg_channel_14_solar",
                link_alias="title_style",
                on_change=lambda idx: (
                    self.set_setting("title_style", int(idx)),
                    self._apply_settings(),
                    self.reload_settings()
                )
            ))

            # Seção de Comportamento
            advanced.append(Divider(text=tr("behavior_section")))
            advanced.append(Switch(
                key="fix_title",
                text=tr("fix_title"),
                subtext=tr("fix_title_desc"),
                default=self.get_setting("fix_title", False),
                icon="msg_pin",
                link_alias="fix_title",
                # Ao alterar, aplicar e sugerir reinício
                on_change=lambda v: (
                    self.set_setting("fix_title", bool(v)),
                    self._apply_settings(),
                    self._show_restart_dialog(),
                    self.reload_settings()
                )
            ))

            # Filtro de títulos para Now Playing
            advanced.append(Switch(
                key="now_playing_filter_titles",
                text=tr("now_playing_filter_titles_label"),
                subtext=tr("now_playing_filter_titles_desc"),
                default=self.get_setting("now_playing_filter_titles", True),
                icon="filled_widget_music",
                link_alias="now_playing_filter_titles",
                on_change=lambda v: (
                    self.set_setting("now_playing_filter_titles", bool(v)),
                    self._apply_settings()
                )
            ))

            # Seção de Integração de Interface
            advanced.append(Divider(text=tr("interface_integration_section")))
            advanced.append(Switch(
                key="show_chat_menu",
                text=tr("show_chat_menu_title"),
                subtext=tr("show_chat_menu_subtext"),
                default=self.get_setting("show_chat_menu", False),
                icon="preview_dots",
                link_alias="show_chat_menu",
                on_change=lambda v: self._handle_show_chat_menu_change(v)
            ))
            
            advanced.append(Switch(
                key="show_side_menu",
                text=tr("show_side_menu_title"),
                subtext=tr("show_side_menu_subtext"),
                default=self.get_setting("show_side_menu", False),
                icon="msg_list",
                link_alias="show_side_menu",
                on_change=lambda v: self._handle_show_side_menu_change(v)
            ))

            # Seção de Sistema
            advanced.append(Divider(text=tr("system_section") if "system_section" in TRANSLATIONS else "Sistema"))
            advanced.append(Switch(
                key="disable_logs",
                text=tr("disable_logs_title"),
                subtext=tr("disable_logs_subtext"),
                default=self.get_setting("disable_logs", False),
                icon="msg_log",
                link_alias="disable_logs",
                on_change=lambda v: self._handle_disable_logs_change(v)
            ))

            return advanced
        except Exception as e:
            log(f"[ChatListCustomizer] Erro criando subfragmento avançado: {e}")
            return [
                Header(text=tr("advanced_settings_page")),
                Text(text=f"Erro: {e}")
            ]

    def _create_weather_subfragment(self, parent_view=None):
        """ Subfragmento de configurações do Smart Weather.
        Inclui cidade, unidade (°C/°F), API Key e opções de exibição.
        """
        try:
            items = []
            # Divisor: Options
            items.append(Divider(text=tr("weather_divider_options")))

            # Cidade
            items.append(Input(
                key="weather_city",
                text=tr("weather_city_label"),
                default=self.get_setting("weather_city", ""),
                icon="msg_location",
                link_alias="weather_city",
                on_change=lambda v: (
                    self.set_setting("weather_city", str(v).strip()),
                    self._apply_settings()
                )
            ))

            # Unidade de temperatura
            items.append(Selector(
                key="weather_units",
                text=tr("weather_units_label"),
                default=self.get_setting("weather_units", 0),  # 0=Celsius, 1=Fahrenheit
                items=[
                    tr("weather_units_celsius"),
                    tr("weather_units_fahrenheit"),
                ],
                icon="zoom_round_b",
                link_alias="weather_units",
                on_change=lambda idx: (
                    self.set_setting("weather_units", int(idx)),
                    self._apply_settings()
                )
            ))

            # Visibilidade da API Key (Hide/Show)
            items.append(Selector(
                key="weather_api_key_visibility",
                text=tr("api_key_selector_label"),
                default=self.get_setting("weather_api_key_visibility", 1),  # 0=Show, 1=Hide
                items=[
                    tr("api_key_option_show"),
                    tr("api_key_option_hide"),
                ],
                icon="msg2_proxy_on",
                link_alias="weather_api_key_visibility",
                on_change=lambda idx: (
                    self.set_setting("weather_api_key_visibility", int(idx)),
                    self.reload_settings()
                )
            ))

            # API Key (mostrar somente quando selector estiver em "Show Key")
            if int(self.get_setting("weather_api_key_visibility", 1)) == 0:
                items.append(Input(
                    key="weather_api_key",
                    text=tr("weather_api_key_label"),
                    default=self.get_setting("weather_api_key", ""),
                    icon="msg2_policy",
                    link_alias="weather_api_key",
                    on_change=lambda v: (
                        self.set_setting("weather_api_key", str(v).strip()),
                        self._apply_settings()
                    )
                ))

            # Título
            try:
                items.append(Text(
                    text=tr("howto_title"),
                    icon="msg_forward",
                    on_click=lambda view: run_on_ui_thread(self._show_weather_how_to_use_sheet)
                ))
            except Exception:
                pass

            # Divisor: Weather Details
            items.append(Divider(text=tr("weather_divider_details")))
            items.append(Switch(
                key="weather_show_condition",
                text=tr("weather_show_condition"),
                subtext=tr("weather_show_condition_subtext"),
                default=self.get_setting("weather_show_condition", True),
                icon="msg_arrow_forward",
                link_alias="weather_show_condition",
                on_change=lambda v: (
                    self.set_setting("weather_show_condition", bool(v)),
                    self._apply_settings()
                )
            ))
            items.append(Switch(
                key="weather_show_wind",
                text=tr("weather_show_wind"),
                subtext=tr("weather_show_wind_subtext"),
                default=self.get_setting("weather_show_wind", False),
                icon="msg_arrow_forward",
                link_alias="weather_show_wind",
                on_change=lambda v: (
                    self.set_setting("weather_show_wind", bool(v)),
                    self._apply_settings()
                )
            ))
            items.append(Switch(
                key="weather_show_humidity",
                text=tr("weather_show_humidity"),
                subtext=tr("weather_show_humidity_subtext"),
                default=self.get_setting("weather_show_humidity", False),
                icon="msg_arrow_forward",
                link_alias="weather_show_humidity",
                on_change=lambda v: (
                    self.set_setting("weather_show_humidity", bool(v)),
                    self._apply_settings()
                )
            ))
            items.append(Switch(
                key="weather_show_feelslike",
                text=tr("weather_show_feelslike"),
                subtext=tr("weather_show_feelslike_subtext"),
                default=self.get_setting("weather_show_feelslike", False),
                icon="msg_arrow_forward",
                link_alias="weather_show_feelslike",
                on_change=lambda v: (
                    self.set_setting("weather_show_feelslike", bool(v)),
                    self._apply_settings()
                )
            ))

            # Divider para agrupar opções de exibição (emojis + idioma)
            items.append(Divider(text=tr("weather_display_section")))
            # Switch de Emojis: quando ativo, o Smart Weather acrescenta emojis à condição
            items.append(Switch(
                key="weather_enable_emojis",
                text=tr("weather_enable_emojis"),
                subtext=tr("weather_enable_emojis_subtext"),
                default=self.get_setting("weather_enable_emojis", False),
                icon="msg_brightness_low",
                link_alias="weather_enable_emojis",
                on_change=lambda v: (
                    self.set_setting("weather_enable_emojis", bool(v)),
                    self._apply_settings()
                )
            ))
            # Selector de idioma para os dados do WeatherAPI
            # Usa items=[...] com índices: 0=en, 1=pt, 2=ru
            items.append(Selector(
                key="weather_language_selector",
                text=tr("weather_language_label"),
                default=(0 if str(self.get_setting("weather_language", "en")) == "en" else (1 if str(self.get_setting("weather_language", "en")) == "pt" else 2)),
                items=[
                    tr("weather_language_english"),
                    tr("weather_language_portuguese"),
                    tr("weather_language_russian")
                ],
                icon="msg_language",
                link_alias="weather_language",
                on_change=lambda v: (
                    self.set_setting("weather_language", ("en" if int(v) == 0 else ("pt" if int(v) == 1 else "ru"))),
                    self._apply_settings()
                )
            ))

            return items
        except Exception as e:
            log(f"[ChatListCustomizer] Erro criando subfragmento de clima: {e}")
            return [
                Header(text=tr("weather_options_header")),
                Text(text=f"Erro: {e}")
            ]

    def _open_get_api_link(self):
        """Abre o link para obter a API da WeatherAPI"""
        try:
            url = "https://www.weatherapi.com/my/"
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if Browser and ctx:
                try:
                    Browser.openUrl(ctx, url)
                    return
                except Exception:
                    pass
            try:
                # Fallback para AndroidUtilities
                if ctx and hasattr(AndroidUtilities, "openUrl"):
                    AndroidUtilities.openUrl(ctx, url)
                    return
            except Exception:
                pass
        except Exception:
            pass

    def _show_weather_how_to_use_sheet(self):
        """Exibe BottomSheet simples explicando a necessidade da API, com botão Get the API"""
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)

            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(tr("howto_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 16, 24, 8))
            
            # Imagem do banner usando WebView
            try:
                WebView = find_class("android.webkit.WebView")
                web_view = WebView(ctx)
                
                # Configura o WebView
                web_view.getSettings().setJavaScriptEnabled(True)
                web_view.setBackgroundColor(0x00000000)  # Fundo transparente
                
                # Implementa o cache para a imagem
                web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                web_view.getSettings().setAppCacheEnabled(True)
                web_view.getSettings().setDomStorageEnabled(True)
                
                # Define o diretório de cache
                try:
                    context = ctx.getApplicationContext()
                    cache_dir = context.getCacheDir().getAbsolutePath()
                    web_view.getSettings().setAppCachePath(cache_dir)
                except Exception as e:
                    log(f"[ChatListCustomizer] Erro ao configurar cache: {e}")
                
                # Método @AGeekApple Styles
                html = """
                <html>
                <head>
                    <style>
                        body { margin: 0; padding: 0; background-color: transparent; }
                        img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                    </style>
                    <script>
                        // Script para garantir que a imagem seja armazenada em cache
                        window.onload = function() {
                            // Força o cache da imagem no localStorage
                            if (!localStorage.getItem('weatherBannerCached')) {
                                localStorage.setItem('weatherBannerCached', 'true');
                                console.log('Imagem armazenada em cache');
                            } else {
                                console.log('Usando imagem em cache');
                            }
                        }
                    </script>
                </head>
                <body>
                    <img src="https://i.postimg.cc/KcQ7fS8X/icon-chat.png" alt="Weather Banner by Apple">
                </body>
                </html>
                """
                
                web_view.loadDataWithBaseURL(None, html, "text/html", "UTF-8", None)
                
                # Ajustando altura para manter proporção correta sem espaços extras
                container.addView(web_view, LayoutHelper.createLinear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception as e:
                log(f"[ChatListCustomizer] Erro ao criar WebView: {e}")

            # Descrição - removendo espaço entre a imagem e o texto
            desc_view = TextView(ctx)
            desc_view.setText(tr("howto_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            # Botão "Get the API" com bordas
            button_container = FrameLayout(ctx)
            
            # Criando um background com bordas para o botão
            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
            button_bg = GradientDrawable()
            button_bg.setCornerRadius(8)  # Cantos arredondados
            try:
                button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))  # Borda azul (teste)
                button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))  # Fundo do diálogo (teste)
            except Exception:
                button_bg.setStroke(2, 0xFF3B78FF)  # Azul padrão como fallback (teste)
                button_bg.setColor(0xFF1F1F1F)  # Cinza escuro como fallback (teste)
            
            btn = TextView(ctx)  # Usando TextView em vez de SimpleTextView para suportar background
            btn.setText(tr("get_api_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)  # Azul padrão como fallback (teste)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)  # Padding interno para o botão (teste)
            btn.setBackground(button_bg)
            button_container.addView(btn, LayoutHelper.createFrame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_get_api_link()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def _open_support_user(self):
        """Abre o perfil @AGeekApple usando a mesma lógica estável"""
        try:
            run_on_ui_thread(lambda: get_messages_controller().openByUserName("AGeekApple", get_last_fragment(), 1))
        except Exception:
            try:
                # Fallback para deep link tg://resolve
                Intent = find_class("android.content.Intent")
                Uri = find_class("android.net.Uri")
                intent = Intent(Intent.ACTION_VIEW)
                intent.setData(Uri.parse("tg://resolve?domain=AGeekApple"))
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
                fragment = get_last_fragment()
                if fragment:
                    context = fragment.getContext()
                    context.startActivity(intent)
            except Exception:
                pass
    # Método @AGeekApple Style
    def _show_donate_sheet(self):
        """Exibe BottomSheet com informações de doação em HTML"""
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)

            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(tr("donate_options_button"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            # HTML minimalista de opções de doação (sem emojis, sem textos PT)
            html_content = """
            <html>
            <head>
                <style>
                    body { 
                        margin: 0; 
                        padding: 16px; 
                        background-color: transparent; 
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        color: #333;
                    }
                    .donate-container {
                        background: #1f2937;
                        border-radius: 12px;
                        padding: 16px;
                        margin: 8px 0;
                        border: 1px solid #374151;
                    }
                    .crypto-item {
                        background: #111827;
                        border-radius: 8px;
                        padding: 12px;
                        margin: 8px 0;
                        border: 1px solid #374151;
                        cursor: pointer;
                    }
                    .crypto-name {
                        color: #e5e7eb;
                        font-size: 15px;
                        font-weight: 600;
                        margin-bottom: 4px;
                    }
                    .crypto-address {
                        color: #9ca3af;
                        font-size: 12px;
                        font-family: monospace;
                        word-break: break-all;
                        line-height: 1.4;
                    }
                    .copy-hint {
                        color: #9ca3af;
                        font-size: 11px;
                        text-align: center;
                        margin-top: 10px;
                    }
                </style>
                <script>
                    function copyText(t) {
                        try {
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                navigator.clipboard.writeText(t);
                            } else {
                                var ta = document.createElement('textarea');
                                ta.value = t; document.body.appendChild(ta);
                                ta.select(); document.execCommand('copy');
                                document.body.removeChild(ta);
                            }
                            var h = document.getElementById('hint');
                            if (h) { h.innerText = 'Copied'; }
                        } catch (e) {}
                    }
                </script>
            </head>
            <body>
                <div class=\"donate-container\">
                    <div class=\"crypto-item\" onclick=\"copyText('UQCy_iox46geMTCNxxZ0G8W0_gg0NXQXz4_A2ho8UtciXvW1')\">
                        <div class=\"crypto-name\">TON</div>
                        <div class=\"crypto-address\">UQCy_iox46geMTCNxxZ0G8W0_gg0NXQXz4_A2ho8UtciXvW1</div>
                    </div>
                    <div class=\"crypto-item\" onclick=\"copyText('UQAnV3cohn83QODugckxVP-f9jfjwsBgp6MR_RS4hLDWy1rT')\">
                        <div class=\"crypto-name\">TON (Telegram)</div>
                        <div class=\"crypto-address\">UQAnV3cohn83QODugckxVP-f9jfjwsBgp6MR_RS4hLDWy1rT</div>
                    </div>
                    <div class=\"crypto-item\" onclick=\"copyText('bc1qkyq4zqy07agmspnuve6gtjlt40ew278l94ljry8fulykec7vhfuqnuh7he')\">
                        <div class=\"crypto-name\">Bitcoin</div>
                        <div class=\"crypto-address\">bc1qkyq4zqy07agmspnuve6gtjlt40ew278l94ljry8fulykec7vhfuqnuh7he</div>
                    </div>
                    <div class=\"crypto-item\" onclick=\"copyText('0xd41a8f8aed90108380688a46b97ad0a15a91598b')\">
                        <div class=\"crypto-name\">Ethereum (ERC20)</div>
                        <div class=\"crypto-address\">0xd41a8f8aed90108380688a46b97ad0a15a91598b</div>
                    </div>
                    <div id=\"hint\" class=\"copy-hint\">Tap address to copy</div>
                </div>
            </body>
            </html>
            """

            # WebView para exibir o HTML
            WebView = find_class("android.webkit.WebView")
            web_view = WebView(ctx)
            web_view.getSettings().setJavaScriptEnabled(True)
            web_view.setBackgroundColor(0x00000000)  # Fundo transparente
            
            # Configurar cache
            web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
            web_view.getSettings().setAppCacheEnabled(True)
            web_view.getSettings().setDomStorageEnabled(True)
            
            try:
                context = ctx.getApplicationContext()
                cache_dir = context.getCacheDir().getAbsolutePath()
                web_view.getSettings().setAppCachePath(cache_dir)
            except Exception:
                pass

            # Adicionar JavaScript para copiar endereços ao tocar
            WebViewClient = find_class("android.webkit.WebViewClient")
            web_view.setWebViewClient(WebViewClient())
            
            # Carregar o HTML
            web_view.loadDataWithBaseURL(None, html_content, "text/html", "UTF-8", None)
            
            # Adicionar o WebView ao container
            container.addView(web_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 0, 0, 0, 0))

            # Botões nativos para Livepix e Ko‑fi com o mesmo estilo do botão Fechar
            def _open_url_safe(url):
                # Sempre abre a URL fornecida; sem redirecionar para helpers externos
                try:
                    if hasattr(self, "_open_url"):
                        self._open_url(url)
                        return
                except Exception:
                    pass
                try:
                    Browser = find_class("org.telegram.messenger.browser.Browser")
                    Browser.openUrl(ctx, url)
                    return
                except Exception:
                    pass
                try:
                    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
                    AndroidUtilities.openUrl(ctx, url)
                except Exception:
                    pass

            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
            link_bg = GradientDrawable()
            link_bg.setCornerRadius(8)
            try:
                link_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                link_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
            except Exception:
                link_bg.setStroke(2, 0xFF3B78FF)
                link_bg.setColor(0xFF1F1F1F)

            # Livepix
            livepix_container = FrameLayout(ctx)
            livepix_btn = TextView(ctx)
            livepix_btn.setText("Livepix")
            livepix_btn.setTextSize(16)
            try:
                livepix_btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                livepix_btn.setTextColor(0xFF3B78FF)
            livepix_btn.setGravity(Gravity.CENTER)
            livepix_btn.setPadding(16, 8, 16, 8)
            livepix_btn.setBackground(link_bg)
            livepix_container.addView(livepix_btn, LayoutHelper.createFrame(-1, 48, Gravity.CENTER))
            livepix_btn.setOnClickListener(OnClickListener(lambda v: _open_url_safe("https://livepix.gg/makios")))
            container.addView(livepix_container, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 8, 24, 8))

            # Ko‑fi
            kofi_container = FrameLayout(ctx)
            kofi_btn = TextView(ctx)
            kofi_btn.setText("Ko-fi")
            kofi_btn.setTextSize(16)
            try:
                kofi_btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                kofi_btn.setTextColor(0xFF3B78FF)
            kofi_btn.setGravity(Gravity.CENTER)
            kofi_btn.setPadding(16, 8, 16, 8)
            kofi_btn.setBackground(link_bg)
            kofi_container.addView(kofi_btn, LayoutHelper.createFrame(-1, 48, Gravity.CENTER))
            kofi_btn.setOnClickListener(OnClickListener(lambda v: _open_url_safe("https://ko-fi.com/ageekapple")))
            container.addView(kofi_container, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 0, 24, 8))

            # Botão de fechar
            close_container = FrameLayout(ctx)
            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
            close_bg = GradientDrawable()
            close_bg.setCornerRadius(8)
            try:
                close_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                close_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
            except Exception:
                close_bg.setStroke(2, 0xFF3B78FF)
                close_bg.setColor(0xFF1F1F1F)

            close_btn = TextView(ctx)
            close_btn.setText(tr("close_button"))
            close_btn.setTextSize(16)
            try:
                close_btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                close_btn.setTextColor(0xFF3B78FF)
            close_btn.setGravity(Gravity.CENTER)
            close_btn.setPadding(16, 8, 16, 8)
            close_btn.setBackground(close_bg)
            close_container.addView(close_btn, LayoutHelper.createFrame(-1, 48, Gravity.CENTER))

            def _close_click(*args):
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            close_btn.setOnClickListener(OnClickListener(_close_click))
            container.addView(close_container, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 16, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception as e:
            log(f"[ChatListCustomizer] Erro ao mostrar BottomSheet de doação: {e}")

    def _show_support_sheet(self):
        """Exibe BottomSheet de suporte com imagem e botão para @AGeekApple"""
        try:
            fragment = get_last_fragment()
            ctx = fragment.getParentActivity() if fragment and fragment.getParentActivity() else None
            if not ctx:
                return

            sheet = BottomSheet(ctx, True)

            container = LinearLayout(ctx)
            container.setOrientation(LinearLayout.VERTICAL)

            # Título
            title_view = TextView(ctx)
            title_view.setText(tr("support_title"))
            try:
                title_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            title_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 18)
            title_view.setGravity(Gravity.START)
            container.addView(title_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 16, 24, 8))

            # Imagem do banner com cache nativo; fallback para WebView
            try:
                image_url = "https://i.postimg.cc/FHqP6q5V/ageekapple.png"
                cached_path = None
                try:
                    cached_path = self._download_image_to_cache(image_url)
                except Exception:
                    cached_path = None

                if cached_path:
                    try:
                        ImageView = find_class("android.widget.ImageView")
                        BitmapFactory = find_class("android.graphics.BitmapFactory")
                        image_view = ImageView(ctx)
                        try:
                            image_view.setAdjustViewBounds(True)
                        except Exception:
                            pass
                        bmp = BitmapFactory.decodeFile(cached_path)
                        if bmp:
                            image_view.setImageBitmap(bmp)
                            container.addView(image_view, LayoutHelper.createLinear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
                        else:
                            raise Exception("Bitmap decode returned null")
                    except Exception:
                        # Fallback para WebView se ImageView falhar
                        WebView = find_class("android.webkit.WebView")
                        web_view = WebView(ctx)
                        web_view.getSettings().setJavaScriptEnabled(True)
                        web_view.setBackgroundColor(0x00000000)
                        web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                        web_view.getSettings().setAppCacheEnabled(True)
                        web_view.getSettings().setDomStorageEnabled(True)
                        try:
                            context = ctx.getApplicationContext()
                            cache_dir = context.getCacheDir().getAbsolutePath()
                            web_view.getSettings().setAppCachePath(cache_dir)
                        except Exception:
                            pass
                        html = """
                        <html>
                        <head>
                            <style>
                                body { margin: 0; padding: 0; background-color: transparent; }
                                img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                            </style>
                            <script>
                                window.onload = function() {
                                    if (!localStorage.getItem('supportBannerCached')) {
                                        localStorage.setItem('supportBannerCached', 'true');
                                    }
                                }
                            </script>
                        </head>
                        <body>
                            <img src="https://i.postimg.cc/FHqP6q5V/ageekapple.png" alt="Support Banner by Apple">
                        </body>
                        </html>
                        """
                        web_view.loadDataWithBaseURL(None, html, "text/html", "UTF-8", None)
                        container.addView(web_view, LayoutHelper.createLinear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
                else:
                    # Sem cache: usa WebView diretamente
                    WebView = find_class("android.webkit.WebView")
                    web_view = WebView(ctx)
                    web_view.getSettings().setJavaScriptEnabled(True)
                    web_view.setBackgroundColor(0x00000000)
                    web_view.getSettings().setCacheMode(web_view.getSettings().LOAD_CACHE_ELSE_NETWORK)
                    web_view.getSettings().setAppCacheEnabled(True)
                    web_view.getSettings().setDomStorageEnabled(True)
                    try:
                        context = ctx.getApplicationContext()
                        cache_dir = context.getCacheDir().getAbsolutePath()
                        web_view.getSettings().setAppCachePath(cache_dir)
                    except Exception:
                        pass
                    html = """
                    <html>
                    <head>
                        <style>
                            body { margin: 0; padding: 0; background-color: transparent; }
                            img { width: 100%; height: auto; display: block; margin-bottom: -4px; }
                        </style>
                        <script>
                            window.onload = function() {
                                if (!localStorage.getItem('supportBannerCached')) {
                                    localStorage.setItem('supportBannerCached', 'true');
                                }
                            }
                        </script>
                    </head>
                    <body>
                        <img src="https://i.postimg.cc/FHqP6q5V/ageekapple.png" alt="Support Banner by Apple">
                    </body>
                    </html>
                    """
                    web_view.loadDataWithBaseURL(None, html, "text/html", "UTF-8", None)
                    container.addView(web_view, LayoutHelper.createLinear(-1, 150, Gravity.CENTER, 24, 0, 24, 0))
            except Exception:
                pass

            # Descrição
            desc_view = TextView(ctx)
            desc_view.setText(tr("support_description"))
            try:
                desc_view.setTextColor(Theme.getColor(Theme.key_windowBackgroundWhiteBlackText))
            except Exception:
                pass
            desc_view.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 14)
            desc_view.setGravity(Gravity.START)
            container.addView(desc_view, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 0, 24, 0))

            # Botão seguindo padrões de propriedades
            button_container = FrameLayout(ctx)
            GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")
            button_bg = GradientDrawable()
            button_bg.setCornerRadius(8)
            try:
                button_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                button_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
            except Exception:
                button_bg.setStroke(2, 0xFF3B78FF)
                button_bg.setColor(0xFF1F1F1F)

            btn = TextView(ctx)
            btn.setText(tr("support_button"))
            btn.setTextSize(16)
            try:
                btn.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                btn.setTextColor(0xFF3B78FF)
            btn.setGravity(Gravity.CENTER)
            btn.setPadding(16, 8, 16, 8)
            btn.setBackground(button_bg)
            button_container.addView(btn, LayoutHelper.createFrame(-1, 48, Gravity.CENTER))

            def _on_click(*args):
                try:
                    self._open_support_user()
                except Exception:
                    pass
                try:
                    sheet.dismiss()
                except Exception:
                    pass

            btn.setOnClickListener(OnClickListener(_on_click))
            container.addView(button_container, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            donate_container = FrameLayout(ctx)
            donate_bg = GradientDrawable()
            donate_bg.setCornerRadius(8)
            try:
                donate_bg.setStroke(2, Theme.getColor(Theme.key_dialogTextBlue))
                donate_bg.setColor(Theme.getColor(Theme.key_dialogBackground))
            except Exception:
                donate_bg.setStroke(2, 0xFF3B78FF)
                donate_bg.setColor(0xFF1F1F1F)

            # (Mesma abordagem do Weather Options)
            donate_text = TextView(ctx)
            donate_text.setText(tr("donate_options_button"))
            donate_text.setTextSize(16)
            try:
                donate_text.setTextColor(Theme.getColor(Theme.key_dialogTextBlue))
            except Exception:
                donate_text.setTextColor(0xFF3B78FF)
            donate_text.setGravity(Gravity.CENTER)
            donate_text.setPadding(24, 12, 24, 12)
            donate_text.setClickable(True)
            try:
                donate_text.setBackground(donate_bg)
            except Exception:
                pass
            
            donate_text.setOnClickListener(OnClickListener(lambda view: self._show_donate_sheet()))
            donate_container.addView(donate_text, LayoutHelper.createFrame(-1, 48, Gravity.CENTER))
            container.addView(donate_container, LayoutHelper.createLinear(-1, -2, Gravity.TOP, 24, 8, 24, 16))

            sheet.setCustomView(container)
            run_on_ui_thread(sheet.show)
        except Exception:
            pass

    def on_plugin_loaded(self):
        """Executado quando o plugin é carregado"""
        try:
            global _LANG
            _LANG = _detect_lang()
            log(f"[ChatListCustomizer] Plugin loaded with language: {_LANG}")
            
            # Definir texto padrão se não existir
            if not self.get_setting("custom_name", ""):
                self.set_setting("custom_name", tr("default_custom_text"))
                     
            # Aplicar configurações e iniciar worker para manter ativo mesmo após reinícios
            self._apply_settings()
            try:
                self._start_refresh_worker(15)
                log("[ChatListCustomizer] Refresh worker bootstrapped on load")
            except Exception as e:
                log(f"[ChatListCustomizer] Error bootstrapping worker: {e}")
            # Instalar hooks do ActionBar para forçar título
            try:
                self._setup_actionbar_hooks()
            except Exception as e:
                log(f"[ChatListCustomizer] Error setting up hooks: {e}")
            
            # Inicializar menus se habilitados
            try:
                if self.get_setting("show_chat_menu", False):
                    self._add_chat_menu_item()
                if self.get_setting("show_side_menu", False):
                    self._ensure_side_menu_item()
            except Exception as e:
                log(f"[ChatListCustomizer] Error initializing menus: {e}")
            
            # Aplicar configuração de logs
            try:
                if self.get_setting("disable_logs", False):
                    _set_log_muted(True)
                    _apply_log_wrapper()
            except Exception as e:
                log(f"[ChatListCustomizer] Error applying log settings: {e}")
        
        except Exception as e:
            log(f"[ChatListCustomizer] Error during load: {e}")

    def on_plugin_unloaded(self):
        """Executado quando o plugin é baixado e instalado"""
        try:
            log("[ChatListCustomizer] Unloading plugin...")
            # Parar worker e restaurar título
            self._stop_refresh_worker()
            self._restore_chat_list_title()
            # Restaurar banner se for aplicado
            try:
                self._restore_action_bar_background()
            except Exception:
                pass
            # Remover hooks
            try:
                if self._hook_set_title_ref:
                    self.unhook_method(self._hook_set_title_ref)
                    self._hook_set_title_ref = None
                if self._hook_set_title_anim_ref:
                    self.unhook_method(self._hook_set_title_anim_ref)
                    self._hook_set_title_anim_ref = None
            except Exception as e:
                log(f"[ChatListCustomizer] Error removing hooks: {e}")
            
            # Remover itens dos menus
            try:
                self._remove_chat_menu_item()
                self._remove_side_menu_item()
            except Exception as e:
                log(f"[ChatListCustomizer] Error removing menu items: {e}")
            
            log("[ChatListCustomizer] Plugin descarregado")
        except Exception as e:
            log(f"[ChatListCustomizer] Erro no descarregamento: {e}")

    # Compatibilidade com nomenclatura alternativa do engine
    def on_plugin_load(self):
        try:
            self.on_plugin_loaded()
        except Exception as e:
            log(f"[ChatListCustomizer] Error in on_plugin_load: {e}")

    def on_plugin_unload(self):
        try:
            self.on_plugin_unloaded()
        except Exception as e:
            log(f"[ChatListCustomizer] Error in on_plugin_unload: {e}")


class _ActionBarTitleHook:
    """Hook para forçar o título da ActionBar em DialogsActivity/FilterChatlistActivity"""
    def __init__(self, plugin: ChatListCustomizerPlugin):
        self.plugin = plugin

    def before_hooked_method(self, param):
        # Não precisamos alterar argumentos antes da chamada
        pass

    def after_hooked_method(self, param):
        try:
            # Evitar recursão ao definir título dentro do hook
            if getattr(self.plugin, "_is_setting_title", False):
                return

            fragment = get_last_fragment()
            if not fragment:
                return
            fragment_name = fragment.getClass().getName()
            if ("DialogsActivity" not in fragment_name) and ("FilterChatlistActivity" not in fragment_name):
                return

            final_title = self.plugin._build_final_title()
            if final_title is None:
                return

            self.plugin._is_setting_title = True
            try:
                action_bar = fragment.getActionBar()
                if action_bar:
                    try:
                        title_view = action_bar.getTitleTextView()
                        if title_view:
                            title_view.setText(final_title)
                        else:
                            action_bar.setTitle(final_title)
                    except Exception:
                        action_bar.setTitle(final_title)
            except Exception as e:
                log(f"[ChatListCustomizer] Hook apply error: {e}")
            finally:
                self.plugin._is_setting_title = False
        except Exception as e:
            log(f"[ChatListCustomizer] Hook error: {e}")


    def reload_settings(self):
        """Reaplica configurações e atualiza estado do worker/hook"""
        try:
            # Reaplicar título e verificar activation
            self._apply_settings()
        except Exception as e:
            log(f"[ChatListCustomizer] Erro em reload_settings: {e}")

# Classes Android auxiliares
LinearLayout = find_class("android.widget.LinearLayout")
try:
    Browser = find_class("org.telegram.messenger.browser.Browser")
except Exception:
    Browser = Nonem