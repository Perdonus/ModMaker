__id__ = "send_file_text"
__name__ = "FileText"
__author__ = "@RnPlugins with @PluginIDE"
__version__ = "1.0.0r"
__description__ = """Добавляет в контекстное меню отправки сообщения (удержи кнопку отправки) пункт **«Отправить файлом»** — введённый текст будет отправлен как **.txt** файл.

Adds a **“Send as file”** option to the message send context menu (hold the send button). The entered text will be sent as a **.txt** file."""

__icon__ = "sPluginIDE/8"
__min_version__ = "11.12.1"

# Сгенерировано в PluginIDE - @PluginIDE

from base_plugin import BasePlugin, MethodHook
from client_utils import get_last_fragment, run_on_queue
from android_utils import run_on_ui_thread, log as logcat

from java.io import File, FileOutputStream
from java import jlong, dynamic_proxy
from java.lang import Runnable
from java.util import Locale, ArrayList

from hook_utils import get_private_field

# UI / Telegram classes
from org.telegram.ui import ChatActivity, MessageSendPreview
from org.telegram.ui.Components import ItemOptions
from org.telegram.messenger import (
    ApplicationLoader, AndroidUtilities, SendMessagesHelper, AccountInstance, R, MessageObject
)
from android.net import Uri  # оставлено про запас


def _log(msg: str):
    logcat(f"[send_file_text] {msg}")


class RunnableFactory(dynamic_proxy(Runnable)):
    def __init__(self, fn):
        super().__init__()
        self.fn = fn

    def run(self):
        try:
            self.fn()
        except Exception as e:
            _log(f"Runnable error: {e}")


class TelegramUtils:
    @staticmethod
    def get_fixed_icon_id() -> int:
        return R.drawable.msg_sendfile


class _SetItemOptionsHook(MethodHook):
    """
    Добавляем пункт в меню долгого нажатия на кнопку отправки.
    Фильтруем дубли: на каждый экземпляр ItemOptions добавляем только один раз.
    """
    def __init__(self, plugin):
        super().__init__()
        self.plugin = plugin
        self._icon_id = 0

    def before_hooked_method(self, param):
        try:
            options = param.args[0] if param and hasattr(param, "args") and param.args else None
            if not options:
                return

            # Сохраняем актуальный MessageSendPreview, чтобы принудительно схлопывать его позже
            try:
                self.plugin._last_preview = param.thisObject
            except Exception:
                pass

            # Если пришел новый экземпляр меню — сбросим флаг "добавлено"
            if getattr(self.plugin, "_last_item_options", None) is not options:
                self.plugin._last_item_options = options
                self.plugin._menu_item_added = False

            # Добавляем пункт только если ещё не добавляли на этот экземпляр меню
            if getattr(self.plugin, "_menu_item_added", False):
                return

            if not self.plugin._has_text_to_send():
                return

            title = self.plugin._get_title()
            if not self._icon_id:
                self._icon_id = TelegramUtils.get_fixed_icon_id()

            # Оборачиваем действие так, чтобы закрывать именно текущее меню (options), а не полагаться на last-ref.
            action = RunnableFactory(lambda opts=options: self.plugin._on_send_as_file_click(opts))

            if self._icon_id > 0:
                options.add(self._icon_id, title, action)
            else:
                options.add(title, action)

            self.plugin._menu_item_added = True
        except Exception as e:
            _log(f"setItemOptions hook error: {e}")


class ExamplePlugin(BasePlugin):
    def on_plugin_load(self):
        try:
            set_item_options_hook = MessageSendPreview.getClass().getDeclaredMethod("setItemOptions", ItemOptions)
            self.hook_method(set_item_options_hook, _SetItemOptionsHook(self))
            self._busy = False
            self._last_item_options = None
            self._menu_item_added = False
            self._last_preview = None
        except Exception as e:
            self.log(f"Не удалось установить hook для меню: {e}")

    # ---------- Popup control ----------

    def _dismiss_item_options(self, opts: ItemOptions = None):
        try:
            target = opts if opts is not None else getattr(self, "_last_item_options", None)
            if target is None:
                return
            try:
                target.dismiss()
            except Exception:
                try:
                    popup = getattr(target, "actionBarPopupWindow", None)
                    if popup is not None:
                        try:
                            try:
                                popup.dismiss()
                            except Exception:
                                try:
                                    popup.dismissWithAlphaAnimation()
                                except Exception:
                                    try:
                                        popup.dismiss(True)
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                except Exception:
                    pass
        finally:
            self._last_item_options = None
            self._menu_item_added = False

    def _collapse_preview_force(self):
        try:
            preview = getattr(self, "_last_preview", None)
            if preview is None:
                return
            for method_name, arg in (("dismiss", None), ("hide", None), ("dismissWithAlphaAnimation", None),
                                     ("dismiss", True), ("dismiss", False)):
                try:
                    m = getattr(preview, method_name)
                    if arg is None:
                        m()
                    else:
                        m(arg)
                except Exception:
                    continue
        except Exception:
            pass

    def _collapse_menus(self, opts: ItemOptions = None):
        try:
            self._dismiss_item_options(opts)
            self._collapse_preview_force()
        except Exception:
            pass
        run_on_ui_thread(lambda: (self._dismiss_item_options(opts), self._collapse_preview_force()))
        try:
            AndroidUtilities.runOnUIThread(RunnableFactory(lambda: (self._dismiss_item_options(opts), self._collapse_preview_force())), 120)
        except Exception:
            pass

    # ---------- Reply panel control ----------

    def _clear_reply_context_soft(self, chat_activity: ChatActivity):
        """
        Мягко снимает выбранный ответ из EnterView (без дёрганья клавиатуры).
        """
        if chat_activity is None:
            return
        enter_view = None
        try:
            enter_view = get_private_field(chat_activity, "chatActivityEnterView")
        except Exception:
            enter_view = None
        if enter_view is None:
            return

        # Самые частые сигнатуры
        for args in (
            (None, True, False),   # (message, animated, openKeyboard)
            (None, False, False),
            (None, False),
            (None,),
        ):
            try:
                getattr(enter_view, "setReplyingMessageObject")(*args)
                return
            except Exception:
                pass

    def _notify_message_sent_delegate(self, chat_activity: ChatActivity):
        """
        Триггерим стандартную логику после отправки через делегат EnterView, чтобы UI сам убрал reply как обычно.
        """
        if chat_activity is None:
            return
        enter_view = None
        try:
            enter_view = get_private_field(chat_activity, "chatActivityEnterView")
        except Exception:
            enter_view = None
        if enter_view is None:
            return

        delegate = None
        try:
            delegate = get_private_field(enter_view, "delegate")
        except Exception:
            delegate = None
        if delegate is None:
            return

        # Пробуем распространённые сигнатуры onMessageSend(...)
        for args in (
            (None, True, 0, 0),
            ("", True, 0, 0),
            (None, True, 0),
            ("", True, 0),
        ):
            try:
                getattr(delegate, "onMessageSend")(*args)
                return
            except Exception:
                continue

    # ---------- Menu action ----------

    def _clear_input_field(self, chat_activity: ChatActivity):
        enter_view = None
        try:
            enter_view = get_private_field(chat_activity, "chatActivityEnterView")
        except Exception:
            enter_view = None

        if enter_view is None:
            return

        try:
            enter_view.setFieldText("")
            return
        except Exception:
            pass

        try:
            edit = enter_view.getEditField()
            if edit is not None:
                try:
                    edit.setText("")
                except Exception:
                    pass
                try:
                    edit.setSelection(0)
                except Exception:
                    pass
        except Exception:
            pass

    def _on_send_as_file_click(self, options_instance: ItemOptions = None):
        if getattr(self, "_busy", False):
            return
        self._busy = True

        self._collapse_menus(options_instance)

        try:
            fragment = get_last_fragment()
        except Exception:
            fragment = None

        if fragment is None or not isinstance(fragment, ChatActivity):
            self._busy = False
            return

        text = self._get_current_input_text(fragment)
        if not text or not str(text).strip():
            self._busy = False
            return

        try:
            self._clear_input_field(fragment)
        except Exception:
            pass

        run_on_queue(lambda: self._prepare_and_send_txt(fragment, str(text)))

    # -------- Helpers --------

    def _get_title(self) -> str:
        try:
            lang = (Locale.getDefault().getLanguage() or "en").lower()
        except Exception:
            lang = "en"
        return "Отправить файлом" if lang.startswith("ru") else "Send as file (.txt)"

    def _has_text_to_send(self) -> bool:
        fragment = get_last_fragment()
        if fragment is None or not isinstance(fragment, ChatActivity):
            return False
        text = self._get_current_input_text(fragment)
        return bool(text and str(text).strip())

    def _get_current_input_text(self, chat_activity: ChatActivity) -> str:
        enter_view = None
        try:
            enter_view = get_private_field(chat_activity, "chatActivityEnterView")
        except Exception:
            enter_view = None

        if enter_view is not None:
            try:
                txt = enter_view.getFieldText()
                if txt is not None:
                    return str(txt)
            except Exception:
                pass
            try:
                edit = enter_view.getEditField()
                if edit is not None:
                    t = edit.getText() if hasattr(edit, "getText") else None
                    if t is not None:
                        return str(t.toString())
            except Exception:
                pass

        return ""

    def _resolve_reply_objects(self, chat_activity: ChatActivity):
        """
        Извлекает текущий контекст ответа:
        - replyToMsg (MessageObject)
        - replyToTopMsg (MessageObject)
        """
        reply_msg = None
        reply_top = None

        # 1) ChatActivity public helpers
        for name in ("getReplyingMessageObject", "getReplyingMessage", "getReplyMessageObject"):
            try:
                m = getattr(chat_activity, name, None)
                if m:
                    obj = m()
                    if obj is not None:
                        reply_msg = obj
                        break
            except Exception:
                pass
        for name in ("getReplyingTopMessage", "getThreadMessage", "getTopicMessage", "getTopMessage"):
            try:
                m = getattr(chat_activity, name, None)
                if m:
                    obj = m()
                    if obj is not None:
                        reply_top = obj
                        break
            except Exception:
                pass

        # 2) From EnterView (methods)
        enter_view = None
        try:
            enter_view = get_private_field(chat_activity, "chatActivityEnterView")
        except Exception:
            enter_view = None

        if enter_view is not None:
            if reply_msg is None:
                for name in ("getReplyingMessageObject", "getReplyingMessage"):
                    try:
                        m = getattr(enter_view, name, None)
                        if m:
                            obj = m()
                            if obj is not None:
                                reply_msg = obj
                                break
                    except Exception:
                        pass
            if reply_top is None:
                for name in ("getReplyingTopMessage", "getThreadMessage", "getTopicMessage", "getTopMessage"):
                    try:
                        m = getattr(enter_view, name, None)
                        if m:
                            obj = m()
                            if obj is not None:
                                reply_top = obj
                                break
                    except Exception:
                        pass
            # 3) Private fields
            if reply_msg is None:
                try:
                    obj = get_private_field(enter_view, "replyingMessageObject")
                    if obj is not None:
                        reply_msg = obj
                except Exception:
                    pass
            if reply_top is None:
                for field in ("replyingTopMessage", "threadMessage", "topicMessage", "topMessage"):
                    try:
                        obj = get_private_field(enter_view, field)
                        if obj is not None:
                            reply_top = obj
                            break
                    except Exception:
                        pass

        # 4) Private fields in ChatActivity as fallback
        if reply_msg is None:
            try:
                obj = get_private_field(chat_activity, "replyingMessageObject")
                if obj is not None:
                    reply_msg = obj
            except Exception:
                pass
        if reply_top is None:
            for field in ("replyingTopMessage", "threadMessage", "topicMessage", "topMessage"):
                try:
                    obj = get_private_field(chat_activity, field)
                    if obj is not None:
                        reply_top = obj
                        break
                except Exception:
                    pass

        try:
            if reply_msg is not None and not isinstance(reply_msg, MessageObject):
                reply_msg = None
        except Exception:
            pass
        try:
            if reply_top is not None and not isinstance(reply_top, MessageObject):
                reply_top = None
        except Exception:
            pass

        return reply_msg, reply_top

    def _prepare_and_send_txt(self, chat_activity: ChatActivity, text: str):
        try:
            from datetime import datetime
            fname = f"message-{datetime.now().strftime('%Y%m%d-%H%M%S-%f')}.txt"

            # Директория
            base_dir = None
            try:
                base_dir = AndroidUtilities.getCacheDir()
            except Exception:
                try:
                    ctx = ApplicationLoader.applicationContext
                    base_dir = ctx.getCacheDir()
                except Exception:
                    base_dir = None
            if base_dir is None:
                try:
                    base_dir = ApplicationLoader.getFilesDirFixed()
                except Exception:
                    base_dir = ApplicationLoader.applicationContext.getFilesDir()

            tmp_dir = File(base_dir, "plugin_send_as_file")
            if not tmp_dir.exists():
                tmp_dir.mkdirs()
            out_file = File(tmp_dir, fname)

            # Записываем .txt
            fos = None
            try:
                fos = FileOutputStream(out_file)
                fos.write(bytes(text, "utf-8"))
                fos.flush()
            finally:
                if fos is not None:
                    try:
                        fos.close()
                    except Exception:
                        pass

            # dialogId / account
            dialog_id = 0
            try:
                dialog_id = chat_activity.getDialogId()
            except Exception:
                try:
                    dialog_id = get_private_field(chat_activity, "dialog_id") or 0
                except Exception:
                    dialog_id = 0

            current_account = 0
            try:
                current_account = chat_activity.getCurrentAccount()
            except Exception:
                try:
                    current_account = get_private_field(chat_activity, "currentAccount") or 0
                except Exception:
                    current_account = 0

            # Извлекаем контекст ответа (replyToMsg и replyToTopMsg) для корректной отправки в теме
            reply_to_msg, reply_to_top_msg = self._resolve_reply_objects(chat_activity)

            # Отправляем на UI
            run_on_ui_thread(lambda: self._send_document_file(chat_activity, dialog_id, out_file, "text/plain", fname, current_account, reply_to_msg, reply_to_top_msg))
        except Exception as e:
            _log(f"Ошибка при подготовке/отправке: {e}")
            run_on_ui_thread(self._reset_busy)

    def _reset_busy(self):
        self._busy = False

    def _send_document_file(self, chat_activity: ChatActivity, dialog_id: int, file_obj: File, mime: str, file_name: str, account: int,
                            reply_to_msg: MessageObject = None, reply_to_top_msg: MessageObject = None):
        """
        ВАЖНО: передаем ТОЛЬКО один источник (paths/originals ИЛИ uris), иначе некоторые сборки отправляют дубли.
        Здесь используем paths+originals, uris оставляем пустым.
        """
        try:
            abs_path = file_obj.getAbsolutePath()

            paths = ArrayList()
            originals = ArrayList()
            uris = ArrayList()  # оставляем пустым, чтобы не было дублей

            paths.add(abs_path)         # String
            originals.add(abs_path)     # String

            accountInstance = AccountInstance.getInstance(account)

            # Пробрасываем replyToMsg и replyToTopMsg, чтобы в темах отправлялось в текущую тему
            SendMessagesHelper.prepareSendingDocuments(
                accountInstance,
                paths, originals, uris,
                "", mime,
                jlong(dialog_id),
                reply_to_msg, reply_to_top_msg,
                None, None,
                None,
                True, 0,
                None,
                None, 0,
                0, False, 0
            )

            # Схлопываем меню/превью после старта отправки
            self._collapse_menus(None)

            # 1) Сообщаем делегату EnterView, чтобы он выполнил стандартный post-send (снимает reply)
            try:
                self._notify_message_sent_delegate(chat_activity)
            except Exception:
                pass

            # 2) На всякий случай мягко убираем reply вручную (если делегат не сработал)
            try:
                self._clear_reply_context_soft(chat_activity)
            except Exception:
                pass

        except Exception as e:
            _log(f"prepareSendingDocuments failed: {e}")
        finally:
            self._reset_busy()